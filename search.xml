<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客搭建记录（一）：本地搭建以及部署到Github</title>
    <url>/2019/07/db311df41612.html</url>
    <content><![CDATA[<p>程序猿作为技术人员，都应该拥有一个自己的技术博客，在他人推荐下，我个人搭建了Hexo+Github的博客系统。</p>
<p>本文讲述如何部署一个 Hexo+Github 的博客系统。</p>
<span id="more"></span>

<blockquote>
<p>该记录全程为Windows系统下，其他操作系统自行处理。</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>一台电脑 （-_-）</li>
<li>一个注册好的Github账号</li>
<li>一款shell工具（我们可以用Git Bash代替）</li>
<li>Node.js环境</li>
<li>Git</li>
</ol>
<hr>
<h3 id="一、安装配置Node-js"><a href="#一、安装配置Node-js" class="headerlink" title="一、安装配置Node.js"></a>一、安装配置Node.js</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。</p>
<p>hexo 是基于Node.js来构建博客的，得益于Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>
<p>首先我们去官网 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnLw==">Node.js<i class="fa fa-external-link-alt"></i></span> 下载安装包</p>
<p>网站会自动识别你的操作系统，这里我们选择<strong>LTS</strong> 也就是长期支持版。<img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120230.png"></p>
<p>安装步骤没有什么要求，点下一步就是了，如不出意外，你的开始菜单里面应该有这两个文件。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120237.png"></p>
<p>确保安装成功，您可以打开cmd或其他命令行工具输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>如有</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120242.png"></p>
<p>版本数字不一定和我一样，有的话说明安装成功</p>
<hr>
<h3 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h3><p>Git是什么，Git是一种版本控制系统，区别于svn，是目前最先进的一种版本控制系统，这里我不详细介绍，大家有想深入了解的话可以去这里  <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw">廖雪峰的 Git 教程<i class="fa fa-external-link-alt"></i></span><br>我们这里安装Git的目的，一是为了下载从Github下载 <code>hexo</code> 的一些工具资源，二是其提供了<code>Git Bash</code> shell 工具，我们的Hexo配置操作都需要用到。</p>
<p>Git的官网  <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=">官网下载Git<i class="fa fa-external-link-alt"></i></span>, 但Git的官网下载速度会抽风，如无爬山工具，也可以这里下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGFuem91cy5jb20vaTQ3emNnag==">镜像下载Git<i class="fa fa-external-link-alt"></i></span> 。                                                                                                                                           安装步骤依然是一直点下一步就是了。</p>
<p><span style="color:red">注意：</span></p>
<blockquote>
<p>安装完成后，还有记得要配置Git本地的邮箱和用户名，如不配置，后面的操作可能会出现问题。<br>具体的配置可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5NjA2NzA3NDMzODQ5Ng==">廖雪峰 ：Git安装与配置<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<h3 id="三、配置本地Hexo"><a href="#三、配置本地Hexo" class="headerlink" title="三、配置本地Hexo"></a>三、配置本地Hexo</h3><h4 id="1-配置hexo全局控制命令"><a href="#1-配置hexo全局控制命令" class="headerlink" title="1.配置hexo全局控制命令"></a>1.配置hexo全局控制命令</h4><p>​	在cmd或者其他命令行工具下输入如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>


<blockquote>
<p>用npm 命令时可能会提示warning,只要不是error，一般来说都不用太过担心。<br>另一个就是执行<code> npm install</code>下载时可能会很久不动好像卡了一样，不用太担心，这		都是正常情况，可以多等一会，或者使用爬山工具。</p>
</blockquote>
<h4 id="2-下载Hexo-工具"><a href="#2-下载Hexo-工具" class="headerlink" title="2.下载Hexo 工具"></a>2.下载Hexo 工具</h4><h5 id="2-1初始化博客目录"><a href="#2-1初始化博客目录" class="headerlink" title="2.1初始化博客目录"></a>2.1初始化博客目录</h5><p>  首先准备一个目录存放你的博客网站文件，例如我的是 <strong>&#x2F;e&#x2F;blog</strong>，也就是在E盘根目录新建了一个<strong>blog</strong>文件夹</p>
<p>  然后我们进入该目录，点击鼠标右键，然后点击 <code>git bash</code> 出现一个命令窗口，接下来我们的大多数操作都用它来完成。</p>
<blockquote>
<p><code>Git Bash</code>在这里并不是唯一的选择，如您熟悉其他命令工具，也可以使用其他工具，这里使用<code>Git Bash</code>是为了减少更多不必要的麻烦</p>
</blockquote>
<p>在 <code>Git Bash</code>窗口下输入如下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>按下回车Enter，<code>Git bash</code> 会自动下载相关文件，如下图</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120248.png"></p>
<blockquote>
<p>速度可能会很慢，请耐心等待，若是在这步出现以下错误 :<br><code>error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054    </code><br><code>fatal: the remote end hung up unexpectedly </code><br><code>fatal: protocol error: bad pack header</code><br><code>WARN  git clone failed. Copying data instead</code><br><code>WARN  Failed to install dependencies. Please run &#39;npm install&#39; manually!  </code></p>
<p>或是一直卡百分比，我们在 <code>Git Bash</code> 中按 <code>Ctrl+C</code> 取消下载，然后删除文件夹中所有文件，重新执行上面的  <code>hexo init</code> 命令</p>
</blockquote>
<p>若出现：<br><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120255.png"></p>
<p>则表示文件下载成功。</p>
<h5 id="2-2-本地生成运行"><a href="#2-2-本地生成运行" class="headerlink" title="2.2 本地生成运行"></a>2.2 本地生成运行</h5><p>在<code>Git Bash</code>窗口下，依次执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>这样，Hexo会默认运行在你本机的4000端口上，然后我们在浏览器中输入<code>http://localhost:4000</code> 即可显示如下页面：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120301.png"></p>
<p>这个页面是hexo默认初始化的一个页面，主题为landscape。</p>
<hr>
<h3 id="三、部署到GitPage"><a href="#三、部署到GitPage" class="headerlink" title="三、部署到GitPage"></a>三、部署到GitPage</h3><blockquote>
<p>这个步骤开始前，请确保你已经注册了Github账号，且已经配置好了相关信息，配置方法请向上翻阅  <strong>二、安装Git</strong>  环节下。</p>
</blockquote>
<h4 id="1-在Github创建仓库。"><a href="#1-在Github创建仓库。" class="headerlink" title="1.在Github创建仓库。"></a>1.在Github创建仓库。</h4><p>打开  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">Github官网<i class="fa fa-external-link-alt"></i></span>  登陆你的Github账号，点击页面右上角的 <code>+</code> 、<code>New repository</code>新建一个<code>repository</code>仓库</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120320.png"></p>
<p>为避免麻烦，这里仓库名必须按照<code>yourusername.github.io</code>规范填写，填写完仓库名后，我们点击<code>Create repository</code>按钮，然后等待其创建完成。复制该项目的HTTP链接<code>https://github.com/yourusername/yourusername.github.io.git</code></p>
<blockquote>
<p><code>yourusername</code>指的就是你的github用户名，本文中出现的该字段都表示这个意思。</p>
</blockquote>
<h4 id="2-Hexo-配置"><a href="#2-Hexo-配置" class="headerlink" title="2.Hexo 配置"></a>2.Hexo 配置</h4><p>打开 <code>Git Bash</code> 切换到博客的根目录，输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-depolyer-git --save</span><br></pre></td></tr></table></figure>

<p>出现</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120416.png"></p>
<p>表示安装成功。</p>
<p>然后输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim _config.<span class="property">yml</span></span><br></pre></td></tr></table></figure>

<p>进入站点配置文件编辑模式，我们向下翻到底部，可以看到 <code>depoly</code> 字段</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120420.png"></p>
<p>在英文输入模式下，按键盘上的 <code>i</code>键进入编辑模式，将<code>depoly</code>字段编辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  <span class="attr">type</span>: git</span><br><span class="line">  <span class="attr">repo</span>:</span><br><span class="line">  44<span class="attr">github</span>: <span class="attr">https</span>:<span class="comment">//github.com/yourusername/yourusername.github.io.git</span></span><br><span class="line">  <span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure>

<p>注意这里<code>:</code>后面一定要加空格，不然会出错。</p>
<p>然后我们按<code>Esc</code> 键，输入<code>:wq</code> 保存退出</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120428.png"></p>
<h4 id="3-完成部署"><a href="#3-完成部署" class="headerlink" title="3.完成部署"></a>3.完成部署</h4><p>在命令行输入并执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>其中，<code>hexo d</code> 则是将本地文件推送到远程。</p>
<p>在第一次推送时，会出现：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120437.png"></p>
<p>这是提示要输入你的Github账号密码，因为是第一次推送，Windows要验证账号密码才能确认推送部署到你的Github上,输入账号密码,账号为你注册的邮箱。</p>
<p>推送完成后，我们在浏览器打开   <code>yourusername.github.io</code> 即可看到我们部署好的博客，例如我的博客地址：<span class="exturl" data-url="aHR0cHM6Ly9xaWFuZmFuZ3VvamluLmdpdGh1Yi5pby8=">小谢同学<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>GitPage效果并不是立即生效的，如果出现访问失败，可以等一下再访问。</p>
</blockquote>
<hr>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pZ2h0bWFyZV9kaW1wbGUvYXJ0aWNsZS9kZXRhaWxzLzg2NjYxNDY1">https://blog.csdn.net/nightmare_dimple&#x2F;article&#x2F;details&#x2F;86661465<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">hexo官方文档<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建记录（二）：基本主题设置以及美化</title>
    <url>/2019/07/8207eb86d277.html</url>
    <content><![CDATA[<p>前一篇博客我主要介绍了如何一点一点搭建起Hexo博客系统，搭建方式还是挺简单的，但是Hexo的默认主题样式可能对于大多数人来说并不是足够炫酷，接下来我介绍一些Hexo的主题美化操作。</p>
<span id="more"></span>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>随着 Hexo 版本以及 Next 主题版本的更新，文章中的某些功能或者设置不可用，请注意检查版本。</p>
<p>本文编写时使用的版本：</p>
<ul>
<li>Hexo版本：4.2.1</li>
<li>next 主题版本：7.7.2</li>
</ul>
<h3 id="1-更改主题。"><a href="#1-更改主题。" class="headerlink" title="1. 更改主题。"></a>1. 更改主题。</h3><p>Hexo的支持很多不同的主题，我们可以在<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">Hexo主题页<i class="fa fa-external-link-alt"></i></span>去寻找自己喜欢的主题，我目前使用的就是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">Next<i class="fa fa-external-link-alt"></i></span> 这款主题，下面我都围绕最新版 Next 7.2 来一步步说明如何进行美化。</p>
<p><span style="color:red">注意</span></p>
<blockquote>
<p>在Hexo目录下有两份重要的配置文件，其名称都是<code>_config.yml</code> 。其中，一份位于站点根目录下，主要包含<code>Hexo</code>的自身配置，另一份位于主题目录下，主要用于配置主题相关的选项。<br>在接下来的描述中，我将前者称为  <strong>站点配置文件</strong>，后者称为  <strong>主题配置文件</strong> 。</p>
</blockquote>
<h4 id="1-1-安装Next"><a href="#1-1-安装Next" class="headerlink" title="1.1 安装Next"></a>1.1 安装Next</h4><p>安装Next主题的方式很简单，利用Git bash 在博客主目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>然后我们打开站点配置文件，将theme属性从默认值landscape改为next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住，所有的配置属性<code>:</code> 后面都要加一个空格,这样我们设定的值才会生效。</p>
</blockquote>
<p>这样我们即将主题修改为Next主题。</p>
<h4 id="1-2-选择不同的Next主题样式"><a href="#1-2-选择不同的Next主题样式" class="headerlink" title="1.2 选择不同的Next主题样式"></a>1.2 选择不同的Next主题样式</h4><p>Next提供了四种主题风格scheme,可以在主题配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种 Muse</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115945.png"></p>
</li>
<li><p>第二种 Mist</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115958.png"></p>
</li>
<li><p>第三种 Pisces</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120004.png"></p>
</li>
<li><p>第四种 Gemini</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120011.png"></p>
</li>
</ul>
<p>选择哪种风格基于个人喜好，我这里选的是最后一种<code>Gemini</code></p>
<hr>
<h3 id="2-更改站点属性（网站名，语言，作者）"><a href="#2-更改站点属性（网站名，语言，作者）" class="headerlink" title="2. 更改站点属性（网站名，语言，作者）"></a>2. 更改站点属性（网站名，语言，作者）</h3><p>打开站点配置文件，找到<code>site</code>字段，具体修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置网站属性信息</span><br><span class="line"># Site:</span><br><span class="line">title: 小白的博客 #网站标题（博客站点名字）。</span><br><span class="line">subtitle: 小小白 #网站副标题，显示在标题下方</span><br><span class="line">description: 我是小白 #个人描述，类似签名，用于搜索引擎对站点的描述，建议在里面加上你的站点的关键词</span><br><span class="line">keywords:</span><br><span class="line">author: 小白 #博客文章作者</span><br><span class="line">language: zh-CN  #设置博客站点语言为中文</span><br><span class="line">timezone:  #设置时区，默认当前电脑时区</span><br></pre></td></tr></table></figure>

<p>设置效果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120018.png"></p>
<hr>
<h3 id="3-菜单栏"><a href="#3-菜单栏" class="headerlink" title="3. 菜单栏"></a>3. 菜单栏</h3><h4 id="3-1-显示更多栏目"><a href="#3-1-显示更多栏目" class="headerlink" title="3.1 显示更多栏目"></a>3.1 显示更多栏目</h4><p>在主题配置文件中修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home # 首页</span><br><span class="line">  about: /about/ || user # 关于</span><br><span class="line">  tags: /tags/ || tags # 标签</span><br><span class="line">  categories: /categories/ || th # 分类</span><br><span class="line">  archives: /archives/ || archive  # 归档</span><br><span class="line">  # schedule: /schedule/ || calendar # 日历</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap # 站点地图</span><br><span class="line">  # commonweal: /404/ || heartbeat # 腾讯公益404</span><br></pre></td></tr></table></figure>



<h4 id="3-2-图标和内容量"><a href="#3-2-图标和内容量" class="headerlink" title="3.2 图标和内容量"></a>3.2 图标和内容量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu_settings:</span><br><span class="line">  icons: true # 是否显示各个页面的图标</span><br><span class="line">  badges: true # 是否显示分类/标签/归档页的内容量</span><br></pre></td></tr></table></figure>



<h4 id="3-3-效果图"><a href="#3-3-效果图" class="headerlink" title="3.3 效果图"></a>3.3 效果图</h4><p>以上修改如下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120026.png"></p>
<hr>
<h3 id="4-侧边栏"><a href="#4-侧边栏" class="headerlink" title="4. 侧边栏"></a>4. 侧边栏</h3><p>以下设置都是在<strong>主题配置</strong>文件中</p>
<h4 id="4-1-显示可跳转-日志-分类-标签页-的链接"><a href="#4-1-显示可跳转-日志-分类-标签页-的链接" class="headerlink" title="4.1 显示可跳转 日志 &#x2F; 分类 &#x2F; 标签页 的链接"></a>4.1 显示可跳转 日志 &#x2F; 分类 &#x2F; 标签页 的链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Posts / Categories / Tags in sidebar.</span><br><span class="line">site_state: true</span><br></pre></td></tr></table></figure>



<h4 id="4-2-社交信息设置"><a href="#4-2-社交信息设置" class="headerlink" title="4.2 社交信息设置"></a>4.2 社交信息设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  Weibo: https://weibo.com/yourname || weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure>

<p>Next 默认给出了一些模板，我们只要将其中的链接改为自己的链接就可以了，当然你也可以自己定义，格式为</p>
<p>名字: 链接 || 图标名，图标必须是<span class="exturl" data-url="aHR0cDovL2ZvbnRhd2Vzb21lLmRhc2hnYW1lLmNvbS8=">FontAwesome<i class="fa fa-external-link-alt"></i></span>网站中能找到的图标名。</p>
<p>例如我添加我的博客地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qianfanguojin: https://qianfanguojin.github.io/ || codepen</span><br></pre></td></tr></table></figure>



<h4 id="4-3-圆形头像设置"><a href="#4-3-圆形头像设置" class="headerlink" title="4.3 圆形头像设置"></a>4.3 圆形头像设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.jpg #头像文件目录</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true #设置鼠标放在头像上面是否旋转</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: true #头像是否设为圆形</span><br></pre></td></tr></table></figure>

<p>将自己喜欢的头像头像按照需求自己更换自己喜欢的就可以了，不过这里要注意一下头像可能会变成椭圆，如果头像是椭圆的，是因为图片不是一个正方形的图片，找到一个宽高像素一样的的图片即可。</p>
<p>以上修改如下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120033.png"></p>
<h4 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4 其他"></a>4.4 其他</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true #自动生成目录</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true #自动产生目录编号</span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false #标题过长是否换行</span><br><span class="line">  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span><br><span class="line">  expand_all: false # 是否显示所有等级的目录项。</span><br><span class="line">  # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span><br><span class="line">  max_depth: 6 #最大标题嵌套个数</span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position.#侧边栏的位置</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Manual define the sidebar width. If commented, will be default for:</span><br><span class="line">  # Muse | Mist: 320</span><br><span class="line">  # Pisces | Gemini: 240</span><br><span class="line">  #width: 300</span><br><span class="line"></span><br><span class="line">  # Sidebar Display (only for Muse | Mist), available values:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically.</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  totally remove sidebar including sidebar toggle.</span><br><span class="line">  display: post</span><br><span class="line"></span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12 # 侧边栏相对主菜单的像素距离</span><br><span class="line">  # Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">  onmobile: false #在手机上侧边栏是否显示</span><br><span class="line"></span><br><span class="line"># 返回顶部</span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false  #侧边栏显示返回顶部信息,默认显示在页面右下方</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: #显示百分比</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-页面设置"><a href="#5-页面设置" class="headerlink" title="5. 页面设置"></a>5. 页面设置</h3><h4 id="5-1-鼠标点击红心"><a href="#5-1-鼠标点击红心" class="headerlink" title="5.1 鼠标点击红心"></a>5.1 鼠标点击红心</h4><p>目前网上大多数文章都是在<code>themes/next/source/js/src</code> 下新建文件，但笔者写这篇文章时最新版Next已经没有<code>src</code>文件夹了 ，于是，我们可以在<code>themes/next/source/js/</code>下新建<code>clicklove.js</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在修改<code>themes/next/layout/_layout.swig</code> 文件末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&#123;% if theme.clicklove %&#125;</span><br><span class="line">      &lt;script type=&quot;text/javascript&quot; src=&quot;/js/clicklove.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">注意</span></p>
<blockquote>
<p>很多人配置正确但不显示的原因主要出在这里，也就是<code>src</code> 后面的文件链接错误，hexo中使用的是相对路径，也就是说,只要你不指定为绝对路径,设置的链接都将是<code>root+url</code>的形式，一般来说，大多数用户默认的<code>root</code> 都为<code>/</code> ，但是有些情况，例如设置了Git Page ,要修改<code>root</code>的路径，<code>root</code>路径我们可以在 <strong>站点配置文件</strong> 中找到：</p>
</blockquote>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120042.png"></p>
<p>上图就是在我设置了Git Page后 <code>root</code>路径的值，在这种情况下，我们在修改<code>themes/next/layout/_layout.swig</code> 文件时，<code>src</code> 的路径都应该加上<code>root</code> 的路径值，因此，在这种情况下代码应修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&#123;% if theme.clicklove %&#125;</span><br><span class="line">      &lt;script type=&quot;text/javascript&quot; src=&quot;/fa/js/clicklove.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>确定无误后最后在主题配置文件末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示页面红心</span><br><span class="line">clicklove: true</span><br></pre></td></tr></table></figure>





<h4 id="5-2-添加动态背景"><a href="#5-2-添加动态背景" class="headerlink" title="5.2 添加动态背景"></a>5.2 添加动态背景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置动态背景</span><br><span class="line"># Canvas-nest</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &quot;0,0,255&quot; # RGB values, use `,` to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 170 # the number of lines</span><br><span class="line"></span><br><span class="line"># JavaScript 3D library.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-three</span><br><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  delay: false # Set true to further delay loading</span><br><span class="line">  three_waves: true</span><br><span class="line">  canvas_lines: false</span><br><span class="line">  canvas_sphere: false</span><br><span class="line"></span><br><span class="line"># Canvas-ribbon</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br><span class="line">  size: 300 # The width of the ribbon</span><br><span class="line">  alpha: 0.6 # The transparency of the ribbon</span><br><span class="line">  zIndex: -1 # The display level of the ribbon</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新版Next已经支持了上面三种动态背景方式，大家想用哪种就将该项的<code>enable</code> 设为 <code>true</code>,具体效果大家自己尝试，一般用的是第一种。</p>
<p>当然，指明要用那种，但是Next没有自带该动画的包，我们要自己下载，链接就在注释中<code># Dependencies</code> 项后面 ，例如我下载第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure>

<p>链接后的是指定下载后放到的文件夹名，大家要注意是放在<code>lib</code> 下且文件夹名字应该和上面的设置项名字一样。</p>
<h4 id="5-3-博客底部基本布局"><a href="#5-3-博客底部基本布局" class="headerlink" title="5.3 博客底部基本布局"></a>5.3 博客底部基本布局</h4><p>这里我就不细说了，大家参照注释自己修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 博客底部布局</span><br><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  #since: 2015 #设置建站时间，不设置则默认为当前年份</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span><br><span class="line">    # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">    name: heart  # 作者图标，默认为author，自定义的图标需来自fontawesome中</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: true  # 图标是否闪动</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot; # 图标颜色</span><br><span class="line"></span><br><span class="line">  # If not defined, `author` from Hexo `_config.yml` will be used.</span><br><span class="line">  copyright: 小白 #设置底部显示的名字，默认为站点配置文件的author名字</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    # Hexo link (Powered by Hexo).</span><br><span class="line">    enable: false # 是否显示 Powered By Hexo</span><br><span class="line">    # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">    version: false # 是否显示 Hexo 版本</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false # 是否显示主题信息</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false # 是否显示主题版本</span><br><span class="line"></span><br><span class="line">  # Beian ICP information for Chinese users. See: http://www.beian.miit.gov.cn</span><br><span class="line">  beian:</span><br><span class="line">    enable: false # 是否显示网站备案信息</span><br><span class="line">    icp:</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-6-底部显示busuanzi博客访客-访问次数统计"><a href="#5-6-底部显示busuanzi博客访客-访问次数统计" class="headerlink" title="5.6 底部显示busuanzi博客访客&#x2F;访问次数统计"></a>5.6 底部显示busuanzi博客访客&#x2F;访问次数统计</h4><p>修改主题配置文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不蒜子统计功能</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true # 是否开启busuanzi统计功能</span><br><span class="line">  total_visitors: true # 是否统计总访客数</span><br><span class="line">  total_visitors_icon: user # 访客数图标</span><br><span class="line">  total_views: true # 是否显示同级总访问次数</span><br><span class="line">  total_views_icon: eye # 总访问次数的图标</span><br><span class="line">  post_views: true # 是否显示单个文章查看次数</span><br><span class="line">  post_views_icon: eye # 文章被查看次数的图标</span><br></pre></td></tr></table></figure>



<h4 id="5-5-右上角显示Github标识"><a href="#5-5-右上角显示Github标识" class="headerlink" title="5.5 右上角显示Github标识"></a>5.5 右上角显示Github标识</h4><p>修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># `Follow me on GitHub` banner in the top-right corner.</span><br><span class="line"># Github 跳转图标</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true # 功能开关</span><br><span class="line">  permalink: https://github.com/yourname # Github主页地址</span><br><span class="line">  title: Follow me on GitHub # 鼠标悬停显示的文字</span><br></pre></td></tr></table></figure>



<h4 id="5-6-接入网易云播放器"><a href="#5-6-接入网易云播放器" class="headerlink" title="5.6 接入网易云播放器"></a>5.6 接入网易云播放器</h4><p>首先在网易云音乐网页端搜索你想播放的音乐（有版权保护的不行）：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120059.png"></p>
<p>然后点击生成外链播放器，得到外链的html代码：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120107.png"></p>
<p>然后我们将代码粘贴到一个合适的位置，建议在侧边栏，对应的文件是<code>themes/next/layout/_macro/sidebar.swig</code> ，不同的位置效果呈现的效果不同，例如我的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;site-overview-wrap sidebar-panel&#123;% if not display_toc or toc(page.content).length &lt;= 1 %&#125; sidebar-panel-active&#123;% endif %&#125;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;site-overview&quot;&gt;</span><br><span class="line"></span><br><span class="line">          &#123;&#123; partial(&#x27;_partials/sidebar/site-overview.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">          &#123;% for inject_item in theme.injects.sidebar %&#125;</span><br><span class="line">            &#123;&#123; partial(inject_item.layout, inject_item.locals, inject_item.options) &#125;&#125;</span><br><span class="line">          &#123;% endfor %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">44&lt;!--网易云链接--&gt;</span><br><span class="line">44&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=33419765&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>效果就是这样：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120115.png"></p>
<p>这里大家自己根据需求设置就行了。</p>
<hr>
<h3 id="6-文章内容相关"><a href="#6-文章内容相关" class="headerlink" title="6 文章内容相关"></a>6 文章内容相关</h3><h4 id="6-1-文章摘要显示（显示阅读全文按钮）"><a href="#6-1-文章摘要显示（显示阅读全文按钮）" class="headerlink" title="6.1 文章摘要显示（显示阅读全文按钮）"></a>6.1 文章摘要显示（显示阅读全文按钮）</h4><ul>
<li><p>自动形成摘要模式</p>
<p>打开主题配置文件，修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150 # 截取的内容长度</span><br><span class="line"></span><br><span class="line"># Read more button</span><br><span class="line"># If true, the read more button would be displayed in excerpt section.</span><br><span class="line">read_more_btn: true # 是否显示阅读全文按钮</span><br></pre></td></tr></table></figure>

<p>但是这样的方式不够自由，我们可以使用如下方式：</p>
</li>
<li><p>使用 <code>&lt;!--more--&gt; </code> 标签分隔，格式如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120120.png"></p>
<p>这样，<code>&lt;!--more--&gt;</code> 标签上的内容为概述，下面为正文，效果如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120126.png"></p>
</li>
</ul>
<h4 id="6-2-代码块设置"><a href="#6-2-代码块设置" class="headerlink" title="6.2 代码块设置"></a>6.2 代码块设置</h4><p>使用参照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 代码块设置</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  # 代码块主题, 可选的值为 normal; night; night eighties; night blue; night bright</span><br><span class="line">  highlight_theme: night</span><br><span class="line">  # Add copy_button on codeblock</span><br><span class="line">  # 显示复制按钮</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:  # 按钮显示格式</span><br></pre></td></tr></table></figure>

<p>代码块样式的具体内容可以查看官方文档  <span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20vdGhlbWUtc2V0dGluZ3MuaHRtbCNzeW50YXgtaGlnaGxpZ2h0LXNjaGVtZQ==">http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="6-3-添加打赏"><a href="#6-3-添加打赏" class="headerlink" title="6.3 添加打赏"></a>6.3 添加打赏</h4><p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120132.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Reward (Donate)</span><br><span class="line">#打赏设置</span><br><span class="line">reward_settings:</span><br><span class="line">  #If true, reward would be displayed in every article by default.</span><br><span class="line">  #You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter.</span><br><span class="line">  enable: true # 功能开关</span><br><span class="line">  animation: true # 动画</span><br><span class="line">  #comment: Donate comment here.</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: /images/wechatpay.png # 微信捐赠二维码图片</span><br><span class="line">  #alipay: /images/alipay.png # 支付宝捐赠二维码图片</span><br><span class="line">  #bitcoin: /images/bitcoin.png # 比特币</span><br></pre></td></tr></table></figure>



<h4 id="6-4-添加版权信息"><a href="#6-4-添加版权信息" class="headerlink" title="6.4 添加版权信息"></a>6.4 添加版权信息</h4><p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120140.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Creative Commons 4.0 International License.</span><br><span class="line">#See: https://creativecommons.org/share-your-work/licensing-types-examples</span><br><span class="line">#Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">#You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span><br><span class="line">#CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa #许可协议</span><br><span class="line">  sidebar: true #侧边栏显示</span><br><span class="line">  post: true #文章底部显示</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>



<h4 id="6-5-添加文章结束提示语"><a href="#6-5-添加文章结束提示语" class="headerlink" title="6.5 添加文章结束提示语"></a>6.5 添加文章结束提示语</h4><p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120147.png"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------------- 本文结束 &lt;i class=&quot;fa fa-heart-o&quot;&gt;&lt;/i&gt; 感谢您的阅读-------------</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你想简单一点实现，直接复制这段代码，然后将其插入到 <code>themes/next/layout/_macro/post.swig</code> 文件的如下位置：</li>
</ul>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120151.png"></p>
<ul>
<li><p>当然，我们大多时候对功能都需要一个灵活性，也就是可以开关。为了实现这样的效果，我们先在<code>themes/next/layout/_macro/</code> 新建 <code>post-end-text.swig</code> 文件，将上面的 <strong>核心代码</strong> 添加进去。<br>然后我们修改<code>themes/next/layout/_macro/post.swig</code> 文件 ，将上面简单实现的代码替换成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">&lt;!--文章结束标语--&gt;</span><br><span class="line">&#123;%4if theme.post_end_text &amp;&amp; not is_index%&#125;</span><br><span class="line">&#123;% include &#x27;post-end-text.swig&#x27; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在主题配置文件末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文章结束提示语</span><br><span class="line">post_end_text: true</span><br></pre></td></tr></table></figure>

<p>我们就可以在这里将其设为<code> true</code> 或 <code>false</code> 来控制其显示。</p>
</li>
</ul>
<h4 id="6-6-添加博客字数和阅读时间统计功能"><a href="#6-6-添加博客字数和阅读时间统计功能" class="headerlink" title="6.6 添加博客字数和阅读时间统计功能"></a>6.6 添加博客字数和阅读时间统计功能</h4><p>首先在站点根目录下配置依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>然后再站点配置文件中加入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true #是否统计字数</span><br><span class="line">  time: true #是否统计阅读时长</span><br><span class="line">  total_symbols: true #是否统计总字数</span><br><span class="line">  total_time: true #是否统计总阅读时长</span><br></pre></td></tr></table></figure>

<p>最后在主题配置文件中修改为以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#字数及访问时间统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true  #分隔线</span><br><span class="line">  item_text_post: true  #文章中的显示是否显示文本</span><br><span class="line">  item_text_total: true       #网页底部的显示是否显示文本</span><br><span class="line">  awl: 2 #平均每个字符的长度</span><br><span class="line">  wpm: 275 # 设定每分钟可阅读的字符数</span><br></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120157.png"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120201.png"></p>
<h4 id="6-7-修改-tag-图标"><a href="#6-7-修改-tag-图标" class="headerlink" title="6.7 修改 tag 图标"></a>6.7 修改 tag 图标</h4><p>默认的 <code>tag</code> 样式为 <code>#</code> 不带图标：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120205.png"></p>
<p>我们可以改成使用图标：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312120209.png"></p>
<p>新版Next 已经帮我们集成了这个功能，我们只要在主题配置文件中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">#使用标签图标</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pZ2h0bWFyZV9kaW1wbGUvYXJ0aWNsZS9kZXRhaWxzLzg2NjYxNTAy">https://blog.csdn.net/nightmare_dimple/article/details/86661502<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo 美化</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hexo的一些基础知识和常见问题</title>
    <url>/2019/07/c35aa1ae3838.html</url>
    <content><![CDATA[<p>Hexo 是一个方便快速的博客系统，但事无巨细，对于像我这样的小白来说，使用时还是会遇到许多小问题，这篇文章主要是记录Hexo的一些基础知识，以及一些小问题解决方案。</p>
<span id="more"></span>

<h2 id="1-如何新建文章（博客）？"><a href="#1-如何新建文章（博客）？" class="headerlink" title="1. 如何新建文章（博客）？"></a>1. 如何新建文章（博客）？</h2><p>假设我要新建标题为 <strong>小白的逆袭之路</strong> 文章，我们进入Hexo博客主目录，在命令行操作下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;小白的逆袭之路&quot;</span></span><br></pre></td></tr></table></figure>

<p>文章即会被创建在<code>博客主目录/source/_posts</code> 目录中</p>
<h2 id="2-如何删除博客"><a href="#2-如何删除博客" class="headerlink" title="2. 如何删除博客"></a>2. 如何删除博客</h2><p>进入<code>博客主目录/source/_posts</code>目录，找到你想删除的文章，鼠标右键删除即可。</p>
<h2 id="3-如何编辑博客"><a href="#3-如何编辑博客" class="headerlink" title="3. 如何编辑博客"></a>3. 如何编辑博客</h2><blockquote>
<p>Hexo 渲染文章使用 Github 的 <span class="exturl" data-url="aHR0cHM6Ly9nZm0uZG9jc2NoaW5hLm9yZy96aC1oYW5zLw==">GFM语法<i class="fa fa-external-link-alt"></i></span> 的 Markdown 格式，在编辑文章之前，我强烈建议大家先去了解 Hexo 下 <span class="exturl" data-url="aHR0cHM6Ly9nZm0uZG9jc2NoaW5hLm9yZy96aC1oYW5zLw==">Markdown 的基本语法<i class="fa fa-external-link-alt"></i></span>，上手非常简单。</p>
</blockquote>
<ol>
<li><p>使用专门的 Markdown 编辑器</p>
<p>目前市面上有许多 Markdown 编辑器，这里我墙裂推荐大家使用 <code>Typora</code> 使用方式以及介绍可以参考 <span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC81NDkxMg==">少数派：Typora 完全使用详解<i class="fa fa-external-link-alt"></i></span></p>
<p>配置好 <code>Typora</code>后我们编辑文章时只要点击我们要编辑的以<code>md</code>结尾的博客文件，鼠标右键 &gt; 打开方式 &gt; 用<code>Typora</code>打开</p>
<p>即可用<code>Typora</code>编辑器进行编辑。</p>
<p>在足够熟悉 Markdown 语法后，可以使用任意一种文本编辑器编写 Markdown 文件。</p>
</li>
<li><p>使用 Git Bash 的<code>vim</code> 编辑器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim 小白的逆袭之路.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他的一些文本编辑器类。</p>
<ul>
<li>VSCode</li>
<li>Sublime</li>
<li>……</li>
</ul>
</li>
</ol>
<h2 id="4-如何为文章添加标签（tags）以及分类（categories）"><a href="#4-如何为文章添加标签（tags）以及分类（categories）" class="headerlink" title="4. 如何为文章添加标签（tags）以及分类（categories）"></a>4. 如何为文章添加标签（tags）以及分类（categories）</h2><p>在我们编辑文章时，文章头部都会有这样的格式：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171602069.png"></p>
<p>Hexo 称其为 Front-matter 用于指定个别文件的变量，Hexo 设定了多种参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>excerpt</code></td>
<td align="left">Page excerpt in plain text. Use <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdGFnLXBsdWdpbnMjUG9zdC1FeGNlcnB0">this plugin<i class="fa fa-external-link-alt"></i></span> to format the text</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>disableNunjucks</code></td>
<td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdGFnLXBsdWdpbnM=">tag plugins<i class="fa fa-external-link-alt"></i></span> when enabled</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>lang</code></td>
<td align="left">Set the language to override <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvaW50ZXJuYXRpb25hbGl6YXRpb24jUGF0aA==">auto-detection<i class="fa fa-external-link-alt"></i></span></td>
<td align="left">Inherited from <code>_config.yml</code></td>
</tr>
</tbody></table>
<p>tag 对应你想对该文章设置的标签 ，书写格式为：- 标签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 小白的逆袭之路</span><br><span class="line">tags:</span><br><span class="line">4- 小白    <span class="comment">#标签1</span></span><br><span class="line">4- 励志    <span class="comment">#标签2</span></span><br></pre></td></tr></table></figure>

<p>categories 指定分类，书写格式为：- 分类名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 小白的逆袭之路</span><br><span class="line">tags:</span><br><span class="line">4- 小白    <span class="comment">#标签1</span></span><br><span class="line">4- 励志    <span class="comment">#标签2</span></span><br><span class="line">categories:</span><br><span class="line">4- Dream <span class="comment">#父分类</span></span><br><span class="line">4- Light Dream <span class="comment">#子分类</span></span><br></pre></td></tr></table></figure>

<p>仔细观察的朋友估计已经看出来了，我在分类名后面分别注释了 <code>父分类</code>以及<code>子分类</code>，为什么是这样子呢，根据官方的说明：</p>
<blockquote>
<p>在Hexo 中，分类和标签有着明显的差别：分类具有顺序性和层次性，而标签没有顺序和层次行。</p>
<p>区别于WordPress ，WordPress支持对一篇文章设置多个分类，这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。例如上面的指定方法，会将分类<code>Light Dream</code> 变为 <code>Dream</code> 的子类，而不是并列分类。因此，在进行您的文章分类时，请尽可能准确的分类。</p>
</blockquote>
<h2 id="5-修改主题配置正确但刷新未显示修改的内容。"><a href="#5-修改主题配置正确但刷新未显示修改的内容。" class="headerlink" title="5. 修改主题配置正确但刷新未显示修改的内容。"></a>5. 修改主题配置正确但刷新未显示修改的内容。</h2><p>在每次我们进行主题或者是对站点配置修改后，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h2 id="6-TypeError-Cannot-read-property-‘length’-of-null"><a href="#6-TypeError-Cannot-read-property-‘length’-of-null" class="headerlink" title="6.  TypeError: Cannot read property ‘length’ of null"></a>6.  TypeError: Cannot read property ‘length’ of null</h2><p>开始遇到这个问题的时候一脸懵逼，再加上对 Javascript 不熟，所以困扰许久。</p>
<p>首先我们查看异常内容，里面有这一段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node_modules\highlight.js\lib\highlight.js:388:42</span><br></pre></td></tr></table></figure>

<p>然后我寻找源码看到这段注释：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">Syntax highlighting with language autodetection.</span><br><span class="line">https://highlightjs.org/</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>语法高亮自动侦测语言？然后我想起来配置文件好像有个侦测语言的，查看了一下站点配置文件找到highlight：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  line_number: <span class="literal">true</span></span><br><span class="line">  auto_detect: <span class="literal">true</span> <span class="comment">#自动判断代码语言</span></span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>

<p>看到了auto_detect ，自动判断代码语言，所以应该就是这里。</p>
<p>那么是哪里出了问题呢，我的文章中代码比较复杂但是都指定了语言，这里的自动侦测语言可能遇到比较复杂的代码会检测出问题。</p>
<p>于是我将 auto_detect 改为 false，重新运行 <code>hexo g</code>，成功。</p>
<p><strong>待续……</strong></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：为 Next 主题添加Valine评论系统</title>
    <url>/2019/07/ba575ca88d50.html</url>
    <content><![CDATA[<p>在前面的文章中，我们基本把Hexo博客的框架搭建好了和实现了主题的部分美化，接下来我开始慢慢介绍一些进阶设定。</p>
<p>这次是Hexo 在Next主题下配置Valine评论系统。</p>
<span id="more"></span>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><span style="color: red">注意</span></h3><p><span style="color: red">根据读者反馈，Valine 评论系统在 Next 主题高版本 (7.+) 以上没有内置，且 Valine 已经很久没有更新维护了。如果想要配置体验 Valine 的，建议使用 Next 主题低版本。<br>或者使用更加人性化且带后端的 <span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnLw==">Waline<i class="fa fa-external-link-alt"></i></span> </span></p>
<p>详细的部署方式可参考我的文章 <a href="https://qianfanguojin.top/2022/01/20/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0-Waline-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">Hexo博客进阶：为-Next-主题添加-Waline-评论系统</a></p>
<h2 id="1-为什么选择Valine"><a href="#1-为什么选择Valine" class="headerlink" title="1.为什么选择Valine"></a>1.为什么选择Valine</h2><p>在笔者进行评论系统选择时，我觉得我的需求就是方便，简洁，最重要一点是要支持<code>Markdown</code> ，对比之下，最终选定了这款Valine，当然，如果你不喜欢这样简洁的，可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2NzU5ODUxOA==">Hexo（NexT 主题）评论系统哪个好？<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2-第一步，注册LeanClound-获取APP-ID-和-APP-Key"><a href="#2-第一步，注册LeanClound-获取APP-ID-和-APP-Key" class="headerlink" title="2. 第一步，注册LeanClound,获取APP ID 和 APP Key"></a>2. 第一步，注册LeanClound,获取APP ID 和 APP Key</h2><p>Valine 是基于 <span class="exturl" data-url="aHR0cHM6Ly9sZWFuY2xvdWQuYXBwLw==">LeanCloud<i class="fa fa-external-link-alt"></i></span> 作为数据存储的，所以需要注册一个账号，注册完成后，我们找到<code>创建应用</code><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210815161252.png"></p>
<p>在这里填写你的应用名称,名称可以自己定义，然后下面选择<code>开发版</code> 点击<code>创建</code>。</p>
<p>然后点击应用进入设置。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614201.png"></p>
<p>在设置页，我们首先点击存储，查看是否有<code>Comment </code>和 <code>Counter</code>，没有则创建，权限设为无限制。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614125.png"></p>
<p>然后点击设置 &gt; 安全中心 ,将除了数据存储的服务全部关闭。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614044.png"></p>
<p> 最后点击应用 Key 取得我们 <code>AppKey</code> 和 <code>App id</code></p>
<h2 id="3-在Hexo-Next主题中配置"><a href="#3-在Hexo-Next主题中配置" class="headerlink" title="3. 在Hexo Next主题中配置"></a>3. 在Hexo Next主题中配置</h2><p>首先打开 <span class="exturl" data-url="aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tL3BhY2thZ2UvbnBtL3ZhbGluZQ==">https://www.jsdelivr.com/package/npm/valine<i class="fa fa-external-link-alt"></i></span> 获取最新的  valine.min.js 的cdn地址：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614876.png"></p>
<p>然后我们修改主题配置文件，配置CDN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># valine</span><br><span class="line"># See: https://github.com/xCss/Valine</span><br><span class="line"># Example:</span><br><span class="line"># valine: //fastly.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span><br><span class="line"># valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js</span><br><span class="line">valine: https://fastly.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js</span><br></pre></td></tr></table></figure>

<p>再打开配置Valine功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line"> # 功能开关</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version</span><br><span class="line">  appid:  # Your leancloud application appid #LeanClound获得的appid</span><br><span class="line">  appkey:  # Your leancloud application appkey #LeanClound获得的appkey</span><br><span class="line">  notify: false # Mail notifier. See: https://github.com/xCss/Valine/wiki # 邮件提醒</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎畅所欲言 # Comment box placeholder</span><br><span class="line">  avatar: mm # Gravatar style #默认头像设置</span><br><span class="line">  guest_info: nick,mail,link # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn # 语言，设为zh-cn</span><br><span class="line">  # 是否开启当前文章阅读量统计</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-其他设置"><a href="#4-其他设置" class="headerlink" title="4. 其他设置"></a>4. 其他设置</h2><h3 id="4-1-指定文章（页面）评论功能是否开启"><a href="#4-1-指定文章（页面）评论功能是否开启" class="headerlink" title="4.1 指定文章（页面）评论功能是否开启"></a>4.1 指定文章（页面）评论功能是否开启</h3><p>在 Hexo 博客中，评论的功能是在所有页面都默认开启的，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面我们并不需要评论功能。</p>
<p>我们可以在 Front-matter 中通过<code>comments</code>属性设置true或false控制该页面或者是文章的评论功能是否打开，如我设置标签页面的评论功能关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>



<h3 id="4-2-自定义头像"><a href="#4-2-自定义头像" class="headerlink" title="4.2 自定义头像"></a>4.2 自定义头像</h3><p>参考：<span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnL2F2YXRhci5odG1s">https://valine.js.org/avatar.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：将 Hexo 部署到云服务器（CentOS）</title>
    <url>/2020/03/6fc91bb380cf.html</url>
    <content><![CDATA[<p><code>Hexo + GitPage</code> 的组合让我们每个人都很容易地拥有自己的博客站点，但由于 <code>Github</code> 在国内经常抽风，给人的体验不是很好。</p>
<p>刚好自己前段时间白嫖了一个云服务器，于是查了查资料，成功将其部署到云服务器。</p>
<p>接下来我就介绍我自己部署的一些过程，希望能给看到的人一些帮助。</p>
<span id="more"></span>

<h2 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h2><ul>
<li>一个已经开放 80 端口的公网云服务器</li>
<li>CentOS 系统</li>
</ul>
<h2 id="2-连接到云服务器-Xshell"><a href="#2-连接到云服务器-Xshell" class="headerlink" title="2. 连接到云服务器( Xshell )"></a>2. 连接到云服务器( Xshell )</h2><p>这一步就不多说了，如果不会请自行百度。</p>
<h2 id="3-Git-仓库的安装配置"><a href="#3-Git-仓库的安装配置" class="headerlink" title="3. Git 仓库的安装配置"></a>3. Git 仓库的安装配置</h2><ol>
<li><p>安装 Git</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version // 如无，则安装</span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户并配置仓库</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git // 设置密码</span><br><span class="line">su git // 这步很重要，避免文件权限的各种问题</span><br><span class="line"><span class="built_in">cd</span> /home/git/</span><br><span class="line"><span class="built_in">mkdir</span> -p project/hexo-blog // 项目存在的真实目录,存放hexo静态文件</span><br><span class="line"><span class="built_in">mkdir</span> repos &amp;&amp; <span class="built_in">cd</span> repos // 放置git仓库的文件夹</span><br><span class="line">git init --bare hexo-blog-repo.git// 创建一个裸露的仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建钩子函数<br> 新建文件，编写内容如下：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-blog-repo.git/hooks //进入hooks文件夹</span><br><span class="line">vim post-receive //创建hook钩子函数文件(git提交时自动部署)，输入以下内容：</span><br></pre></td></tr></table></figure>

 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/home/git/projects/hexo-blog --git-dir=/home/git/repos/hexo-blog-repo checkout -f</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改权限</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x post-receive</span><br><span class="line"><span class="built_in">exit</span> // 退出到 root 登录</span><br><span class="line"><span class="built_in">chown</span> -R git:git /home/git/repos/hexo-blog-repo.git // 添加权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试能否拉取</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@server_ip:/home/git/repos/hexo-blog-repo.git</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-建立客户端与服务器的-SSH-免密连接"><a href="#4-建立客户端与服务器的-SSH-免密连接" class="headerlink" title="4. 建立客户端与服务器的 SSH 免密连接"></a>4. 建立客户端与服务器的 SSH 免密连接</h2><ol>
<li><p>创建 authorized_keys 以及配置权限</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/git/.ssh</span><br><span class="line"><span class="built_in">touch</span> authorized_keys  //存放客户端的ssh公钥(id_rsa.pub)</span><br><span class="line"><span class="built_in">chmod</span> 600 authorized_keys   //配置权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成密钥对（已有的请忽略）</p>
<p>进入你本机的(windows) c:&#x2F;Users&#x2F;youname&#x2F;.ssh 文件夹下，查看是否有名为 <code>id_rsa.pub</code> 和 <code>id_rsa</code> 的文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20200302234435.png"></p>
<p>如果有，请跳过下面 <strong>生成密钥</strong> 这一步：</p>
<blockquote>
<p>生成密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>中途不管你提示啥，一直Enter就是了，生成成功的话会在控制台打印出一个图案</p>
</blockquote>
</li>
<li><p>建立 SSH 信任关系（免密登录）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip</span><br><span class="line">ssh git@server_ip // 测试能否登录</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>此时 SSH 登录 Git 用户不需要输入密码，如果需要，请仔细对照步骤1-2。</p>
<p>当然，也有极个别特殊情况，大多数问题可以在这里找到答案：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JfeF9wL2FydGljbGUvZGV0YWlscy83ODUzNDQyMw==">SSH无密钥登陆 与 配置公钥后仍需要输入密码的解决方案<i class="fa fa-external-link-alt"></i></span></p>
<p>还有就是注意本地 ssh-keygen 生成密钥对时最好不要对密钥对进行重命名 <strong>(大坑)</strong></p>
</blockquote>
<h2 id="5-限制-git-用户的权限"><a href="#5-限制-git-用户的权限" class="headerlink" title="5. 限制 git 用户的权限"></a>5. 限制 git 用户的权限</h2><p>为了安全起见，最好是将 git 用户的权限设置为只能执行 <code>git clone</code> , <code>git push</code> 命令等等：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells // 查看 git-shell 是否在登录方式里面</span><br><span class="line"><span class="built_in">which</span> git-shell // 查看是否安装</span><br><span class="line">vim /etc/shells</span><br><span class="line">添加第2步显示出来的路径，通常为 /usr/bin/git-shell</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200304142805.png" alt="image-20200303141203059"></p>
<p>同时修改 &#x2F;etc&#x2F;passwd 文件内容，更改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">将原来的:</span><br><span class="line">git:x:1001:1001::/home/git:/bin/bash //原来的</span><br><span class="line">修改为:</span><br><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell //修改之后</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-安装配置-Nginx"><a href="#6-安装配置-Nginx" class="headerlink" title="6. 安装配置 Nginx"></a>6. 安装配置 Nginx</h2><h3 id="6-1-下载安装-Nginx"><a href="#6-1-下载安装-Nginx" class="headerlink" title="6.1 下载安装 Nginx"></a>6.1 下载安装 Nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget &quot;http://nginx.org/download/nginx-1.17.8.tar.gz&quot; //下载安装文件</span><br><span class="line">tar -xvzf nginx-1.17.8.tar.gz -C ../</span><br><span class="line">cd ../nginx-1.17.8</span><br><span class="line">./configure --prefix=/usr/local/nginx-webServer --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</span><br><span class="line">make &amp;&amp; make install // 编译安装</span><br><span class="line">alias nginx=&#x27;/usr/local/nginx-webServer/sbin/nginx&#x27; //取别名为nginx，方便调用</span><br></pre></td></tr></table></figure>

<h3 id="6-2-配置-Nginx"><a href="#6-2-配置-Nginx" class="headerlink" title="6.2 配置 Nginx"></a>6.2 配置 Nginx</h3><p>根据上面的步骤，安装完成，在控制台输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<p>可看到版本信息，代表安装成功<img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200303161109.png"></p>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<p>在浏览器输入你购买的服务器的 IP ，可看到：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200314162743.png"></p>
<p>表示 Nginx 配置成功。</p>
<blockquote>
<p>如果上图的页面没有显示，则有可能是你购买的服务器安全组没有授权 80 端口开放，可以查询相关帮助开放 80 端口。</p>
</blockquote>
<p>接下来是 Nginx 的详细配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop //先停止nginx</span><br><span class="line"><span class="built_in">cd</span> /usr/local/nginx-webServer/conf</span><br><span class="line">vim nginx.conf //打开配置文件</span><br><span class="line">将 user 修改为 root //避免权限不足无法访问博客目录</span><br><span class="line">将 root 解析路径修改为博客目录 /home/git/project/hexo-blog</span><br><span class="line">nginx -s reload //重启nginx</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200304142817.png" alt="image-20200303162637211"></p>
<h2 id="7-配置-Hexo"><a href="#7-配置-Hexo" class="headerlink" title="7. 配置 Hexo"></a>7. 配置 Hexo</h2><p>配置站点配置文件<code>_config.yml</code> 的 <code>deploy</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">git@server_ip:/home/git/repos/hexo-blog-repo.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>server_ip : 即你购买的服务器的 IP 地址</p>
</blockquote>
<p>部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>当然，为了每次部署时更简单，我推荐创建 npm 脚本。</p>
<p>在 hexo 的根目录下的 <code>package.json</code> 文件中加入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;hexo clean &amp;&amp; hexo g -d&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以在目录下直接运行<code>npm</code>脚本部署啦：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4Mjk5MzExL2FydGljbGUvZGV0YWlscy84ODg0NDQ0Mg==">hexo+git+nginx在云服务器搭建hexo博客教程<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTYxODU3L2FydGljbGUvZGV0YWlscy84MTU5MDk1Mw==">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JfeF9wL2FydGljbGUvZGV0YWlscy83ODUzNDQyMw==">SSH无密钥登陆 与 配置公钥后仍需要输入密码的解决方案<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：为 Next 主题的 Hexo 博客内容添加文章过期/时效提示</title>
    <url>/2022/09/69288abaaf16.html</url>
    <content><![CDATA[<p>随着时间的推移，许多博客的内容都往往会遇到过时的情况，一些程序，操作教程在新的版本可能已经不适用。</p>
<p>为了方便读者们查阅，我们应该根据文章发布时间提供一个提示信息，提醒读者该文章的时效，节省读者的时间。</p>
<p>下面笔者就介绍在 Next 主题下面，Hexo 如何显示优雅的时效性提示信息。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先上最终效果图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202209072214826.png"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202209072221668.png"></p>
<p>有过网页基础的可能都很快能想到解决方案，只需要在文章显示之前执行一段 <code>Javascript</code> 脚本来显示这段文字即可。</p>
<p>但是，Hexo 以及 Next 主题默认是不提供这个功能的，并且在笔者编写这篇文章的时候，也没有找到 Hexo 有对应的插件来解决这个问题。</p>
<p>难道我们必须要改源码或者说专门制作一个插件？开始我也是这么认为的，但是我在插件的介绍页 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvcGx1Z2lucy5odG1s">插件 | Hexo <i class="fa fa-external-link-alt"></i></span>找到了这个：</p>
<blockquote>
<p>如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 <code>scripts</code> 文件夹，在启动时就会自动载入。</p>
</blockquote>
<p>Ok，自动执行一个脚本的功能找到了，那么如何确保只在指定的位置显示这段文字？</p>
<p>事实上，Hexo提供了  <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9pbmplY3Rvcg==">注入器（Injector） | Hexo<i class="fa fa-external-link-alt"></i></span>，可以<strong>将指定的静态代码片段注入到生成的静态页面中。</strong></p>
<p>那么接下来的步骤就很简单了，我们只需要在 <code>scripts</code> 文件夹下新建一个脚本，这个脚本运行 Hexo 的注入器函数，注入器函数再将对应的静态代码注入到文章指定位置即可。</p>
<p>下面就来操作吧。</p>
<h2 id="1-添加注入器"><a href="#1-添加注入器" class="headerlink" title="1. 添加注入器"></a>1. 添加注入器</h2><p>Hexo 的注入器函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">injector</span>.<span class="title function_">register</span>(entry, value, to)</span><br><span class="line"><span class="comment">//entry: 注入到页面的位置</span></span><br><span class="line"><span class="comment">//value：注入到页面的静态代码片段</span></span><br><span class="line"><span class="comment">//to: 注入到哪个页面</span></span><br></pre></td></tr></table></figure>

<p>在 Hexo 的 <code>scripts</code> 目录（没有则新建一个）下新建一个名为 <code>injector.js</code> 的文件，将下面的代码复制到其中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入文章过期提示</span></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">injector</span>.<span class="title function_">register</span>(<span class="string">&#x27;body_end&#x27;</span>, <span class="string">`&lt;script src=&quot;/js/outdate.js&quot;&gt;&lt;/script&gt;`</span>,<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>body_end</code> 代表注入到文章开头。</li>
<li>由于注入的代码有点长，我们就用一个 <code>Javascript</code> 文件单独处理，作为注入的代码片段引入</li>
<li><code>post</code> 代表只注入到文章详情页面中。</li>
</ul>
<p>更多细节可以查看<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9pbmplY3Rvcg==">官网文档<i class="fa fa-external-link-alt"></i></span>，对注入器函数有详细的介绍。</p>
<h2 id="2-添加静态代码片段"><a href="#2-添加静态代码片段" class="headerlink" title="2.  添加静态代码片段"></a>2.  添加静态代码片段</h2><p>在 Hexo 的 <code>source</code> 目录下新建 <code>js</code> 文件夹，新建一个名为 <code>outdate.js</code> 的文件，添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//不同的日期显示不同的样式，200 天为黄色提示，400天为红色提示，可以自己定义。</span></span><br><span class="line">  <span class="keyword">let</span> warningDay = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">let</span> errorDay = <span class="number">400</span>;</span><br><span class="line">  <span class="comment">// 确保能够获取到文章时间以及在文章详情页</span></span><br><span class="line">  <span class="keyword">let</span> times = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (times.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">let</span> posts = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;post-body&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (posts.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取系统当前的时间</span></span><br><span class="line">  <span class="keyword">let</span> pubTime = <span class="keyword">new</span> <span class="title class_">Date</span>(times[<span class="number">0</span>].<span class="property">dateTime</span>);  <span class="comment">/* 文章发布时间戳 */</span></span><br><span class="line">  <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()  <span class="comment">/* 当前时间戳 */</span></span><br><span class="line">  <span class="keyword">let</span> interval = <span class="built_in">parseInt</span>(now - pubTime)</span><br><span class="line">  <span class="keyword">let</span> days = <span class="built_in">parseInt</span>(interval / <span class="number">86400000</span>)</span><br><span class="line">  <span class="comment">/* 发布时间超过指定时间（毫秒） */</span></span><br><span class="line">  <span class="comment">//note warning 以及 note danger 是 Next 主题的自定义模板语法，如果使用其他主题，请自行更改样式以达到最佳显示效果</span></span><br><span class="line">  <span class="keyword">if</span> (interval &gt; warningDay*<span class="number">3600</span>*<span class="number">24</span>*<span class="number">1000</span> &amp;&amp; interval &lt; errorDay*<span class="number">3600</span>*<span class="number">24</span>*<span class="number">1000</span>)&#123;</span><br><span class="line">    posts[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;div class=&quot;note warning&quot;&gt;&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&lt;h5&gt;文章时效性提示&lt;/h5&gt;&lt;p&gt;这是一篇发布于 &#x27;</span> + days + <span class="string">&#x27; 天前的文章，部分信息可能已发生改变，请注意甄别。&lt;/p&gt;&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&lt;/div&gt;&#x27;</span> + posts[<span class="number">0</span>].<span class="property">innerHTML</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(interval &gt;= errorDay*<span class="number">3600</span>*<span class="number">24</span>*<span class="number">1000</span>)&#123;</span><br><span class="line">      posts[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;div class=&quot;note danger&quot;&gt;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&lt;h5&gt;文章时效性提示&lt;/h5&gt;&lt;p&gt;这是一篇发布于 &#x27;</span> + days + <span class="string">&#x27; 天前的文章，部分信息可能已发生改变，请注意甄别。&lt;/p&gt;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&lt;/div&gt;&#x27;</span> + posts[<span class="number">0</span>].<span class="property">innerHTML</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-查看结果"><a href="#3-查看结果" class="headerlink" title="3. 查看结果"></a>3. 查看结果</h2><p>在 Hexo 根目录，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器，查看一篇旧文章，检查结果即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2FwaS9pbmplY3Rvcg==">注入器（Injector） | Hexo<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvcGx1Z2lucw==">插件 | Hexo<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 的 HTTPS 和 SSH 方式的区别和使用</title>
    <url>/2019/07/f21c90391e87.html</url>
    <content><![CDATA[<p>Git 有两种远程仓库与本地仓库之间 push&#x2F;clone&#x2F;pull 等操作的验证模式。一种是 HTTPS 模式，另一种是 SSH 模式。</p>
<p>本文主要讲述这两种模式的区别以及使用方式。</p>
<span id="more"></span>

<hr>
<h2 id="HTTPS协议模式"><a href="#HTTPS协议模式" class="headerlink" title="HTTPS协议模式"></a>HTTPS协议模式</h2><p>相对于 <code>SSH</code> 模式，HTTPS 对于新手来说更友好，假设我要 clone 一个项目，直接在<code>clone</code> 后跟上链接即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/qianfanguojin/compare.git</span><br></pre></td></tr></table></figure>

<p>但是，方便的同时也会产生一些麻烦，当我们在进行<code>push/pul</code>l操作时，每次都要输入账号密码。</p>
<p>当然，很多时候我们好像就是只输入了一次，后面也不需要输入了，但其实只是 Windows 操作系统帮我们记录在了 Windows凭据 中，每次我们执行操作的时候，Windows 都自动帮你填写好账号密码：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171537027.png"></p>
<p>此时我们执行 <code>push</code> 操作，可以看到：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171538173.png"></p>
<p>没有提示输入账号密码，直接推送成功。</p>
<p>但当我删除Windows凭据中的内容：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171539489.png"></p>
<p>我再次执行推送，发现弹出输入账号密码的输入窗口：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171539973.png"></p>
<p>想要了解更多关于 Git 凭据的信息，可以参考官方文档 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU1JTg3JUFEJUU4JUFGJTgxJUU1JUFEJTk4JUU1JTgyJUE4">Git 工具 - 凭证存储<i class="fa fa-external-link-alt"></i></span></p>
<p>综上，我们可知，HTTPS 方式在 Git 执行操作时每次都要账号密码验证，但是得益于凭据管理模式，使用起来也方便许多，但当我们在多台电脑上运行操作我们的项目时，每次都要输入账号密码，就会非常的麻烦。</p>
<hr>
<h2 id="SSH-协议模式"><a href="#SSH-协议模式" class="headerlink" title="SSH 协议模式"></a>SSH 协议模式</h2><p>根据 Git 的官方文档 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCU4QSVFNyU5QSU4NC1HaXQtJUU1JThEJThGJUU4JUFFJUFF">服务器上的 Git - 协议<i class="fa fa-external-link-alt"></i></span> ，SSH 在 Git 中的使用具有架设简单、高效、方便管理优点，但 SSH 的缺点在于你不能通过它进行匿名访问，即便是只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。</p>
<p>这里我教大家如何使用<code>SSH</code>来操作。</p>
<h4 id="1-确认自己电脑是否拥有SSH密钥："><a href="#1-确认自己电脑是否拥有SSH密钥：" class="headerlink" title="1.确认自己电脑是否拥有SSH密钥："></a>1.确认自己电脑是否拥有SSH密钥：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，用户的SSH密钥都存储在<code>~/.ssh</code>目录下，也就是用户根目录下的<code>.ssh</code>文件夹中，我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。</p>
<p><code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录）<code>No such file or directory</code> 表示文件夹不存在，则表示没有密钥，我们需要自己创建。</p>
<h4 id="2-生成-SSH-密钥"><a href="#2-生成-SSH-密钥" class="headerlink" title="2.生成 SSH 密钥"></a>2.生成 SSH 密钥</h4><p>在命令行下（cmd 或是 Git bash）我们可以通过 <code>ssh-keygen</code>命令创建:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171540054.png"></p>
<p>当然，为了使生成的SSH密钥更清楚明了，还可以添加一些附加控制命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的email地址&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中：<br>-t  指明密钥类型，默认为 rsa，可省略。<br>-c 指明注释文字，如邮箱，会显示在你生成的 <code>id_rsa</code> 文件内容最下方。<br>-f  指定密钥文件存储的文件名字</p>
<p>可以看到，我们使用不带任何参数方法创建时，首先 <code>ssh-keygen</code> 会确认密钥的存储位置，如你没有指定，则它使用默认的目录（默认是 <code>.ssh/id_rsa</code>）。</p>
<p>然后会要求你输入两次密钥口令，口令的作用即是一个密码，即当你使用密钥时需要输入该口令，如果你不想在使用密钥时输入口令，将其留空即可。</p>
<h4 id="3-将SSH密钥添加到服务器"><a href="#3-将SSH密钥添加到服务器" class="headerlink" title="3.将SSH密钥添加到服务器"></a>3.将SSH密钥添加到服务器</h4><p>不同的 Git 服务器添加操作区域不一样，这里我以 Github 为例。</p>
<p>点击右上角个人头像，从下拉框中进入Setting：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171540379.png"></p>
<p>然后进入SSH and GPG Keys设置：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171540572.png"></p>
<p>然后按照下图操作：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171540750.png"></p>
<h4 id="4-利用SSH密钥推送"><a href="#4-利用SSH密钥推送" class="headerlink" title="4.利用SSH密钥推送"></a>4.利用SSH密钥推送</h4><p>由于我们先前使用的远程关联方式是 HTTPS 链接，所以我们先将远程关联信息删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>然后添加 SSH 链接的远程关联信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin <span class="string">&quot;你的远程仓库SSH链接&quot;</span></span><br></pre></td></tr></table></figure>

<p>将 master 本地分支推送到远程默认分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1emlsb25nbG92ZS9hcnRpY2xlL2RldGFpbHMvNzk0MTU2Mjg=">https://blog.csdn.net/duzilonglove/article/details/79415628<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdW5pYW5fMjc2MS9hcnRpY2xlL2RldGFpbHMvMTIyOTA3NzY2">保姆级教程，教你使用Git推送你的项目到Github_千帆过烬的博客小站-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git 协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：为 Next 主题添加 Waline 评论系统</title>
    <url>/2022/01/eb4966ce759b.html</url>
    <content><![CDATA[<p>文章发出之后，往往我们想要得到读者更多地反馈，那么拥有一个评论系统是至关重要的。</p>
<p>本篇带大家通过一些简单的配置，在 Hexo Next 主题下添加 Waline 评论系统。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的 <a href="https://qianfanguojin.top/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/?highlight=valine">Hexo博客进阶：为Next主题添加Valine评论系统 | 谢同学的博客 (qianfanguojin.top)</a> 文章中，我叙述了如何 在 Next主题下配置 Valine 评论系统。</p>
<p>但是，根据读者反馈，Valine 评论系统在 Next 主题高版本 (7.+) 以上已没有支持，且 Valine 已经很久没有更新维护了。不过，有大佬在 Valine 的基础之上开发了  <span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnLw==">Waline<i class="fa fa-external-link-alt"></i></span> 。<br>这次，我们就来描述如何快速上手安装配置更加人性化且带后端的 <span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnLw==">Waline<i class="fa fa-external-link-alt"></i></span> 评论系统。</p>
<h2 id="1-第一步，配置评论数据库"><a href="#1-第一步，配置评论数据库" class="headerlink" title="1. 第一步，配置评论数据库"></a>1. 第一步，配置评论数据库</h2><p><code>Waline</code> 和 Valine 一样，也是支持基于 <span class="exturl" data-url="aHR0cHM6Ly9sZWFuY2xvdWQuYXBwLw==">LeanCloud<i class="fa fa-external-link-alt"></i></span> 作为数据存储的，但是 <code>Waline</code> 支持的部署方式更多：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Waline</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Client</strong></td>
<td align="center"><strong>Server</strong></td>
<td align="center"><strong>Storage</strong></td>
</tr>
<tr>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnLw==">@waline&#x2F;client<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tLw==">Vercel<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9sZWFuY2xvdWQuYXBwLw==">LeanCloud<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9taW5pdmFsaW5lLmpzLm9yZy8=">MiniValine<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9kZXRhLnNoLw==">Deta<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9jbG9kYmFzZS5uZXQv">CloudBase<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FzZm9yZXN0L0FwcmlsQ29tbWVudA==">AprilComment<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZGJhc2UubmV0Lw==">CloudBase<i class="fa fa-external-link-alt"></i></span></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9tb25nb2RiLmNvbS8=">MongoDB<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9pbnNwaXJlY2xvdWQuY29tLw==">InspireCloud<i class="fa fa-external-link-alt"></i></span></td>
<td align="center">MySQL</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9yYWlsd2F5LmFwcC8=">Railway<i class="fa fa-external-link-alt"></i></span></td>
<td align="center">SQLite</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9yZW5kZXIuY29tLw==">Render<i class="fa fa-external-link-alt"></i></span></td>
<td align="center">PostgreSQL</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Docker</td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Virtual Host</td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRldGEuc2gvZG9jcy9iYXNlL2Fib3V0">Deta Base<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9pbnNwaXJlY2xvdWQuY29tL2RvY3Mvbm9kZWpzL2RhdGFiYXNlL3F1aWNrc3RhcnQuaHRtbA==">InspireCloud<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>为了方便，这里我只讲述最简单，零成本的数据库建立方法。</p>
<p>我们需要注册一个 <span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmxlYW5jbG91ZC5hcHAvcmVnaXN0ZXI=">Leancloud 国际版 <i class="fa fa-external-link-alt"></i></span>的账号，注意，一定要是 <strong>国际版</strong>，国内版需要绑定备案的域名，比较麻烦。具体可以在注册时的左上角看到：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201202316763.png"></p>
<p>注册完成后，登录，然后我们找到<code>创建应用</code></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210815161252.png"></p>
<p>在这里填写你的应用名称,名称可以自己定义，然后，下面选择<code>开发版</code> 点击<code>创建</code>。</p>
<p>然后点击应用进入设置。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108151614201.png"></p>
<p> 点击应用凭证，取得我们 <code>AppKey</code> 、<code>App id</code> 、以及 <code>MasterKey</code> ：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211139993.png"></p>
<p>数据库配置完毕，接下来安装服务端。</p>
<h2 id="2-安装服务端"><a href="#2-安装服务端" class="headerlink" title="2. 安装服务端"></a>2. 安装服务端</h2><p>由上面的表格可以看到，<code>Waline</code> 支持多种服务端，为了最简便上手，我们使用第一种方式，即在 <code>Vercl</code> 上安装服务端。首先，点击下面的按钮，一键部署：</p>
<p>  <a href="https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example"><img data-src="https://vercel.com/button" alt="Vercel"></a></p>
<p>应该需要注册一个账号，支持使用 <code>Github</code> 账号直接登录：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211306146.png"></p>
<p>登录后重新点进来，点击 <code>Create</code>：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211309809.png"></p>
<p>然后等待下面 <code>Deploy</code> 构建完成，点击 <code>Go to Dashboard</code></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211313406.png"></p>
<p>找到 Settings &#x3D;&gt; Environment Variables，配置环境变量：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211314501.png"></p>
<p>我们需要配置三个环境变量，对应如下表：</p>
<table>
<thead>
<tr>
<th>Lean Cloud</th>
<th>Vercel Environment</th>
</tr>
</thead>
<tbody><tr>
<td>AppID</td>
<td>LEAN_ID</td>
</tr>
<tr>
<td>AppKey</td>
<td>LEAN_KEY</td>
</tr>
<tr>
<td>MasterKey</td>
<td>LEAN_MASTER_KEY</td>
</tr>
</tbody></table>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211330222.png"></p>
<blockquote>
<p>提示</p>
<p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p>
</blockquote>
<p>为了使环境变量生效，我们需要重新构建一次。在上方找到 Deployments ，选择第一个右边的三个点，点击 Redeploy 。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211333672.png"></p>
<p>等待其构建结束，然后记住 <code>DOMAINS</code> 中的域名地址：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211413737.png"></p>
<p>好了，服务端部署到此结束，下面我们开始在 <code>Hexo Next</code> 主题中配置客户端。</p>
<h2 id="3-在Hexo-Next主题中配置"><a href="#3-在Hexo-Next主题中配置" class="headerlink" title="3. 在Hexo Next主题中配置"></a>3. 在Hexo Next主题中配置</h2><p>由于 Next 主题中并不自带 <code>Waline</code> 的评论配置，我们需要安装官方提供的插件。在 <code>Hexo</code> 根目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @waline/hexo-next</span><br></pre></td></tr></table></figure>

<p>找到 Next 的主题配置文件，在最后加上</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">waline-server-pearl.vercel.app</span> <span class="comment"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀</span> <span class="comment"># #评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新部署 <code>Hexo</code> ，就可以看到结果了。</p>
<blockquote>
<p>据反馈，Hexo 似乎在 8.x 的版本使用 waline 比较稳定，如果出现 <code>hexo g</code> 出错，可尝试升级 hexo 版本。</p>
</blockquote>
<h2 id="4-登录服务端"><a href="#4-登录服务端" class="headerlink" title="4. 登录服务端"></a>4. 登录服务端</h2><p>由于 <code>Waline</code> 有服务端，支持评论管理。我们需要注册一个账号作为管理员。</p>
<p>找到评论框，点击 <code>登录</code> 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201211432511.png"></p>
<p>注册好，登录之后即可进入评论管理的后台，可以对评论进行管理。</p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h3 id="5-1-自定义头像"><a href="#5-1-自定义头像" class="headerlink" title="5.1 自定义头像"></a>5.1 自定义头像</h3><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnL2d1aWRlL2NsaWVudC9hdmF0YXIuaHRtbA==">头像配置 | Waline<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="5-2-参考"><a href="#5-2-参考" class="headerlink" title="5.2 参考"></a>5.2 参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly93YWxpbmUuanMub3JnL2d1aWRlL2dldC1zdGFydGVkLmh0bWw=">https://waline.js.org/guide/get-started.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Waline</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git和码云来记录自己的学习</title>
    <url>/2019/08/5b3fcad9dcb0.html</url>
    <content><![CDATA[<p>在我们学习了 Git 之后，大多数时间我们都单纯用来管理我们的项目，这样并不能让 Git 工具得到高效的利用。</p>
<p>养成对学习内容的记录是一个优秀的好习惯，今天我们来使用 Git 和码云结合做一个记录学习内容的仓库。</p>
<span id="more"></span>

<h2 id="一-、新建码云仓库并编写README文件"><a href="#一-、新建码云仓库并编写README文件" class="headerlink" title="一 、新建码云仓库并编写README文件"></a>一 、新建码云仓库并编写README文件</h2><h3 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h3><p>首先打开<span class="exturl" data-url="aHR0cHM6Ly9pbWcvR2l0ZWUuY29tLw==">码云官网<i class="fa fa-external-link-alt"></i></span>，登录自己的账号， 点击右上角的新建仓库</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101623065.png"></p>
<p>仓库名称最好是与你当前学习内容相关的名字，比如在学 JAVA ，这里直接就写 JavaStudyRecord ，下图中红框内容一定要记得勾选：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101623580.png"></p>
<h3 id="2-初始化-README-文件"><a href="#2-初始化-README-文件" class="headerlink" title="2. 初始化 README 文件"></a>2. 初始化 README 文件</h3><p>建好仓库之后，我们要对我们的 README 文件进行一些修改。</p>
<p>README 文件是仓库中的一个特殊文件，当你点击进仓库时，仓库中的 README 文件中内容会自动显示在页面上，具体介绍看下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101624373.png"></p>
<p>很明显，我们可以利用这个文件来介绍我们的仓库。那么我们开始修改其中的内容。</p>
<p>首先点击图中的红框 中 <strong>README.md</strong>文件 ，进入下图界面：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101624676.png"></p>
<p>点击图中红框中的<strong>编辑</strong>按钮，此时页面会出现一个内容编辑框，我们将其中的内容除第一行外全部删除，并在其中添加文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA的初阶学习笔记的记录，从零开始学JAVA，持续督导中。</span><br></pre></td></tr></table></figure>

<p>呈现的效果如下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101624771.png"></p>
<p>编写完成后，点击图中最下方的<strong>提交到 master</strong>，此时会跳转到 README 文件内容页，效果如下图</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101633111.png"></p>
<p>此时可以看到 README 文件中的内容已经改成了我们编写的内容，如果觉得这段内容不好，同样可以参考上面的步骤修改成自己想写的内容即可。</p>
<p>码云上的操作基本上结束了，接下来我们在本地上操作。</p>
<h2 id="二、使用-Git-命令行对仓库进行操作"><a href="#二、使用-Git-命令行对仓库进行操作" class="headerlink" title="二、使用 Git 命令行对仓库进行操作"></a>二、使用 Git 命令行对仓库进行操作</h2><h3 id="1-克隆仓库到本地"><a href="#1-克隆仓库到本地" class="headerlink" title="1. 克隆仓库到本地"></a>1. 克隆仓库到本地</h3><p>首先我们复制仓库的链接：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101635324.png"></p>
<p>在电脑的桌面上点击鼠标右键，点击 <strong>Git Bash Here</strong> ，出现一个窗口如下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101635577.png"></p>
<p>这样我们就进入了 Git 命令行操作工具中。</p>
<p>因为我们要克隆仓库到本地，我们在该命令行中输入<code>git clone </code>命令执行克隆，后面加上你的仓库地址，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://img/Gitee.com/qianfanguojin/JavaStudyRecord.git</span><br></pre></td></tr></table></figure>

<p>如下图所示，执行成功后，桌面会创建一个与码云上仓库同名的文件夹：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101635578.png"></p>
<p>在桌面上点击进入该文件夹，可以看到码云仓库中的两个 README 文件已经被克隆下来了：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101635106.png"></p>
<h3 id="2-新建文件夹放置自己的学习内容并上传到码云"><a href="#2-新建文件夹放置自己的学习内容并上传到码云" class="headerlink" title="2. 新建文件夹放置自己的学习内容并上传到码云"></a>2. 新建文件夹放置自己的学习内容并上传到码云</h3><p>首先执行 cd 命令进入该文件夹<img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101636084.png"></p>
<blockquote>
<p>进入这个文件夹的目的是我们稍后执行的命令都是操作该目录下的文件，所以如果你执行下面的命令出错，请检查自己命令行的当前目录是否在你的本地仓库根目录。</p>
</blockquote>
<p>从桌面上点击进入 JavaStudyRecord 文件夹，在里面新建文件夹，每个文件夹名字最好能和学习的内容对应，并进行编号，可以参考下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101636644.png"></p>
<p>然后我们就可以在文件夹内放我们学习这个内容时的各种资料，例如照着敲的代码，写的笔记，或者说查的资料都可以放进去。比如今天我学习完了 Java 的方法，我新建了一个文件夹存放了我学习 Java 方法时记录的笔记还有代码：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101636006.png"></p>
<blockquote>
<p>注意 Git 是不能提交空文件夹的，所以要记得在文件夹里面添加文件。</p>
</blockquote>
<p>我们要把文件从本地推送到远程，一般需要三个步骤：</p>
<ol>
<li>先添加文件（add），此步骤对应 Git 命令中<code>git add</code></li>
<li>提交文件（commit），此步骤对应 Git 命令中<code>git commit</code></li>
<li>推送文件（push），此步骤对应 Git 命令中<code>git push</code></li>
</ol>
<p>接下来我们就做一个示例，在刚才的 Git 命令行执行命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>这个命令会将我们已修改的文件，也就是我们刚刚新建的<code>01-Java 方法</code>文件夹内容，都添加到暂存区，记得后面有个小数点。</p>
<p>再执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交的内容介绍&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个命令将文件提交到本地仓库。</p>
<p>最后我们将我们的内容推送到远程仓库</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>执行效果如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101636238.png"></p>
<p>此时我们查看码云的仓库，查看更新是否成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101636000.png"></p>
<p>可以看到我们刚才创建的文件夹成功推送到了码云仓库上。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>新建目录时名字一定要规范</p>
</li>
<li><p>空文件夹不会被 add 到暂存区，要记得在文件夹里面存放文件才会被提交。</p>
</li>
<li><p>在每次需要推送文件到远程时，注意要在命令行中进入你本地仓库的根目录，然后执行三件套：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;推送时的介绍&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>每次推送完记得检查远程仓库内容是否更新。</p>
</li>
<li><p>记得每次在本地仓库修改了文件内容都要推送一次，这样可以在主页看到你的贡献度，可以看出你自己对学习的态度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git的高效利用</tag>
      </tags>
  </entry>
  <entry>
    <title>Git clone 时遇到 fatal:&#92; protocol &#39;https&#39; is not supported问题解决方案</title>
    <url>/2019/08/ed46b563e31b.html</url>
    <content><![CDATA[<p>在 Git Bash 里执行 clone 命令时，有时候会莫名其妙报错<code>protocol &#39;&#39;https&#39;&#39; is not supported</code>，这是为什么呢？</p>
<p>本篇文章带你理解这个报错的由来，以及对应的解决方式。</p>
<span id="more"></span>

<h2 id="一、问题来因"><a href="#一、问题来因" class="headerlink" title="一、问题来因"></a>一、问题来因</h2><p>今天在整合项目时需要将码云上的仓库<code>clone</code>下来，在 Git Bash 里执行 clone命令报错<code>protocol &#39;&#39;https&#39;&#39; is not supported</code>，经过一番查找，找到了原因，分享给大家，其实也是我们常犯的一个错误。</p>
<h2 id="二、寻找解决方案"><a href="#二、寻找解决方案" class="headerlink" title="二、寻找解决方案"></a>二、寻找解决方案</h2><p>开始在CSDN上找各种解决办法，并没有任何成果，遇到的问题情况和我都不一样。</p>
<p>我一直秉承的思想是问题不能只有解决了才行，我们应该去找到问题产生的原因。</p>
<p>最后在<code>stackoverflow</code>上找到了解决方案和原因，其中是这么写到的：</p>
<blockquote>
<p>You tried to paste it using</p>
<ul>
<li>CTRL +V</li>
</ul>
<p>before and it didn’t work so you went ahead and pasted it with classic</p>
<ul>
<li>Right Click - Paste**.</li>
</ul>
<p>Sadly whenever you enter CTRL +V on <strong>terminal</strong> it adds</p>
<ul>
<li>a <strong>hidden</strong> <strong>^?</strong></li>
</ul>
<p>(at least on my machine it encoded like that).</p>
<p>the character that you only appears after you</p>
<ul>
<li>backspace</li>
</ul>
<p>(go ahead an try it on git bash).</p>
<p>So your link becomes <code>^?https://...</code></p>
<p><strong>which is invalid.</strong></p>
</blockquote>
<p>什么意思呢？就是说我们在粘贴地址时使用了 <code>CTRL +V</code>, 在Git Bash中没有效果，然后我们就会使用右键菜单中的粘贴，但是不幸的是，使用 <code>CTRL +V</code>会在Git Bash 中添加一个隐藏的符号 <code>^?</code>。</p>
<p>当你在粘贴仓库链接时使用了<code>CTRL +V</code>后</p>
<p>在GIt Bash 中你的克隆语句可能显示是这样正常的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//gitee.com/qianfanguojin/homework_1.git</span></span><br></pre></td></tr></table></figure>

<p>但真实语句其实是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone ^?https:<span class="comment">//gitee.com/qianfanguojin/homework_1.git</span></span><br></pre></td></tr></table></figure>

<p>链接前面多了符号，协议变成了<code>^https</code>，肯定不能克隆成功，提示协议不支持。</p>
<h2 id="三、问题解决办法"><a href="#三、问题解决办法" class="headerlink" title="三、问题解决办法"></a>三、问题解决办法</h2><p>解决问题的办法也很简单，将使用了<code>CTRL +V</code>的克隆语句删除重新编写，但是记得粘贴链接时不要使用<code>CTRL +V</code>即可。</p>
<p>这个问题也提醒我们不要在 命令行中乱用 <code>CTRL +V</code>或是<code>CTRL +C</code>这类快捷键，可能会出现莫名其妙的BUG。</p>
<h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTM5ODg2MzgvZ2l0LWZhdGFsLXByb3RvY29sLWh0dHBzLWlzLW5vdC1zdXBwb3J0ZWQ=">https://stackoverflow.com/questions/53988638/git-fatal-protocol-https-is-not-supported<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git问题</tag>
      </tags>
  </entry>
  <entry>
    <title>保姆级教程，教你使用Git推送你的项目到Github</title>
    <url>/2021/08/e1f3bd2d3fb8.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">Git <i class="fa fa-external-link-alt"></i></span> 是一个开源的分布式版本控制系统，它可以高效地帮你管理项目中的文件，作为一个开发人员，了解并学习 Git 是我们的必修课。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">Github<i class="fa fa-external-link-alt"></i></span> 是世界上最大的代码托管中心，可以说 ，不知道 Github 不算一个合格的 Coder。</p>
<p>今天，我就以推送一个本地项目到 Github 为例，带你体验一下 Github 以及 Git 的魅力。</p>
<span id="more"></span>

<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>在开始本教程之前，首先需要提醒几句话。</p>
<ol>
<li>对于新学习 Git 人来说，我一般建议使用命令来操作 Git 仓库，这可以让你更快熟悉 Git 的工作；同样地 ，学好了命令操作便可以在多种不同的系统中无缝切换使用 Git，不用依赖 IDE 以及 GUI 。</li>
<li>由于国内网络的特性，Github在国内常常都是表示为接近 <strong>无法访问</strong>，或者速度很慢，所以，<strong>希望在阅读此文章之前，您已经了解并能够使用 《科学工具》 浏览外国网站。</strong></li>
</ol>
<h2 id="1、注册Github账号"><a href="#1、注册Github账号" class="headerlink" title="1、注册Github账号"></a>1、注册Github账号</h2><p>既然是个网站，为了管理我们自己的仓库，我们需要一个 Github 账号，你可以点击 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpZ251cA==">这里 Join GitHub <i class="fa fa-external-link-alt"></i></span>或者百度搜索 Github 官网进入注册页面：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806114318.png" alt="image-20210806114311586"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806114407.png" alt="image-20210806114406931"></p>
<p>注册的内容就不细说了，按照流程来便是了，最后会有一步验证邮箱，会给你邮箱发送验证信息，将验证的代码填写上去，即注册成功。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806154904.png" alt="image-20210806154857264"></p>
<p>最后点击左上角的 Github 图标，回到首页</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806162232.png" alt="image-20210806162232044"></p>
<h2 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h2><p>Git 是分布式的，每个 Git 仓库在不同的位置都拥有不同的版本。 <strong>本地仓库</strong> 和 <strong>远程仓库</strong> 就是两个不同的仓库。</p>
<p>可以把本地仓库和远程仓库类比为分享文件，假设你拥有一套学习视频，你要通过网盘分享给别人，别人可以通过你的网盘链接下载该文件。</p>
<p>其中：</p>
<p>本地拥有的学习视频类似于 Git 的<strong>本地仓库</strong>，你可以随时更新学习视频的内容，然后将其上传到网盘。</p>
<p>网盘中的视频类似于 Git 的<strong>远程仓库</strong>，你同样可以通过浏览器，网盘客户端等更新操作网盘中的内容，与本地仓库的区别在于存储的位置不一样而已。</p>
<p>网盘的分享链接就是 Git <code>clone</code> 链接，只要拥有了该链接，任何人都可以 <code>clone</code>该项目。</p>
<p>远程的 Git 仓库由 Github 提供管理，而本地我们需要 Git 程序来管理 Git 仓库。</p>
<p>Git 程序是开源的，意味着你在互联网上很容易就能下载到它，Git的官网就有下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZHM=">Git - Downloads (git-scm.com)<i class="fa fa-external-link-alt"></i></span>。</p>
<p>但是，由于国内网络的特性，官网下载的速度奇慢，犹记得作者第一次下载时那 <code>22kB/s</code> 的龟速，对于无法科学上网的同学，这里我给出几个国内的镜像源地址，以供参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2dpdGh1Yi1yZWxlYXNlL2dpdC1mb3Itd2luZG93cy9naXQvTGF0ZXN0UmVsZWFzZS8=">git-for-windows&#x2F;git&#x2F;LatestRelease&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZXBvLmh1YXdlaWNsb3VkLmNvbS9naXQtZm9yLXdpbmRvd3MvdjIuMzIuMC53aW5kb3dzLjEv">Git for Windows | 华为开源镜像站<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>记得下载64位且为 <code>.exe</code> 后缀的版本。</p>
<p>下载后，直接运行安装就是了，除了在这里注意修改一下软件的安装位置之外，建议不做任何改动，直接 <code>Next</code> ：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806170124.png" alt="image-20210806170124937"></p>
<p>最后 <code>Finish</code> 完成安装：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806170236.png" alt="image-20210806170236314"></p>
<h2 id="3、创建远程仓库"><a href="#3、创建远程仓库" class="headerlink" title="3、创建远程仓库"></a>3、创建远程仓库</h2><p>回到 Github 的主页面，点击右上角加号图标，选择 New repository 新建仓库 ：<br><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806170646.png" alt="image-20210806170646128"></p>
<p>填写必要信息：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806171739.png" alt="image-20210806171739064"></p>
<p>点击 Create repository 创建仓库，创建成功自动跳转到该仓库：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806171840.png" alt="image-20210806171840807"></p>
<h2 id="4、初始化本地仓库"><a href="#4、初始化本地仓库" class="headerlink" title="4、初始化本地仓库"></a>4、初始化本地仓库</h2><p>打开文件管理器，进入你的项目文件夹的根目录，笔者这里的项目根文件夹为 MyProject ，然后在空白处右击鼠标右键，选择 Git Bash Here：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806172502.png" alt="image-20210806172502717"></p>
<p>这时会自动弹出一个命令行窗口，这是 Git 自带的命令行程序，和 Git 结合性较好，推荐使用。如果你想其他命令行程序，甚至是 cmd 都可以，只需使用 cd 命令进入这个项目目录即可。</p>
<p>第一步，配置用户信息。上文中提到，Git 是分布式的，一个相同的仓库在不同的人的电脑上可能有不同的版本，Github的远程仓库类似于中央仓库。如果这个仓库是公开的（<code>public</code>），任何人都有可能修改这个仓库的内容。为了知道是谁向仓库产生了修改，必须在本地设置用户信息。</p>
<p>分别输入以下两条命令，设置用户信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;your name&quot;</span> --global</span><br><span class="line">git config user.email <span class="string">&quot;your email&quot;</span> --global</span><br></pre></td></tr></table></figure>

<p>上面的 <code>user.name</code>，<code>user.email</code> 可以任意，不必和 Github 上注册的相同，因为这只是你在本地的一个代号而已。</p>
<p>第二步，初始化仓库。确定自己已经在命令行进入该项目目录，输入初始化命令，初始化该目录为一个 Git 仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806174641.png" alt="image-20210806174641309"></p>
<p>此时，项目根目录会自动生成 <code>.git</code> 隐藏文件夹，存储该仓库的信息，同时代表这个项目目录由 <code>Git</code>管理。</p>
<blockquote>
<p>Windows 10 查看隐藏文件的办法：</p>
<p>在文件资源管理器中，选择左上角的 <strong>查看</strong>，然后在显示的菜单中找到 <strong>隐藏的项目</strong> 并勾选，此时隐藏的文件就会显示出来。</p>
</blockquote>
<p>第三步，添加远程仓库。初始化好本地仓库后，该仓库中所有的文件都会受到 Git 的管理，但是，我们似乎和远程仓库没有任何联系。为了将该仓库推送到远程，我们必须添加远程仓库的位置，让本地仓库能够知道这个仓库应该推送到哪里。</p>
<p>打开我们之前在 Github 上创建的仓库，单击 SSH按钮，然后点击 ssh 链接右方的复制图标复制该链接：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806181456.png" alt="image-20210806181456193"></p>
<p>切换回命令行，使用 <code>git remote add </code> 添加该链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add 别名 <span class="string">&quot;链接地址&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个<strong>链接地址</strong>就代表仓库的位置，别名和链接地址就类似于域名和ip地址的关系，这个别名一般为 origin：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806181917.png" alt="image-20210806181917353"></p>
<p>输入命令 <code>git remote -vv</code> 可以看到添加的仓库信息：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806195930.png" alt="image-20210806195930536"></p>
<p>这样，本地仓库就拥有了远程仓库的位置，可以在后期推送的时候指定该位置。</p>
<h2 id="5、使用SSH密钥"><a href="#5、使用SSH密钥" class="headerlink" title="5、使用SSH密钥"></a>5、使用SSH密钥</h2><p>配置好本地仓库的信息，接下本来应该是推送了。但是，由于我们用的是 SSH 链接，我们还必须配置密钥信息。</p>
<p>第一步，生成密钥对。依然是在Git Bash的命令行，输入生成 SSH 密钥对的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">&quot;comment&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>comment 的内容为备注，即备注改密钥对的信息，可不写。</p>
</blockquote>
<p>接下来会出现几行提示需要要你输入，可以不管，直接回车即可，最终效果如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806192327.png" alt="image-20210806192326998"></p>
<p>第二步，获取生成的公钥。接下来打开系统的文件管理器，进入用户家目录的 <code>.ssh</code> 文件夹，找到刚才建立的 <code>id_rsa.pub</code> 文件，以文本方式打开，复制其中的内容：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806192935.png" alt="image-20210806192935687"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806193145.png" alt="image-20210806193145334"></p>
<p>第三步，将公钥配置到 Github。在 Github 网站右上角找到个人头像的位置，点击头像，在弹出的菜单中点击 <code>Settings</code></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806193742.png" alt="image-20210806193742545"></p>
<p>在左边的菜单中点击 SSH and GPG Keys：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806194149.png" alt="image-20210806194149098"></p>
<p>点击 New SSH Keys，将复制的公钥内容粘贴到 Key 输入框，并给该 SSH Key 定义一个 Title；然后点击下方的 Add SSH key 添加该 Key。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806194742.png" alt="image-20210806194742776"></p>
<p>添加时可能需要验证密码，正常输入便是，最后添加成功的结果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806195528.png" alt="image-20210806195528612"></p>
<p>OK，SSh密钥到此配置成功，接下来就是推送了。</p>
<h2 id="6、提交推送"><a href="#6、提交推送" class="headerlink" title="6、提交推送"></a>6、提交推送</h2><p>第一步，添加文件。切回命令行，要提交，首先得添加要提交的文件，使用 <code>git add</code> 命令添加文件进入 git 管理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>git add .</strong><br><strong>提交所有修改的和新建的数据暂存区</strong></p>
<p><strong>git add -u &lt;&#x3D;&#x3D;&gt; git add –update</strong><br><strong>提交所有被删除和修改的文件到数据暂存区</strong></p>
<p><strong>git add -A &lt;&#x3D;&#x3D;&gt;git add –all</strong><br><strong>提交所有被删除、被替换、被修改和新增的文件到数据暂存区</strong></p>
<p>来自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RheWV3YW5kb3UvYXJ0aWNsZS9kZXRhaWxzLzc4NTEzNTc4">git add -A &#x2F;git add -u&#x2F;git add .的用法_dayewandou的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p>通常我们都使用 git add .</p>
</blockquote>
<p>第二步，查看状态。接下来，我们可以查看文件状态，看看文件是否被添加进了 git 管理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806200426.png" alt="image-20210806200425969"></p>
<p><code>new file</code> 代表添加到了 git 管理的文件。</p>
<p>第三步，提交文件更改。刚才添加的文件只是到了 git 的暂存区，我们还需要提交添加的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;input yours message&quot;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806200940.png" alt="image-20210806200940537"></p>
<p>第四步，推送。使用 <code>push</code> 命令 将本地仓库推送到远程仓库（Github）中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>origin：这就是上面所说的远程仓库的 “别名”</p>
<p>master：代表要推送的分支名称，默认为 master ，可以在 Git Bash 的路径最右端看到。</p>
</blockquote>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806202153.png" alt="image-20210806202153462"></p>
<p>如图，可能会出现提示是否继续连接的输入项，输入 yes 即可。</p>
<p>最后，在 Github 主页中，点击右上角头像 》点击 Your Repositories 》点击建立的远程仓库(first-project) 》。可以看到我们刚才推送的内容已经到了仓库中：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210806202534.png" alt="image-20210806202534349"></p>
<p>（本文完）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RheWV3YW5kb3UvYXJ0aWNsZS9kZXRhaWxzLzc4NTEzNTc4">git add -A &#x2F;git add -u&#x2F;git add .的用法_dayewandou的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0LXNjbS5jb20v">Git (git-scm.com)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>教你设置 VSCode 为 Git 在比较和合并冲突时的可视化工具</title>
    <url>/2022/01/f9f90e4efb98.html</url>
    <content><![CDATA[<p><code>Git</code> 是我们软件开发中经常使用的工具，为了解决日常遇到的各种问题，我们需要使用 <code>Git</code> 提供的各种各样的内置工具，但很多都是在命令行下使用的，对于新手来说并不方便。</p>
<p>本篇介绍一种新的方式，将 <code>Git</code> 的内置工具修改为 <code>VSCode</code> ，方便我们的使用。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多人协作多分支开发往往会遇到分支合并的问题，一般，我们遇到多个分支的合并，大致是以下流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff  =&gt; merge =&gt; add &amp; commit</span><br></pre></td></tr></table></figure>

<p>其中，<code>git diff</code> 命令可以查看分支间的差异，清楚知道各个文件的差异，以便我们知道哪些问题有更改。为了可视化显示，我们会使用  <code>git difftool</code> 。</p>
<p>其次，<code>git merge</code> 命令用于合并分支，如果遇到冲突，则会自动停止，为了可视化解决冲突，我们一般使用 <code>git mergetool</code> 来合并文件。</p>
<p>默认情况下，<code>git difftool</code> 和 <code>git mergetool</code> 会调用类似 <code>vim</code> 的命令行工具来实现文件查看和编辑，<code>vim</code> 的确很强大，但是得熟悉快捷键，上手有难度。</p>
<p>使用过 <code>VSCode</code> 的读者应该都了解，<code>VSCode</code> 的编辑器就自带 <code>diff</code> 工具，那我们是否可以使用 <code>VSCode</code> 来实现 <code>diff</code> 和 <code>merge</code> 的功能呢？</p>
<p>答案是可以的！下面我们就开始配置。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
<p>由于篇幅有限，如何安装 <code>VSCode</code> 的步骤我就不赘述了，没有安装的搜索引擎寻找教程即可。</p>
</blockquote>
<p>为了确保配置能够成功，我们需要确定可以在命令行唤起 <code>VSCode</code> 的窗口。</p>
<p>在任意位置打开 <code>Git Bash</code> 的命令行窗口，输入 <code>code</code> ，如果能够唤起 <code>VSCode</code> 的窗口，则直接跳到 <a href="#%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4">下一节</a>.<br>能够唤起的情况下应该是这样子的：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202201152018906.gif" alt="code-awake"></p>
<p>如果不能唤起，那大概率是没有配置环境变量，在 <code>Windows</code> 下，打开 高级系统设置 &#x3D;&gt; 高级 &#x3D;&gt; 环境变量，找到 <code>PATH</code>，在最后加上一条，内容为你的 <code>VSCode</code> 的安装路径，如 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Development\Microsoft\Microsoft VS Code</span><br></pre></td></tr></table></figure>

<p>具体的路径根据你的安装位置决定，<strong>注意：配置好一定要重启电脑，使环境变量生效</strong>。启动后按照上述方式测试是否能够唤起，确定能够唤起，进入下一步。</p>
<h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><p><code>git difftool</code> 以及 <code>git mergetool</code> 提供了运行时指定特定工具的参数 <code>-t --tool</code>，不过这个工具必须在 <code>git</code> 的配置中定义好。</p>
<ol>
<li><p>添加 <code>VSCode</code>  为 <code>git difftool</code> 可使用的工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global difftool.code.cmd <span class="string">&quot;code --wait --diff <span class="variable">$LOCAL</span> <span class="variable">$REMOTE</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>VSCode</code>  为 <code>git mergetool</code> 可使用的工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global mergetool.code.cmd <span class="string">&quot;code --wait <span class="variable">$MERGED</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后，查看配置列表，检查是否配置成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure>

<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>为了使用更加优雅，请先打开 <code>VSCode</code> 的窗口。否则每个文件可能都要重新打开一次 <code>VSCode</code> 的窗口。</p>
<h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>假设当前为 <code>main</code> 分支，我想查看 <code>dev</code> 分支和当前分支的不同，使用默认方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git difftool dev</span><br></pre></td></tr></table></figure>

<p>调用 <code>VSCode</code>的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git difftool -t code dev</span><br></pre></td></tr></table></figure>

<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>假设当前为 <code>main</code> 分支，我想合并 <code>dev</code> 分支到当前分支，使用默认方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br><span class="line"><span class="comment">#如果出现冲突</span></span><br><span class="line">git mergetool</span><br></pre></td></tr></table></figure>

<p>调用 <code>VSCode</code>的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br><span class="line"><span class="comment">#如果出现冲突</span></span><br><span class="line">git mergetool -t code dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git问题</tag>
        <tag>Git技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础加强：Java反射</title>
    <url>/2019/08/2583cf81c304.html</url>
    <content><![CDATA[<p>Java 在互联网上的飞速发展和使用，离不开诸如 Spring 、SpringMVC、Mybatis 等框架的推出，其极大简化了开发者的精力。</p>
<p>对于各式各样的框架，它们底层使用的依然是 Java 代码，只是它们通过利用 Java 提供的多种特性和技术，简化程序员所需要编写的代码，大大减少了开发时间。</p>
<p>而这篇，就是讲述 Java 框架的核心技术之一，<strong>Java 反射</strong>。</p>
<span id="more"></span>

<h2 id="1-反射的出现"><a href="#1-反射的出现" class="headerlink" title="1. 反射的出现"></a>1. 反射的出现</h2><p>将类的各个组成部分封装成其他对象，这就是 Java 的反射机制，通过反射，我们可以得到每个类的各个组成部分。</p>
<p>由于反射的优秀特性，现代的主流 Web 中使用到的框架 Spring &#x2F; MyBatis 等都大量使用了反射的技术，可以说，反射是框架的灵魂。</p>
<hr>
<h3 id="1-1-Java-代码经历的三个过程"><a href="#1-1-Java-代码经历的三个过程" class="headerlink" title="1.1 Java 代码经历的三个过程"></a>1.1 Java 代码经历的三个过程</h3><p>那么反射是什么？作用在什么地方？要搞清楚这个问题，我们首先看一张图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171612316.png"></p>
<p>这张图简略的描述了一个 Java 程序从编写完成到执行经历的过程。</p>
<p>首先在 <strong>Source 源代码阶段</strong>，假设我们新建了一个 <code>Person.java</code> 文件 ，在里面有一个公有的 Person 类，类里面有成员变量，构造方法，成员方法。</p>
<p>编写好代码之后，我们要运行的话，首先需要 <strong>编译</strong>，使用 Java 自带的<code>javac</code> 命令编译后，此时在我们的目录下会生成一个 Java 字节码文件 <code>Person.class</code>。</p>
<p><code>Person.class</code> 文件中包含这个类文件的所有信息，主要有三部分内容。一部分是我们所有的成员变量，一部分是我们的构造方法，一部分是我们的成员方法。当然其中不止这些内容，还有类名等等其他信息，<code>.class</code> 文件是 Java 跨平台的基础。</p>
<p>编译好的 Java 字节码文件（<code>.class</code> 后缀）开始是在硬盘中的，而程序都是在内存中运行的，在使用之前我们应将其加载到内存中去。</p>
<p>如何将字节码加载到内存中呢？在 Java 中，负责加载硬盘上的字节码文件到内存中的工具称为 <strong>类加载器（ClassLoader）</strong> ，它是一个对象，它负责将类对应的字节码文件加载到内存中。</p>
<p>而在Java中，万物皆对象，在内存中，也有一个对象负责存储描述字节码文件中的信息，该对象为<code>Class</code> 类的对象，在 Java 的 api 中，我们也可以找到这个类：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171611131.png"></p>
<p>在被加载的类 Class 对象中，包含了这个<strong>类所有共同的类型信息</strong>。什么是共同的类型信息呢？就比如 <strong>每个类的成员变量，构造方法，成员方法，类名</strong>….等等。<br>这里我们也要注意一个点，一个 class 字节码文件对应一个 Class 对象，也就是说，无论你创建了多少个实例对象，在 JVM（Java 虚拟机） 或者说内存中只会存在一个 Class 对象，其负责描述类的共同类型信息。具体对应关系看下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171611349.png"></p>
<p>于是在<code>Class</code>对象中，每一个成员变量都被封装成一个<code>Field</code>对象，而多个成员变量就形成了<code>Field []</code>对象数组。构造方法，成员方法也是如此，在 Class 类中，他们的对应关系为：</p>
<table>
<thead>
<tr>
<th align="center">组成部分</th>
<th align="left">对象名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员变量</td>
<td align="left">Field</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="left">Constructor</td>
</tr>
<tr>
<td align="center">成员方法</td>
<td align="left">Method</td>
</tr>
</tbody></table>
<p>第二阶段加载类的步骤执行完后，JVM再根据<code>Class</code>对象中的信息实例对象，至此，对象才被真正创建。</p>
<h3 id="1-2-反射的思想"><a href="#1-2-反射的思想" class="headerlink" title="1.2 反射的思想"></a>1.2 反射的思想</h3><p>根据我们上面的分析，类在被使用前，应先被类加载器加载到内存中以<code>Class</code>对象的方式存在，<code>Class</code> 对象将类的成员变量，构造函数，成员方法封装成不同的对象。</p>
<p>那么我们可不可以这样想，当一个Person类的对象在使用时，由于其共有的<code>Class</code> 对象中将该对象的成员变量，构造函数，成员方法等封装成了对象，我们是不是可以通过操作这些封装好的对象来操控Person对象中的相关信息？</p>
<p>答案时肯定的，这也就是反射的实现思想，在程序的运行过程中，能够知道程序的所有属性和方法，也能够随时调用改变其中的属性和方法，这就是<span style="color:red">反射机制</span></p>
<p>使用反射的优点如下：</p>
<ul>
<li>可以在程序的运行过程中去操作这些对象</li>
<li>可以解耦，提高程序的阿可扩展性</li>
</ul>
<hr>
<blockquote>
<p>知道了反射的概念之后，我们使用一些案例来分析反射的基本使用</p>
</blockquote>
<h2 id="2-反射的基本使用"><a href="#2-反射的基本使用" class="headerlink" title="2. 反射的基本使用"></a>2. 反射的基本使用</h2><h3 id="2-1-获取Class对象"><a href="#2-1-获取Class对象" class="headerlink" title="2.1 获取Class对象"></a>2.1 获取Class对象</h3><p>通过上面的分析，我们知道了反射可以操控类的<code>Class</code> 对象，那么在使用反射之前，我们应该先获得类的<code>Class</code> 对象。</p>
<p>我们可以使用如下三种方式获得<code>Class</code> 对象，对应Java代码经历的三个阶段。</p>
<ol>
<li><p>类还未被加载进内存，也就是源代码阶段使用</p>
<p><span style="color:blue">Class.forName(“全类名”) ：将字节码文件加载进内存，返回Class对象。</span></p>
</li>
<li><p>类已经被加载进内存了，但是实例对象还没创建时使用</p>
<p><span style="color:blue">类名.class：通过类名的属性class获取</span></p>
</li>
<li><p>类已经被实例化，也就是已经有了实例对象时使用</p>
<p><span style="color:blue">对象名.getClass()：利用Object类中定义的getClass()方法</span></p>
</li>
</ol>
<p>文字描述可能不够透彻，我们使用代码来验证以下我们的结果。</p>
<p>我们打开idea ，新建一个java项目，名字为ReflectDemo，然后新建一个实体类Person，一个ReflectDemo1，此时项目结构如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171611066.png"></p>
<p>然后我们在Person类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>相应的ReflectDemo1的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三种不同的获取Class对象的方式：</span></span><br><span class="line"><span class="comment">     * 1、Class.forName(&quot;全类名&quot;) ：将字节码文件加载进内存，返回Class对象。</span></span><br><span class="line"><span class="comment">     * 2、类名.class：通过类名的属性class获取</span></span><br><span class="line"><span class="comment">     * 3、对象名.getClass()：利用Object类中定义的getClass()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1.Class.forName(&quot;类名&quot;)</span></span><br><span class="line">        <span class="comment">//注意这里的字符串是全类名，也就是包名+类名，我这直接写类名的原因是我没有定义包。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">        System.out.println(cla1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla2</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        System.out.println(cla2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.对象名.getClass()</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cla3</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        System.out.println(cla3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171612571.png"></p>
<p>可以看到，输出的结果是一样的，那么是不是他们都是同一个Class对象吗？</p>
<p>我也不确定，单纯靠输出不能完全判定，我们还需要通过一些验证代码来确定。</p>
<p>根据我们以前学过的知识，判断两个对象是否相等，也就是引用指向的内存空间是否相同，我们可以使用 <code>==</code>运算符。</p>
<p>那么我们添加代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断三个对象是否相等</span></span><br><span class="line">      System.out.println(cla1 == cla2);</span><br><span class="line">      System.out.println(cla1 == cla3);</span><br><span class="line">      System.out.println(cla2 == cla3);</span><br></pre></td></tr></table></figure>

<p>然后运行：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171612310.png"></p>
<p>结果都为true，他们的对象都是一样的。这说明了什么？</p>
<p>我们整理一下思路</p>
<ol>
<li>首先<code>cla1</code>对象我们通过<code>Class.forName(&quot;Person&quot;)</code> 获得，而此时类还为被加载。</li>
<li><code>cla2</code> 对象我们通过<code>Person.class</code> 获得，此时类已经加载但是没有实例化。</li>
<li><code>cla3</code>对象我们通过<code>p.getClass()</code>获得，此时类已经实例化。</li>
</ol>
<p>通过对比，三个对象都是同一个对象，也就是说，对于同一个类，它在依次运行时只会被加载一次，且只存在一个<code>Class</code> 对象。</p>
<h3 id="2-2-使用Class对象"><a href="#2-2-使用Class对象" class="headerlink" title="2.2 使用Class对象"></a>2.2 使用Class对象</h3><p>关于Class对象的使用，主要分为四类：</p>
<ol>
<li>成员变量Field对象的使用</li>
<li>构造方法Constructor对象的使用</li>
<li>成员方法Method对象的使用</li>
<li>对类名的获取</li>
</ol>
<p>下面我们来分析他们的具体用法。</p>
<h4 id="2-2-1-使用Field类操作成员变量"><a href="#2-2-1-使用Field类操作成员变量" class="headerlink" title="2.2.1 使用Field类操作成员变量"></a>2.2.1 使用Field类操作成员变量</h4><p>Class类中有关Field类的基本操作如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Field</code></td>
<td align="center"><code>getField(String name)</code></td>
<td align="center">获取指定name名称、具有public修饰符的变量（字段），包括继承字段。</td>
</tr>
<tr>
<td align="center"><code>Field[]</code></td>
<td align="center"><code>getFields()</code></td>
<td align="center">获取所有具有public修饰符的变量（字段），包括继承字段</td>
</tr>
<tr>
<td align="center"><code>Field</code></td>
<td align="center"><code>getDeclaredField(String name )</code></td>
<td align="center">获取指定name名称的变量（字段），且不考虑修饰符（包括private修饰的），不包括继承字段。</td>
</tr>
<tr>
<td align="center"><code>Field[]</code></td>
<td align="center"><code>getDeclaredFields()</code></td>
<td align="center">获取类中所有变量（字段），不考虑修饰符（包括private修饰的），不包括继承字段</td>
</tr>
</tbody></table>
<p>Field类中常用的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Object</code></td>
<td align="center"><code>get(Object obj)</code></td>
<td align="center">返回指定对象上此 Field 对象所表示的字段的值</td>
</tr>
<tr>
<td align="center"><code>void</code></td>
<td align="center"><code>set(Object obj ,  Object value)</code></td>
<td align="center">将指定对象(obj)变量上此 Field 对象表示的字段设置为指定的新值(value)</td>
</tr>
<tr>
<td align="center"><code>void</code></td>
<td align="center"><code>setAccessible(boolean flag)</code></td>
<td align="center">将此对象的 accessible 标志设置为指定的布尔值，accessible 属性默认为false，设置为true后我们称为《暴力反射》</td>
</tr>
</tbody></table>
<p>首先在<code>Person</code>类修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作测试Filed类的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&quot;male&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> <span class="string">&quot;篮球&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hobby=&#x27;&quot;</span> + hobby + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后新建一个ReflecField文件，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class对象中关于Field的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Person类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">pes</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********输出结果**********&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getField(String name )的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getField(String name )的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//注意这里name对应的字段一定要是public修饰的，且该字段存在</span></span><br><span class="line">        <span class="comment">//如不满足上述条件，会抛出 NoSuchFieldException 异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> pes.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            System.out.println(age);<span class="comment">//age为private修饰，这里不会输出任何值，且抛出NoSuchFieldException异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException nfe)&#123;</span><br><span class="line">            nfe.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">height</span> <span class="operator">=</span> pes.getField(<span class="string">&quot;height&quot;</span>);</span><br><span class="line">        System.out.println(height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getFields()的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有具有public修饰符的变量（字段），包括继承字段</span></span><br><span class="line">        Field[] fields = pes.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f: fields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclaredField(String name )的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定name名称的变量（字段），且不考虑修饰符（包括private修饰的），不包括继承字段。</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age1</span> <span class="operator">=</span> pes.getDeclaredField(<span class="string">&quot;age&quot;</span>); <span class="comment">//age为private修饰</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name1</span> <span class="operator">=</span> pes.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">//name字段为private修饰</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">sex</span> <span class="operator">=</span> pes.getDeclaredField(<span class="string">&quot;sex&quot;</span>);  <span class="comment">//sex为protected修饰</span></span><br><span class="line">        System.out.println(sex);</span><br><span class="line">        System.out.println(age1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclaredFields()的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取类中所有变量（字段），不考虑修饰符（包括private修饰的），不包括继承字段</span></span><br><span class="line">        Field[] fields1 = pes.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields1)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------获取变量的值----------&quot;</span>);</span><br><span class="line">        <span class="comment">//返回指定对象上Field表示的值</span></span><br><span class="line">        <span class="comment">//会对你访问的字段进行权限修饰符检查。也就是private的不可访问</span></span><br><span class="line">        <span class="comment">//如想访问私有，必须使用setAccessible(true)《暴力反射》来忽略权限修饰符的检查</span></span><br><span class="line">        <span class="comment">//否则抛出IllegalAccessException异常</span></span><br><span class="line">        System.out.println(height.get(p));</span><br><span class="line">        System.out.println(sex.get(p));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//age1为获取到的私有对象</span></span><br><span class="line">            System.out.println(age1.get(p));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException iae)&#123;</span><br><span class="line">            iae.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        age1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(age1.get(p));<span class="comment">//输出为0，这是因为int类型默认值为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------设置变量的值----------&quot;</span>);</span><br><span class="line">        <span class="comment">//将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</span></span><br><span class="line">        <span class="comment">//会对你访问的字段进行权限修饰符检查。也就是private的不可访问</span></span><br><span class="line">        <span class="comment">//如想访问私有，必须使用setAccessible(true)《暴力反射》来忽略权限修饰符的检查</span></span><br><span class="line">        <span class="comment">//否则抛出IllegalAccessException异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改所有属性值：&quot;</span> + p.toString());</span><br><span class="line">        height.set(p,<span class="number">170</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//name1为获取到的私有对象</span></span><br><span class="line">            name1.set(p,<span class="string">&quot;小千&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException iae)&#123;</span><br><span class="line">            iae.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看name字段设定可访问之前属性值</span></span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">        name1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name1.set(p,<span class="string">&quot;小千&quot;</span>);</span><br><span class="line">        <span class="comment">//查看name字段设置可访问之后的属性值</span></span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**********输出结果**********</span><br><span class="line"></span><br><span class="line">----------getField(String name )的使用----------</span><br><span class="line">java.lang.NoSuchFieldException: age</span><br><span class="line">4at java.lang.Class.getField(Class.java:<span class="number">1703</span>)</span><br><span class="line">4at ReflectField.main(ReflectField.java:<span class="number">23</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.height</span><br><span class="line"></span><br><span class="line">----------getFields()的使用----------</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.height</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.weight</span><br><span class="line"></span><br><span class="line">----------getDeclaredField(String name )的使用----------</span><br><span class="line"><span class="keyword">protected</span> java.lang.String Person.sex</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Person.age</span><br><span class="line"></span><br><span class="line">----------getDeclaredFields()的使用----------</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Person.age</span><br><span class="line"><span class="keyword">private</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.height</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.weight</span><br><span class="line"><span class="keyword">protected</span> java.lang.String Person.sex</span><br><span class="line">java.lang.String Person.hobby</span><br><span class="line"></span><br><span class="line">----------获取变量的值----------</span><br><span class="line">heght：<span class="number">180</span></span><br><span class="line">sex：male</span><br><span class="line"></span><br><span class="line">java.lang.IllegalAccessException: Class ReflectField can not access a member of <span class="keyword">class</span> <span class="title class_">Person</span> with modifiers <span class="string">&quot;private&quot;</span></span><br><span class="line">4at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:<span class="number">102</span>)</span><br><span class="line">4at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:<span class="number">296</span>)</span><br><span class="line">4at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:<span class="number">288</span>)</span><br><span class="line">4at java.lang.reflect.Field.get(Field.java:<span class="number">390</span>)</span><br><span class="line">4at ReflectField.main(ReflectField.java:<span class="number">67</span>)</span><br><span class="line"></span><br><span class="line">age：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">----------设置变量的值----------</span><br><span class="line">修改所有属性值：Person&#123;age=<span class="number">0</span>, name=<span class="string">&#x27;null&#x27;</span>, height=<span class="number">180</span>, sex=<span class="string">&#x27;male&#x27;</span>, hobby=<span class="string">&#x27;篮球&#x27;</span>&#125;</span><br><span class="line">java.lang.IllegalAccessException: Class ReflectField can not access a member of <span class="keyword">class</span> <span class="title class_">Person</span> with modifiers <span class="string">&quot;private&quot;</span></span><br><span class="line">4at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:<span class="number">102</span>)</span><br><span class="line">4at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:<span class="number">296</span>)</span><br><span class="line">4at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:<span class="number">288</span>)</span><br><span class="line">4at java.lang.reflect.Field.set(Field.java:<span class="number">761</span>)</span><br><span class="line">4at ReflectField.main(ReflectField.java:<span class="number">84</span>)</span><br><span class="line">Person&#123;age=<span class="number">0</span>, name=<span class="string">&#x27;小千&#x27;</span>, height=<span class="number">170</span>, sex=<span class="string">&#x27;male&#x27;</span>, hobby=<span class="string">&#x27;篮球&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-使用Constructor类"><a href="#2-2-2-使用Constructor类" class="headerlink" title="2.2.2 使用Constructor类"></a>2.2.2 使用Constructor类</h4><p>Class类中有关Constructor类的基本方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Constructor&lt;T&gt;</code></td>
<td align="center"><code>getConstructor(Class&lt;?&gt;....parameterTypes)</code></td>
<td align="center">返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td align="center"><code>Constructor&lt;?&gt; []</code></td>
<td align="center"><code>getConstructors()</code></td>
<td align="center">返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td align="center"><code>Constructor&lt;T&gt;</code></td>
<td align="center"><code>getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</code></td>
<td align="center">返回指定参数类型、且不考虑权限修饰符（包括private）声明的构造函数对象</td>
</tr>
<tr>
<td align="center"><code>Constructor&lt;?&gt;[]</code></td>
<td align="center"><code>getDeclaredConstructors()</code></td>
<td align="center">返回所有声明的构造函数对象、且不考虑权限修饰符（包括private）</td>
</tr>
<tr>
<td align="center"><code>T</code></td>
<td align="center"><code>newInstance()</code></td>
<td align="center">调用类的空参构造创建此 Class 对象所表示类的一个实例，返回创建的实例，</td>
</tr>
</tbody></table>
<p>在Person类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造方法</span></span><br><span class="line"><span class="comment">    * 用作测试Constructor类使用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>新建一个ReflectConstructor，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectConstructor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Class对象中关于Constructor的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Person类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">pes</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********输出结果**********&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getConstructor(Class&lt;?&gt;....parameterTypes)的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------getConstructor(Class&lt;?&gt;....parameterTypes)的使用-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取带int,String 参数的构造方法对象</span></span><br><span class="line">        <span class="comment">//获取的构造方法一定要是 public 修饰且存在的</span></span><br><span class="line">        <span class="comment">//否则抛出NoSuchMethodException</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> pes.getConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//Constructor 对象通过调用 newInstance()方法来运行构造方法实例化对象</span></span><br><span class="line">        <span class="comment">//newInstance() 方法中的参数填写根据获得Constructor对象时传入的参数</span></span><br><span class="line">        <span class="comment">//我这里上面传入了int.class , String.class 所以这里带的参数为int，String型</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> constructor.newInstance(<span class="number">10</span>, <span class="string">&quot;小千&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getConstructors()的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------getConstructors()的使用-----------&quot;</span>);</span><br><span class="line">        Constructor[] constructors = pes.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: constructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)的使用的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)的使用-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取修饰符为私有的构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> pes.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//注意这里使用私有构造之前必须将其设为可访问,否则会抛异常</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p2</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;大千&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredConstructors()的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------getDeclaredConstructors()的使用-----------&quot;</span>);</span><br><span class="line">        Constructor[] constructors1 = pes.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c: constructors1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//newInstance()的使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------newInstance()的使用-----------&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Class对象调用其newInstance()方法，实例化该类的对象</span></span><br><span class="line">        <span class="comment">//newInstance()方法实际上是调用了类的空参构造函数来实例对象的</span></span><br><span class="line">        <span class="comment">//注意这里newInstance()方法参数必须为空</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">p3</span> <span class="operator">=</span> pes.newInstance();</span><br><span class="line">        System.out.println(p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**********输出结果**********</span><br><span class="line"></span><br><span class="line">------------getConstructor(Class&lt;?&gt;....parameterTypes)的使用-----------</span><br><span class="line">Person&#123;age=10, name=&#x27;小千&#x27;, height=180, sex=&#x27;male&#x27;, hobby=&#x27;篮球&#x27;&#125;</span><br><span class="line"></span><br><span class="line">------------getConstructors()的使用-----------</span><br><span class="line">public Person(int,java.lang.String)</span><br><span class="line">public Person()</span><br><span class="line"></span><br><span class="line">------------getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)的使用-----------</span><br><span class="line">Person&#123;age=10, name=&#x27;小千&#x27;, height=180, sex=&#x27;male&#x27;, hobby=&#x27;篮球&#x27;&#125;</span><br><span class="line"></span><br><span class="line">------------getDeclaredConstructors()的使用-----------</span><br><span class="line">public Person(int,java.lang.String)</span><br><span class="line">public Person()</span><br><span class="line">private Person(java.lang.String)</span><br><span class="line"></span><br><span class="line">------------newInstance()的使用-----------</span><br><span class="line">Person&#123;age=0, name=&#x27;null&#x27;, height=180, sex=&#x27;male&#x27;, hobby=&#x27;篮球&#x27;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-使用Method类"><a href="#2-2-3-使用Method类" class="headerlink" title="2.2.3 使用Method类"></a>2.2.3 使用Method类</h4><p>Class 类中有关Method类的基本操作如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Method</code></td>
<td align="center"><code>getMethod(String name, Class&lt;?&gt;....parameterTypes)</code></td>
<td align="center">返回一个指定参数类型的已声明的 Method 对象，包括继承的父类 public 方法。</td>
</tr>
<tr>
<td align="center"><code>Method []</code></td>
<td align="center"><code>getMethods()</code></td>
<td align="center">返回该Class对象中所有由 public 权限修饰符且已声明的 Method 方法对象，包括继承的父类 public 方法。</td>
</tr>
<tr>
<td align="center"><code>Method</code></td>
<td align="center"><code>getDeclaredMethod(String name, Class&lt;?&gt;...parameterTypes)</code></td>
<td align="center">返回指定参数类型、且不考虑权限修饰符（包括private）的已声明的声明的方法 Method 对象，但不包括继承的方法。</td>
</tr>
<tr>
<td align="center"><code>Method[]</code></td>
<td align="center"><code>getDeclaredMethods()</code></td>
<td align="center">返回所有已声明的方法 Method 对象、且不考虑权限修饰符（包括private），但不包括继承的方法</td>
</tr>
</tbody></table>
<p>在Person类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用作测试Method类的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;运行 public show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行 private display&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>新建一个 ReflectMethod 类，添加代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethod</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class对象中关于Method的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Person类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">pes</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个Person实例</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********输出结果**********&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------getMethod(String name, Class&lt;?&gt;....parameterTypes)的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获得Class对象中public修饰的已声明的指定参数的方法的对象，传入参数</span></span><br><span class="line">        <span class="comment">//由于一个方法都是由方法名和参数列表指定的，这里方法参数需要指定方法名，后面接参数列表的class</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> pes.getMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//invoke 负责执行方法对象指定的方法，传入指定执行的实例对象，和参数列表</span></span><br><span class="line">        show.invoke(p,<span class="string">&quot;千&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getMethods()的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获的Class对象中所有public权限修饰符修饰的方伐，包括父类的方法</span></span><br><span class="line">        <span class="comment">//这里打印出来了Object类的方法，验证结论</span></span><br><span class="line">        Method[] methods = pes.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclaredMethod(String name, Class&lt;?&gt;...parameterTypes)的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定参数类型、且不考虑权限修饰符（包括private）的已声明的方法 Method 对象，但不包括继承的方法。</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">display</span> <span class="operator">=</span> pes.getDeclaredMethod(<span class="string">&quot;display&quot;</span>);</span><br><span class="line">        System.out.println(display);</span><br><span class="line">        <span class="comment">//忽略权限修饰符，暴力反射</span></span><br><span class="line">        display.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        display.invoke(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclaredMethods()的使用----------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有已声明的方法 Method 对象、且不考虑权限修饰符（包括private），但不包括继承的方法</span></span><br><span class="line">        <span class="comment">//这里没有打印出来Object类的方法，无法获得继承（父类）的方法对象</span></span><br><span class="line">        Method[] declaredMethods = pes.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**********输出结果**********</span><br><span class="line">----------getMethod(String name, Class&lt;?&gt;....parameterTypes)的使用----------</span><br><span class="line">千</span><br><span class="line">运行 <span class="keyword">public</span> show</span><br><span class="line">----------getMethods()的使用----------</span><br><span class="line">能够获得Object类的方法对象</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.show(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.setAge(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.getAge()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">----------getDeclaredMethod(String name, Class&lt;?&gt;...parameterTypes)的使用----------</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> Person.display()</span><br><span class="line">运行 <span class="keyword">private</span> display</span><br><span class="line">----------getDeclaredMethods()的使用----------</span><br><span class="line">不能获得Object类的方法对象</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.toString()</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.setName(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> Person.display()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.show(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Person.setAge(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Person.getAge()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-2-4-获取类名"><a href="#2-2-4-获取类名" class="headerlink" title="2.2.4 获取类名"></a>2.2.4 获取类名</h4><p>获取类名的方法相对简单，通过以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Person类的class对象</span></span><br><span class="line">      <span class="type">Class</span> <span class="variable">pes</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">      <span class="comment">//返回由类对象表示的实体（类，接口，数组类，原始类型或空白）的名称，作为 String</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pes.getName();</span><br><span class="line">      System.out.println(className);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名：Person</span><br></pre></td></tr></table></figure>



<p>OK，反射使用基本结束。</p>
<h2 id="3-参考链接："><a href="#3-参考链接：" class="headerlink" title="3. 参考链接："></a>3. 参考链接：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzcwNzY4MzY5">深入理解Java类型信息(Class对象)与反射机制<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 反射</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础加强：Java注解</title>
    <url>/2019/08/11374cc80408.html</url>
    <content><![CDATA[<p>上篇我们讲述了框架中核心技术 Java 反射 的使用，介绍了它功能的强大之处。</p>
<p>本篇我们讲述另一个框架使用的重要技术，<strong>Java 注解</strong></p>
<span id="more"></span>

<h2 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1. 什么是注解"></a>1. 什么是注解</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是 <strong>JDK1.5</strong> 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明。</p>
<p>举个例子，注释我们都知道，注释是对程序的一些说明，是为了让程序员看得懂程序而编写的。</p>
<p>而注解也是对程序的说明，不过是给计算机看的，计算机通过注解得到信息，可以把注解理解为标签，给类、方法、成员变量贴上标签，对他们进行一些说明。</p>
<p>在使用 Junit 单元测试时，我们在每一个单元测试的方法上都要加上一个<code>@Test</code> 注解，这个注解就是告诉测试程序这个方法是测试方法，是可以用作单元测试的，可以直接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 测试add方法</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        //1.创建计算器对象</span><br><span class="line">        Calculator ca = new Calculator();</span><br><span class="line">        //调用add方法</span><br><span class="line">        int result = ca.add(1,3);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-注解的基本结构"><a href="#1-2-注解的基本结构" class="headerlink" title="1.2 注解的基本结构"></a>1.2 注解的基本结构</h3><p>接下来我们从源码找寻注解的结构。</p>
<p>首先我们查看 SuppressWarnings 注解内部内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，里面的结构为两个注解 + 一个用@interface声明的名称，该名称<code>&#123;&#125;</code>范围中还有一个类似方法定义的<code>String[] value()</code>。</p>
<h4 id="1-2-1-注解定义分析"><a href="#1-2-1-注解定义分析" class="headerlink" title="1.2.1 注解定义分析"></a>1.2.1 注解定义分析</h4><p>首先我们看<code>@interface</code> ，它其实是一种标识符，标识声明为一个注解，就如同<code>class</code>标识为声明为类一样。</p>
<p>那么 @interface 内部到底是如何实现注解定义的呢，我们可以通过反编译查看其中的内容，首先我们在任意目录下新建一个 MyAnno.java 文件，然后打开命令行窗口并定位到该目录，执行以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac MyAnno.java <span class="comment">//编译形成class文件</span></span><br><span class="line">javap MyAnno.class <span class="comment">//反编译</span></span><br></pre></td></tr></table></figure>

<p>可以看到在执行第二条命令的下面出现以下代码信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;MyAnno.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyAnno</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我们就很熟悉了，这不就是声明了一个名字为 MyAnno 的接口然后继承了 <code>java.lang.annotation.Annotation</code> 吗，那么 <code>java.lang.annotation.Annotation</code> 是啥，我们打开API文档，搜索 Annotation ，可以看到这么一段内容：</p>
<blockquote>
<ul>
<li>public interface Annotation</li>
</ul>
<p>所有注解类型扩展的公共接口。  注意，手动扩展这个接口不限定注解类型。 还要注意，此接口本身并不定义注解类型。  有关注解类型的更多信息，请参见The Java™ Language Specification的第9.6 节  。 <a href="../../../java/lang/reflect/AnnotatedElement.html"><code>AnnotatedElement</code></a>接口讨论了将注解类型从不可重复性转变为可重复时的兼容性问题。</p>
</blockquote>
<p>到这基本就清楚了，@interface 用来定义一个注解，而且注解底层本质是一个接口，所有注解默认继承了 <code>java.lang.annotation.Annotation</code>接口  当然要注意，<strong>注解不支持继承</strong>，不可以使用 extends 关键字继承自 @interface 。</p>
<h4 id="1-2-2-元注解"><a href="#1-2-2-元注解" class="headerlink" title="1.2.2 元注解"></a>1.2.2 元注解</h4><p>我们再观察上面两个注解 @Target 和 @Retention 。</p>
<p><code>@Target</code>，<code>@Retention</code>两个注解其实是由 Java 提供的 <strong>元注解</strong> ，所谓元注解就是注解的注解，可能有点懵，我这样解释一下：</p>
<p>比如在类上面使用注解是表述类或描述类的一些信息，而<strong>元注解在注解中的使用就是用来表述或定义注解的一些信息</strong>。下面我们分别对这两个元注解进行分析。</p>
<ul>
<li><p><strong>@Target注解</strong></p>
<p>查看 @Target 注解的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//返回注释类型的元素种类的数组</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到注解内容中有一个 <code>ElementType[] value()</code> 。</p>
<p>ElementType 为枚举类型，其作用是帮助我们在定义 Target 注解时指定传入的值，其中定义的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> * <span class="meta">@author</span>  Joshua Bloch</span><br><span class="line"> * <span class="meta">@since</span> <span class="number">1.5</span> <span class="comment">// 1.5版本之后可用</span></span><br><span class="line"> * <span class="meta">@jls</span> <span class="number">9.6</span><span class="number">.4</span><span class="number">.1</span> <span class="meta">@Target</span></span><br><span class="line"> * <span class="meta">@jls</span> <span class="number">4.1</span> The Kinds of Types and Values</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可以用于类、接口、（包括注解类型）或枚举类型之上</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    <span class="comment">//表明该注解可用于字段，包括enum常量之上</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可用于方法之上</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可用于方法参数之上</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    <span class="comment">//表明可用于构造函数之上</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可用于局部变量之上</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可用于注解之上</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    <span class="comment">//表明该注解可以用于包之上</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8 从java 1.8 开始可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//表明该注解可用于类型参数</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8 从java 1.8 开始可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//表明该注解可用于类型使用</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>Target 是目标的意思，@Target 就是约束注解可以使用的范围，例如我想约束注解只可作用于<strong>方法</strong>上，那么我就需要在注解的定义上声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解作用于方法上</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoBasic &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Target 中的成员变量<code>ElementType[] value()</code>是一个数组，也就是意味着可以同时出传入多个类型相同但数值不同的值。</p>
<p>  例如我想使注解作用于类、方法、成员变量上，就可以这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解作用于类、方法、成员变量上。</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoBasic &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过在这里要注意使用大括号<code>&#123;&#125;</code>将这些属性括起来表示为数组。</p>
<p><strong>还有一点</strong>，当注解上没有使用 @Target 注解约束时，表示该注解可以作用于任何元素之上。</p>
</li>
<li><p><strong>@Retention注解</strong></p>
<p>查看@Retention注解的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//返回保留的策略</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似 @Target 注解，这里也有一个成员属性值 value（），类型为<code>RetentionPolicy</code>。RetentionPolicy也是枚举类型，其中封装的值帮助我们定义@Retention注解指定传入的值，其中内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//表明注解被编译器丢弃（该类型的注解信息只会保留在源码里）</span></span><br><span class="line">    <span class="comment">//源码经过编译后，注解信息就会被丢弃，不会保留在class文件中</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//表明注解会被记录在class文件中，但VM（虚拟机）在运行时不会被保留该注解，该内容不会被加载到虚拟机中。</span></span><br><span class="line">    <span class="comment">//在不手动指定注解的生命周期时，默认注解声明周期都是该值</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   4<span class="comment">//表明该注解会被记录在class文件中而且在VM（虚拟机）运行时会被保留</span></span><br><span class="line">    <span class="comment">//虚拟机会加载class文件中的该注解的内容，可以使用反射机制读取该注解的内容</span></span><br><span class="line"></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>具体每个属性的信息可以查看上面的代码注释，说明的很清楚，我再说几点。</p>
<p>第一，类似@Override、@SuppressWarning这些对代码编写规范的提示类注解，他们的作用周期都是 SOURCE 也就是源码阶段。</p>
<p>第二，在目前的主流框架中，将注解定义为 RUNTIME 运行时时用的比较多的，如SpringMvc中的@Controller、@Autowired、@RequestMapping等。定义在运行时，我们可以通过反射获取注解的内容，可以简化代码。</p>
</li>
<li><p><strong>@Inherited注解</strong></p>
<p>@Inherited 负责指定注解可以被继承，但不是真正意义上的继承，<strong>注解本质上是不可以继承的</strong>，我们无法使用<code>extends</code>标识符继承自 @interface 。这里的继承指得是<strong>可以让子类通过反射使用Class对象中的getAnnotations() 获取父类被@Inherited修饰的注解</strong>，具体请看以下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> *  /<span class="doctag">@Inherited</span>表明注解可继承的示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Anno1&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Anno1被使用&quot;</span>;</span><br><span class="line">    <span class="comment">//定义@Inherited的注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Anno2&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Anno2被使用&quot;</span>;</span><br><span class="line">    <span class="comment">//没有定义@Inherited的注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Anno1</span></span><br><span class="line"><span class="meta">@Anno2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//获得子类B的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.annotation.B&quot;</span>);</span><br><span class="line">44<span class="comment">//获得子类B上面定义的所有注解（注意该注解是要定义在类的声明上面的）</span></span><br><span class="line">        Annotation[] ano = cls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation a : ano) &#123;</span><br><span class="line">            <span class="comment">//获得的注解类型如果来自Anno1注解，输出该注解中value的值</span></span><br><span class="line">            <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Anno1) &#123;</span><br><span class="line">                System.out.println(((Anno1)a).value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获得的注解类型如果来自Anno2注解，输出该注解中value的值</span></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Anno2) &#123;</span><br><span class="line">                System.out.println(((Anno2)a).value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Anno1被使用</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@Documented</strong></p>
<p>说明该注解将被包含在javadoc中。和注释一样，注解虽然会在源码中显示，但是 javadoc 命令生成的文档默认会隐藏注解内容，如果我们想让某个注解在 javadoc 中可显示，在注解中定义即可，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义注解可以在java文档中出现</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@interface DO&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-3-注解元素（属性）"><a href="#1-2-3-注解元素（属性）" class="headerlink" title="1.2.3 注解元素（属性）"></a>1.2.3 注解元素（属性）</h4><h5 id="p1-基本定义和使用"><a href="#p1-基本定义和使用" class="headerlink" title="p1. 基本定义和使用"></a>p1. 基本定义和使用</h5><p>在上面 @SuppressWarning 注解的定义内容中，有一个<code>String[] value()</code>。</p>
<p>这其实是注解的属性，或者说是元素。在前面的分析中，我们知道，注解的本质是一个接口，在接口中，我们可以定义抽象方法，在注解中我们同样可以，只不过在注解中，抽象方法被用来表示注解的元素。</p>
<p>于是在注解中注解元素的定义以 <strong>无形参的方法</strong> 形式声明，方法名定义了该元素的名字，返回值定义了该元素的类型。</p>
<p>在大多数自定义注解中，一般都会声明一些元素以标识某些值，方便程序使用，比如我们上面使用的 Target 注解，它在注解定义中定义了一个成员属性，那么我们就可以在声明注解的时候传入相关值来实现不同的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">//注解应用于方法上</span></span><br></pre></td></tr></table></figure>

<p>在注解定义中，支持如下的数据类型：</p>
<ul>
<li>所有的基本类型（int,float,boolean,byte,double,char,long,short）</li>
<li>String 字符串</li>
<li>Class 类对象</li>
<li>enum 枚举</li>
<li>Annotation 注解</li>
<li>上述类型的数组</li>
</ul>
<p>除以上的类型之外，在注解中不可使用其他类型或是说基础类型的包装类型如 <code>Integer</code>，不然编译器会报错。</p>
<p>还有一点就是和定义成员变量一样，注解元素也支持定义默认值，在某个元素定义了默认值后，我们在使用注解时可以不指定该元素的值。定义默认值方法是在定义的注解元素名后用 <code>defult</code> 指定。</p>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.annotation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解作用于类、方法、成员变量上。</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoBasic &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注解作用于方法上</span></span><br><span class="line"><span class="comment">//@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="comment">//public @interface AnnoBasic &#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanhuojin</span></span><br><span class="line"><span class="comment"> * 对注解中可使用的元素类型示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@interface</span> AnnoElement&#123;</span><br><span class="line">    <span class="comment">//基础类型 ，设定默认值都为0；</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">c</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">d</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String 类型，默认值为空字符串</span></span><br><span class="line">    String <span class="title function_">e</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Class类型,默认值为void.class</span></span><br><span class="line">    Class <span class="title function_">f</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举类型,这里使用ElementType枚举类做示例,默认值为Element.TYPE</span></span><br><span class="line">    ElementType <span class="title function_">g</span><span class="params">()</span> <span class="keyword">default</span> ElementType.TYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解类型，也就是可以使用嵌套注解，使用上面的注解AnnoBasic,默认值为@AnnoBasic</span></span><br><span class="line">    AnnoBasic <span class="title function_">h</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@AnnoBasic</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="type">int</span>[] i() <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意两点：</p>
<ol>
<li><p>在定义默认值时要注意，编译器对注解属性的默认值使用规定非常严格。</p>
<p>首先是任何一个元素的默认值都不能设定为 <code>null</code>，在使用注解时也不能将元素的值指定为null ；其次是任一元素不能有不确定的值，要么在注解的定义中声明元素的默认值，不然就必须要在代码中使用注解时指定该元素的值。对于有些情况我们想让其表示为空时，只能用空自字符串或者是0等其他参数代替。</p>
</li>
<li><p>使用数组作为注解元素时，在使用该注解需要指定多个值时，需要用<code>&#123;&#125;</code>将数值包含起来，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="p2-使用快捷方式指定注解元素的值"><a href="#p2-使用快捷方式指定注解元素的值" class="headerlink" title="p2. 使用快捷方式指定注解元素的值"></a>p2. 使用快捷方式指定注解元素的值</h5><p>在使用注解时，我们要指定注解元素的值，一般来说都是使用 <code>key=value</code> 的方式，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AnnoElement(a=1,b=2)</span></span><br></pre></td></tr></table></figure>

<p>但有的时候我们并不需要指定所有注解元素的值，或者说只有一个注解元素的值需要指定，在注解中提供了一个元素名为 <code>value()</code>的元素，只要在注解的定义中定义了名为 <code>value</code>的元素，我们在使用注解指定该值时就可以直接在括号中填入该值，最明显的一个案例就是 @Target 注解的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//返回注释类型的元素种类的数组</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了元素名为 value() 后，我们在使用时就可以直接填入该值的内容，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-注解的基本使用"><a href="#2-注解的基本使用" class="headerlink" title="2. 注解的基本使用"></a>2. 注解的基本使用</h2><p>在 Java 中，注解的语法格式为： <code>@+注解名</code>，如<code>@Override</code>。</p>
<p>一般来说，注解的使用主要分为以下三类：</p>
<ul>
<li>编写文档。在代码的文档注释里使用 Java 提供的注解，然后使用 javadoc 命令生成doc文档。</li>
<li>编译检查。通过代码里标识的注解能够让编译器实现编译检查，如 【Override】命令检查是否为继承重写的方法。</li>
<li>代码分析。通过代码里标识的注解对代码进行分析，处理。</li>
</ul>
<p>在现代的主流框架中，如Spring ，大量使用了注解来简化代码，那么现在我们就来分析注解具体的一些我们应该学习的地方。</p>
<h3 id="2-1-使用注解编写文档"><a href="#2-1-使用注解编写文档" class="headerlink" title="2.1 使用注解编写文档"></a>2.1 使用注解编写文档</h3><p>使用 Java 时，我们经常会遇到自己不认识的类或者是某个方法我们不知道具体是做什么用的，此时我们都知道可以翻阅 java 的 api 文档查看，如 java8 的文档：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171613324.png"></p>
<p>那么这些文档怎么生成的呢？</p>
<p>其实这些都是使用 javadoc 命令通过解析代码中的文档注释以及相关注解自动生成的网页。</p>
<p>现在我们用一个简单的例子测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解生成 Javadoc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 千帆过烬</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoDocDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两数的和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b4整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 AnnoDocDemo.java 文件所在目录打开命令行窗口，执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc AnnoDocDemo.java</span><br></pre></td></tr></table></figure>

<p>此时在目录下会生成许多网页相关的文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171613752.png"></p>
<p>然后我们打开 index.html 可以看到：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171613857.png"></p>
<p>生成了跟我们的 api 文档一样的样子，而且刚才我们定义的注解都被解析成文档的格式</p>
<p>如<code>@since</code> 表示从何版本开始，方法中的<code>@return</code> 表示对返回值的解释。</p>
<p>当然在文档注释中可以使用的注解不止这些，通过使用这些注解可以帮助 javadoc命令 在生成文档的时候根据注解内容来生成不同的文档内容。也就是说，注解能让 java 程序通过注解得到程序想要的信息。</p>
<h3 id="2-2-JDK-内置的一些注解"><a href="#2-2-JDK-内置的一些注解" class="headerlink" title="2.2 JDK 内置的一些注解"></a>2.2 JDK 内置的一些注解</h3><p>在 JDK 中预置的三个常用注解为：</p>
<ol>
<li><p><code>@Override</code> ：检测该被注解标注的方法是否是继承自父类（接口）的。</p>
<p>源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>@Deprecated</code>：被该注解标注的内容，表示已经过时。</p>
<p>源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>@SuppressWarning</code>：有选择的关闭编译器对类、方法、成员变量、变量初始警告。</p>
<p>源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部的 String 数组接收的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deprecation：使用了不赞成使用的类或方法时的警告；</span><br><span class="line">unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;</span><br><span class="line">fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</span><br><span class="line">path：在类路径、源文件路径等中有不存在的路径时的警告;</span><br><span class="line">serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;</span><br><span class="line">finally：任何 finally 子句不能正常完成时的警告;</span><br><span class="line">all：关于以上所有情况的警告。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用介绍如下：</p>
<h4 id="2-2-1-Override"><a href="#2-2-1-Override" class="headerlink" title="2.2.1 @Override"></a>2.2.1 @Override</h4><p>首先是<code>@Override</code>注解，添加如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. `<span class="doctag">@Override</span>` ：检测该被注解标注的方法是否是继承自父类（接口）的。</span></span><br><span class="line"><span class="comment"> * 2. `<span class="doctag">@Deprecated</span>`：被该注解标注的内容，表示已经过时。</span></span><br><span class="line"><span class="comment"> * 3. `<span class="doctag">@SuppressWarning</span>`：压制（忽略）警告。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoJdk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /<span class="doctag">@Override</span>注解是对代码的一种严谨性检查</span></span><br><span class="line"><span class="comment">     * 在方法上声明该注解能够确保方法是重写自父类的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明了Override注解后，该方法必须在父类中存在</span></span><br><span class="line">    <span class="comment">//所有的类都继承了Object类，toString方法在Object类中，这里不报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会报错</span></span><br><span class="line">    <span class="comment">//声明了@Oerride注解后，该方法必须在父类能够找到，toString1方法在父类中不存在</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171613787.png"></p>
<p>可以看到，编辑器报错，并提示 <code>Method dose not override method from its superclass</code> 也就是该方法不是重写父类的，声明<code>@Override注解</code>会报错。</p>
<h4 id="2-2-2-Deprecated"><a href="#2-2-2-Deprecated" class="headerlink" title="2.2.2 @Deprecated"></a>2.2.2 @Deprecated</h4><p>其次是<code>@Deprecated</code>注解，在刚才的文件中添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /<span class="doctag">@Deprecated</span>注解对方法进行过时标记</span></span><br><span class="line"><span class="comment">     * 被该注解标识的方法在使用时会提示过时，在ide中该方法被画了一条线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//旧的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addnew</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//新的方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时我们如果调用 <code>add（）</code> 方法时，会出现：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171613122.png"></p>
<p>提示我们方法过时，在 Java 的发展中，强大的类库为我们提供了许多的方便，不过有些方法或类久了之后在程序中使用已经不再推荐，如 Java 中的 Data 类z中的许多方法：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171614646.png"></p>
<p>A <a href="#this-is-a-title">link</a> to jump towards target header</p>
<h4 id="2-2-3-SuppressWarning"><a href="#2-2-3-SuppressWarning" class="headerlink" title="2.2.3 @SuppressWarning"></a>2.2.3 @SuppressWarning</h4><p>最后是<code>@SuppressWarning</code>注解，我们在编辑器编写代码时候，如：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171614298.png"></p>
<p>这里每一小点点都是编译器帮我们检查出来的一些可能的问题，编辑器会以一些方式来提醒用户，但是有得时候警告可能很多，而且我们自己其实知道代码并没有什么问题，我们可以使用<code>@SuppressWarning</code>注解来压制警告。</p>
<p><code>@SuppressWarning</code>压制警告的范围和类型由自己决定，比如我想压制整个类的所有警告类型，我在类名上声明注解为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br></pre></td></tr></table></figure>

<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171616812.png"></p>
<p>在类上声明，该注解会作用于整个类的区域，后面的字符串指定你要压制的类型，一般我们使用<code>al</code>即全部类型的警告，其余的属性请翻阅上面的 <a href="#2.2-JDK-%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3">JDK 内置的一些注解</a> （按住Ctrl + 鼠标左键跳转）。</p>
<hr>
<h2 id="3-注解进阶使用"><a href="#3-注解进阶使用" class="headerlink" title="3. 注解进阶使用"></a>3. 注解进阶使用</h2><h3 id="3-1-获取使用注解对象"><a href="#3-1-获取使用注解对象" class="headerlink" title="3.1 获取使用注解对象"></a>3.1 获取使用注解对象</h3><p>在使用自定注解之前，我们先来了解一下如何获取注解中的内容。</p>
<p>根据前面的知识，我们知道注解声明的位置是在类、方法、成员变量….等等之上，如果接触过反射的话，我们知道在程序的运行过程中我们可以通过反射机制获取类中的构造方法、成员方法、成员变量等，而注解也可以看作是类、方法、成员变量中的一部分。</p>
<p>为了在运行时准确的获取到注解的相关信息，Java 在java.lang.reflect 反射包下提供了AnnotatedElement 接口，反射我们使用的基本类如Method类、Constructor类、Field类、Class类和Package类都实现了该接口。</p>
<p>该接口中的方法及功能如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;T extends Annotation&gt; T</code></td>
<td align="center"><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></td>
<td align="center">返回该元素的指定注解类型的注解对象（包括继承自父类的），如找不到该注解类型，则返回 null。</td>
</tr>
<tr>
<td align="center"><code>Annotation[]</code></td>
<td align="center"><code>getAnnotations()</code></td>
<td align="center">返回该元素上所有存在的注解，包括继承至父类的。</td>
</tr>
<tr>
<td align="center"><code>default &lt;T extends Annotation&gt; T</code></td>
<td align="center"><code>getDeclaredAnnotation( Class &lt;T&gt; annotationClass )</code></td>
<td align="center">返回该元素的指定注解类型的注解对象，如找不到该注解类型，则返回 null，忽略继承自父类的注解。</td>
</tr>
<tr>
<td align="center"><code>Annotation[]</code></td>
<td align="center"><code>getDeclaredAnnotations()</code></td>
<td align="center">返回该元素上所有存在的注解，忽略继承至父类的注解。</td>
</tr>
<tr>
<td align="center"><code>default boolean</code></td>
<td align="center"><code>isAnnotationPresent( Class &lt;?  extends Annotation&gt; annotationClass )</code></td>
<td align="center">如果此元素上<em>存在</em>指定类型的注解(包括继承自父类的)，则返回true，否则返回false。  该方法主要用于方便访问标记注解。</td>
</tr>
</tbody></table>
<p>一个简单的使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 注解的简单示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@AH1</span></span><br><span class="line"><span class="meta">@AH2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnnoGetH</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@A1</span></span><br><span class="line"><span class="meta">@A2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoGet</span> <span class="keyword">extends</span> <span class="title class_">AnnoGetH</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//获取AnnoGet类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;cn.annotation.AnnoGet&quot;</span>);</span><br><span class="line">        <span class="comment">//由于我注解都是定义在类上面的</span></span><br><span class="line">        <span class="comment">//下面的注解都要用Class类对象来获取</span></span><br><span class="line">        <span class="comment">//相应的如果定义在方法上则要用方法Method对象获取</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getAnnotation 获取该元素指定注解类型的注解对象,包含继承的----------&quot;</span>);</span><br><span class="line">        <span class="type">A1</span> <span class="variable">a1</span> <span class="operator">=</span> aClass.getAnnotation(A1.class);</span><br><span class="line">         <span class="comment">//获取继承自AnnoGetH类的注解</span></span><br><span class="line">        <span class="type">AH1</span> <span class="variable">ah1</span> <span class="operator">=</span> aClass.getAnnotation(AH1.class);</span><br><span class="line">        System.out.println(a1.toString());</span><br><span class="line">        System.out.println(ah1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getAnnotations 获取该元素所有的注解对象，包含继承----------&quot;</span>);</span><br><span class="line">        Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">        System.out.println(Arrays.toString(annotations));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclearedAnnotation 获取该元素指定注解类型的注解对象，忽略继承的----------&quot;</span>);</span><br><span class="line">        <span class="type">A2</span> <span class="variable">a2</span> <span class="operator">=</span> aClass.getDeclaredAnnotation(A2.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此方法不能获取到继承的注解，否则会抛出异常</span></span><br><span class="line">        System.out.println(a2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------getDeclearedAnnotations 获取该元素所有的注解对象，忽略继承的----------&quot;</span>);</span><br><span class="line">        Annotation[] annotations1 = aClass.getDeclaredAnnotations();</span><br><span class="line">        System.out.println(Arrays.toString(annotations1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------isAnnotationPresent 判断该元素是否存在指定的注解对象，包括继承的----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次判断该元素是否有相应的注解</span></span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(A1.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A1 true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(A2.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A2 true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(AH1.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AH1 true&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(AH2.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AH2 true&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnoH类的注解,可继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> AH1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnoH类的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> AH2&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Anno类的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> A1&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Anno类的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> A2&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----------getAnnotation 获取该元素指定注解类型的注解对象,包含继承的----------</span><br><span class="line">@cn.annotation.A1()</span><br><span class="line">@cn.annotation.AH1()</span><br><span class="line">----------getAnnotations 获取该元素所有的注解对象，包含继承----------</span><br><span class="line">[@cn.annotation.AH1(), @cn.annotation.A1(), @cn.annotation.A2()]</span><br><span class="line">----------getDeclearedAnnotation 获取该元素指定注解类型的注解对象，忽略继承的----------</span><br><span class="line">@cn.annotation.A2()</span><br><span class="line">----------getDeclearedAnnotations 获取该元素所有的注解对象，忽略继承的----------</span><br><span class="line">[@cn.annotation.A1(), @cn.annotation.A2()]</span><br><span class="line">----------isAnnotationPresent 判断该元素是否存在指定的注解对象，包括继承的----------</span><br><span class="line">A1 true</span><br><span class="line">A2 true</span><br><span class="line">AH1 true</span><br></pre></td></tr></table></figure>

<p>要注意一点，虽然getAnnotations 和getAnnotation 都能获取到从父类继承的注解，但是父类的注解必须被声明 @inherited 注解，子类才能获取到该父类的注解。</p>
<h3 id="3-2-自定义注解实现对方法的测试"><a href="#3-2-自定义注解实现对方法的测试" class="headerlink" title="3.2 自定义注解实现对方法的测试"></a>3.2 自定义注解实现对方法的测试</h3><p>了解完注解的基础知识以及如何使用反射获取注解之后，我们通过一个例子自定义注解解决我们的问题。</p>
<p>假设小明写了一个类 Calculator  ，他自信满满的对我说：</p>
<p>小明：“像我这么优秀的人，我写的代码肯定是没有问题的”</p>
<p>我：“自信是好的，但是还是不要轻心，还是测试比较一下比较好的”</p>
<p>小明：“那你想怎么测试，一个个调用很麻烦的，还要一个个分析”</p>
<p>我：“不用，我只要使用注解@QTest就好了，你看我表现吧”</p>
<p>小明编写的类 <strong>Calculator</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 计算器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="meta">@AnnoCheck</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 0 =&quot;</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="meta">@AnnoCheck</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 - 0 =&quot;</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘法</span></span><br><span class="line">    <span class="meta">@AnnoCheck</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mul</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 * 0 =&quot;</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法</span></span><br><span class="line">    <span class="meta">@AnnoCheck</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">div</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 / 0 =&quot;</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啊哈哈，没有BUG&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试使用的注解 <strong>AnnoCheck</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoCheck &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，我使用自己的测试类 CalculatorCheck 就可以测试 Calculator 类中的方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 测试类，对方法测试并生成测试信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取Calculator类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.annotation.Calculator&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个类实例用于运行方法</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">ca</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//计算运行错误的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//打印结果的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//获取该类中的所有方法</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m: methods) &#123;</span><br><span class="line">            <span class="comment">//判断该方法上是否有注解，有则是要测试的方法</span></span><br><span class="line">            <span class="keyword">if</span> (m.isAnnotationPresent(AnnoCheck.class)) &#123;</span><br><span class="line">                <span class="comment">//测试的方法可能会有错误，我们应该捕获异常</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.invoke(ca);</span><br><span class="line">                    strb.append(<span class="string">&quot;方法: &quot;</span> + m.getName() + <span class="string">&quot; 运行成功\n&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    strb.append(<span class="string">&quot;方法: &quot;</span> + m.getName() + <span class="string">&quot; 运行出现异常\n&quot;</span>);</span><br><span class="line">                    strb.append(<span class="string">&quot;异常名为：&quot;</span> + e.getCause().getClass().getSimpleName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    strb.append(<span class="string">&quot;异常的原因：&quot;</span> + e.getCause().getMessage() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        strb.append(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">        strb.append(<span class="string">&quot;发现&quot;</span> + num + <span class="string">&quot;个错误！&quot;</span>);</span><br><span class="line">        System.out.println(strb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">0</span> =<span class="number">1</span></span><br><span class="line"><span class="number">1</span> - <span class="number">0</span> =<span class="number">1</span></span><br><span class="line"><span class="number">1</span> * <span class="number">0</span> =<span class="number">0</span></span><br><span class="line">方法: add 运行成功</span><br><span class="line">方法: sub 运行成功</span><br><span class="line">方法: mul 运行成功</span><br><span class="line">方法: div 运行出现异常</span><br><span class="line">异常名为：ArithmeticException</span><br><span class="line">异常的原因：/ by zero</span><br><span class="line">--------------------</span><br><span class="line">发现<span class="number">1</span>个错误！</span><br></pre></td></tr></table></figure>

<p>可以看到，提示div 方法出现了异常，异常名为 ArithmeticException ，异常原因为除 0 操作。</p>
<p>小明的代码是有问题的，而我也通过注解完成了我的目的。</p>
<p>利用注解 + 反射的结合能帮我们解决平时看起来很复杂的问题，在目前的应用中，注解在各种框架中大放光彩，比如：</p>
<ul>
<li><p>JUnit 测试框架</p>
</li>
<li><p>Android 的 ButterKnife</p>
</li>
<li><p>Spring</p>
<p>…..</p>
</li>
</ul>
<h2 id="4-jdk-8-对注解功能的增强"><a href="#4-jdk-8-对注解功能的增强" class="headerlink" title="4. jdk 8 对注解功能的增强"></a>4. jdk 8 对注解功能的增强</h2><h3 id="4-1-新增元注解-Repeatable"><a href="#4-1-新增元注解-Repeatable" class="headerlink" title="4.1 新增元注解@Repeatable"></a>4.1 新增元注解@Repeatable</h3><p>@Repeatable 注解在Java 8 中加入，它表示的注解可以在同一个位置重复使用。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Role(&quot;USER&quot;)</span></span><br><span class="line"><span class="meta">@Role(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 java8 之前，如果我们要实现一个注解表示多个相同类型但不同的值，我们必须要在注解内部声明数组，比如@Target注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//返回注释类型的元素种类的数组</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在使用时在注解上只能声明一次 Target注解，然后指定多个值形成数组，来表示注解可以在多个地方使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br></pre></td></tr></table></figure>

<p>而Java8又提供了另一种解决方式：使用@Repeatable 注解表明该注解可以在同一元素上重复使用。假设我想使Role 注解可以重复声明在类上，实现这个功能需要两步：</p>
<p>第一步在 Role 注解上加@Repeatable注解，并指定多个重复的Role注解存放的容器，该容器也是一个注解类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Role注解，被允许重复使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repeatable(Roles.class)</span> <span class="comment">//指定该注解可以重复声明，并指定该注解声明后放置的容器注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> Role&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步创建 Role注解的容器Roles注解，在Roles注解中声明一个 Role [] 注解数组存放多个Role注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Role注解的容器，接收相同的Role注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Roles&#123;</span><br><span class="line">    Role[] value();<span class="comment">//数组负责保留多个Role注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以在同一元素上使用Role注解了。</p>
<p>事实上这只是一种语法糖而已，我举个例子，假设我们在Person类上声明了两个相同Role注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Role(&quot;USER&quot;)</span></span><br><span class="line"><span class="meta">@Role(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个 Role 注解会自动合并到 Roles 注解中，相当于这样定义一个Roles注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Roles(&#123;@Role(&quot;USER&quot;,@Role(&quot;ADMIN&quot;))&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而事实是这样定义和上面定义的效果是一样的，上面的定义看起来可能就更直观一点。</p>
<p>为了处理这种重复注解，java8也在 AnnotatedElement 接口中新增了两个方法，用法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法返回值</th>
<th align="center">方法名</th>
<th align="center">方法功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>default &lt;T extends Annotation&gt;T[]</code></td>
<td align="center"><code>getAnnotationsByType( Class&lt;T&gt; annotationClass)</code></td>
<td align="center">返回该元素上指定注解类型，重复使用的注解，包括继承自父类的。</td>
</tr>
<tr>
<td align="center"><code>default &lt;T extends Annotation&gt;T[]</code></td>
<td align="center"><code>getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></td>
<td align="center">返回该元素上指定注解类型，重复使用的注解，不包括继承自父类的。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>对于 getAnnotationsByType 方法，该方法会最先调用 getDeclaredAnnotationsByType 方法寻找当前元素（类，成员变量，成员方法）上是否有指定注解类型而且被重复声明的注解，如有则返回当前元素上定义的指定注解类型的所有注解。</p>
<p>如找不到，并且注解是声明在一个类上，而该注解又是可继承的(使用了@Inherited)，则就去父类寻找是否有指定注解类型重复声明的注解。</p>
<p>两者只能取一，意思是如果你开始获取到子类有指定注解类型的重复注解，那么就不会再去寻找父类是否有该指定类型的重复注解，子类找不到再去寻找父类。</p>
<p>简单的使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明两个重复注解</span></span><br><span class="line"><span class="meta">@Role(&quot;USER&quot;)</span></span><br><span class="line"><span class="meta">@Role(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Child</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;cn.annotation.Person&quot;</span>);</span><br><span class="line">        Role[] annotationsByType = cls.getAnnotationsByType(Role.class);</span><br><span class="line">        <span class="keyword">for</span> (Role r: annotationsByType)&#123;</span><br><span class="line">            System.out.println(r.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明两个重复注解</span></span><br><span class="line"><span class="meta">@Role(&quot;MAN&quot;)</span></span><br><span class="line"><span class="meta">@Role(&quot;Child&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Role注解，允许重复使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//Roles 和 Role 两个注解都要定义为可继承，否则子类无法获取父类的重复注解</span></span><br><span class="line"><span class="meta">@Repeatable(Roles.class)</span> <span class="comment">//声明该注解可重复使用，并指定该注解要放置的容器</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> Role&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Role注解的容器，接收相同的Role注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Roles&#123;</span><br><span class="line">    Role[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cn</span>.annotation.Role(value=USER)</span><br><span class="line"><span class="meta">@cn</span>.annotation.Role(value=ADMIN)</span><br></pre></td></tr></table></figure>

<p>根据上面的说明，子类父类只能获取到其中之一的重复注解，我要获取父类的则必须把子类同名的重复注解注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Role(&quot;USER&quot;)</span></span><br><span class="line"><span class="comment">//@Role(&quot;ADMIN&quot;)</span></span><br></pre></td></tr></table></figure>

<p>此时我们再运行，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cn</span>.annotation.Role(value=MAN)</span><br><span class="line"><span class="meta">@cn</span>.annotation.Role(value=Child)</span><br></pre></td></tr></table></figure>

<p>成功获取到父类的重复注解。</p>
<p>好了，本篇文章结束，谢谢大家阅读。</p>
<h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzcxODYwNjMz">深入理解Java注解类型(@Annotation)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWJsdWUvYXJ0aWNsZS9kZXRhaWxzLzczODI0MDU4">秒懂，Java 注解 （Annotation）你可以这样学<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础加强：JUnit 单元测试</title>
    <url>/2019/08/ccbcf2f0cdaa.html</url>
    <content><![CDATA[<p>作为一个 Java 开发人员，为了编写出优秀的代码，我们要既要懂得在编写时注意各种规范和逻辑，也要懂得如何对代码进行测试。</p>
<p>本篇文章就带领大家体验使用 JUnit 测试框架来对 Java 代码进行测试。</p>
<span id="more"></span>

<h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>在软件行业，测试方法大致分为两大类：</p>
<ol>
<li><p>黑盒测试。</p>
<p>在黑盒测试中，测试人员不考虑程序内部结构和内部特性，不需要写代码。例如我对该程序输入测试后，黑盒测试随后<strong>只检查程序执行之后的输出的结果是否正确，着眼考虑于程序的外部结构</strong>。</p>
</li>
<li><p>白盒测试。</p>
<p>相对于黑盒测试，白盒测试需要测试人员<strong>关注程序内部功能实现的流程</strong>，需要写代码。白盒测试在输入测试后，用户可以看到程序中的内部结构，逻辑，算法…. 等。</p>
</li>
</ol>
<p>可以看到，白盒测试对于测试人员的要求更高，但是相应地，白盒测试能够发现程序的更多细致的问题，所以白盒测试对于开发人员来说是一项不可或缺的技能。</p>
<p>在 Java 中，使用 JUnit 单元测试框架对代码测试就是一种白盒测试的方式，接下来，我们就来一步步开始了解和使用 JUnit 。</p>
<h2 id="1-初步使用-JUnit"><a href="#1-初步使用-JUnit" class="headerlink" title="1. 初步使用 JUnit"></a>1. 初步使用 JUnit</h2><p>对于使用 JUnit 单元测试来说，有以下几个步骤：</p>
<ul>
<li>定义一个测试类</li>
<li>导入 JUnit 测试环境</li>
<li>在测试类中定义一个可以独立运行的测试方法</li>
<li>给方法加 <code>@Test</code> 注解</li>
</ul>
<p>下面我使用一个用例来具体解析如何使用 JUnit 进行测试。</p>
<h3 id="1-1-新建一个测试项目"><a href="#1-1-新建一个测试项目" class="headerlink" title="1.1 新建一个测试项目"></a>1.1 新建一个测试项目</h3><p>打开 IDEA， 点击 File&gt;New&gt;Project，左边选择 Java ，选择好 JDK 的路径 ，点击 Next ，再点击 Next，将项目名命名为<code>JunitTest</code>，然后点击 FINISH ，创建项目。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202202131602241.png"></p>
<p>在<code>src</code> 目录下新建一个名为 junit 的包：鼠标右键单击<code>src</code> 目录，然后点击 New&gt;Package，输入名字为 junit，点击 OK。</p>
<p>最后在 junit 包下新建我们想要测试的 Calculator 类：鼠标右键单击 junit 目录，然后点击 New&gt;Java Class，输入名字为Calculator，点击OK。</p>
<p>此时我们的项目结构如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171617194.png"></p>
<p>然后我们在<code>Calculator</code>类中定义两个方法用作被测试，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> junit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加法操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减法操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">substract</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，项目基本框架建立完成。</p>
<h3 id="1-2-新建测试类"><a href="#1-2-新建测试类" class="headerlink" title="1.2 新建测试类"></a>1.2 新建测试类</h3><p>上面我们已经建好了项目且编写好了被测试类的方法，若要对 Calculator 中的方法进行测试的话，还需要编写一个测试类。</p>
<p>对于开发人员来说，将测试代码和源代码分开是一个好习惯。对于测试类，我们在<code>src</code> 同级目录下新建<code>test</code>文件夹，专门用来放测试代码。接着在 IDEA里还要把这个 test 文件夹要设置成测试文件的根目录，右键选中 <code>Mark Directory As - Test Sources Root</code>。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171618147.png"></p>
<p>建好目录之后，我们在同样在 <code>test</code>  目录下新建一个与要测试的类相同的包 <code>junit</code>。</p>
<p>同时在该包下新建类名为 <code>CalculatorTest</code> 的类。<strong>在编写代码的过程中，将测试类的包名和被测试的包名保持一致是一个好习惯</strong>。</p>
<p>良好的命名往往具有锦上添花的作用。对于测试类的命名，我们推荐使用<code>要测试的类名 + Test</code> 。</p>
<p>此时项目结构如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171617981.png"></p>
<h3 id="1-3-在测试类中新建测试方法"><a href="#1-3-在测试类中新建测试方法" class="headerlink" title="1.3 在测试类中新建测试方法"></a>1.3 在测试类中新建测试方法</h3><p>打开 CalculatorTest 类，在里面输入以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jnnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建计算器对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//调用add方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ca.add(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，我们定义了一个<code>testAdd</code>方法，用于对 Calculator 类中的 add 方法进行测试。</p>
<p>在这个方法中，我们首先是创建了一个计算器 Calculator 对象，然后调用它的 add 方法将 1，3 相加，最后输出相加的结果。</p>
<h3 id="1-4-添加注解独立运行"><a href="#1-4-添加注解独立运行" class="headerlink" title="1.4 添加注解独立运行"></a>1.4 添加注解独立运行</h3><p>但是，这样的方法并不能直接运行。Java 是完全面向对象的，要使用<code>testAdd</code>方法，我们必须先 new 一个对象出来，然后调用该方法，该方法才会被直接执行。</p>
<p>但是 JUnit 测试框架通过注解将该操作简化，我们只需在测试的方法上加上<code>@Test</code> 注解，就可以实现独立运行，下面是加上注解后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jnnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建计算器对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//调用add方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ca.add(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次使用的话，注解会报红，这是没有导入包的原因，我们点击 <code>@Test</code> 注解，按键盘的 Alt+Enter 键：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171618469.png"></p>
<p>选择第一个，然后 IDEA 就会自动加载该包。</p>
<p>加上注解后，我们可以看到在方法左边多了个绿色箭头，这代表该方法可以直接运行。在 <code>main</code> 方法上，左边也有同样的箭头，。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619617.png"></p>
<p>我们点击该箭头运行，出现如下结果：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619070.png"></p>
<p>可以看到，左边显示绿色提示，右边的控制台打印了我们输出的相加结果，表示测试成功。</p>
<p>当测试出现异常时，左边的提示会变成红色。</p>
<p>我们在测试时，都是通过是否出现提示红色来判断测试的程序段是否有问题，这就要求我们的测试代码在编写时要有一定的严谨性。</p>
<p>下面我来介绍增加测试代码严谨性的方法。</p>
<h2 id="2-使用断言"><a href="#2-使用断言" class="headerlink" title="2. 使用断言"></a>2. 使用断言</h2><h3 id="2-1-什么是断言？"><a href="#2-1-什么是断言？" class="headerlink" title="2.1 什么是断言？"></a>2.1 什么是断言？</h3><p>断言就是对你的测试结果确定一个事先的肯定结果。在对这个测试结果做了断言之后，测试结果会与你事先希望的结果比较，结果一样，测试提示为绿色，结果不一样，测试提示为红色。</p>
<h3 id="2-2-为什么使用断言？"><a href="#2-2-为什么使用断言？" class="headerlink" title="2.2 为什么使用断言？"></a>2.2 为什么使用断言？</h3><p>在我们上面的测试中，我们调用<code>Calculator</code> 中的 add 方法，然后输出结果。</p>
<p>但是这样的测试存在很多弊端，也就是只通过结果无法判断程序的逻辑是否正确。</p>
<p>例如，我将<code>Calculator</code> 类中的add方法修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再次运行测试类的 testAdd 方法：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619318.png"></p>
<p>左边提示为绿色，没有发现问题。</p>
<p>我修改 add 方法的代码之后，其逻辑已经出现了问题，但是测试并没有出现问题，<strong>可以看出单纯通过打印输出结果无法判断程序是否正确</strong>。</p>
<h3 id="2-3-开始使用断言"><a href="#2-3-开始使用断言" class="headerlink" title="2.3 开始使用断言"></a>2.3 开始使用断言</h3><p>JUnit 提供了一个类 Assert ，它有许多静态重载方法来定义断言：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619567.png"></p>
<p>修改之前的 testAdd 方法为使用断言的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//1.创建计算器对象</span></span><br><span class="line">      <span class="type">Calculator</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">      <span class="comment">//2.调用add方法</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ca.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="comment">//System.out.println(result);</span></span><br><span class="line">      <span class="comment">//3.使用断言</span></span><br><span class="line">      Assert.assertEquals(<span class="number">3</span>,result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>assertEquals()</code>接收两个值，前者为我们期望的值也就是断言的值，后者时测试的真正结果值，此时我们再次运行测试方法：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619395.png"></p>
<p>可以看到，左边并没有变为绿色，这里没显示红色是我主题的原因。但是我们可以通过右边看到，上面提示 Test failed ，即测试失败。</p>
<p>然后列出了原因 :</p>
<p>Expected ：3           期望为3<br>Actual：-1                实际为-1</p>
<p>此时我们将<code>Calculator</code> 中的 add 方法修改回正常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>运行测试方法，测试成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619166.png"></p>
<h2 id="3-补充内容"><a href="#3-补充内容" class="headerlink" title="3. 补充内容"></a>3. 补充内容</h2><p>使用<code>@Test</code>注解能够将方法设定为独立运行，但是，每次我们运行测试方法时，还是要 new 一个测试类的对象，只是这个操作由 JUnit 帮我们去完成了而已。</p>
<p>在大多数时候，这并不会有太大的影响。然而，对于一些重复类的逻辑，比如 IO操作，我们每一个测试方法都要先获得被测试类的对象才能调用它对应的方法，而这些逻辑基本在每个测试方法都是相同的，这样就会造成代码冗余。</p>
<p>为了减缓这种现象，我们一般会将这些操作都放在一个函数里面，在类被使用时首先就执行，使用结束后释放。</p>
<p>而 JUnit 也提供了这样的功能，通过<code>@Before</code>注解，指定 <strong>该方法在所有测试方法执行之前执行</strong>。</p>
<p>通过 <code>@After</code> 注解，指定 <strong>该方法在所有测试方法之后执行</strong>。</p>
<p>我们来试验一下，修改测试类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jnnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有测试方法之前执行</span></span><br><span class="line"><span class="comment">     * 一般用于数据和资源的初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有测试方法之后执行</span></span><br><span class="line"><span class="comment">     * 一般用于数据和资源的释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建计算器对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//2.调用add方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ca.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//        System.out.println(result);</span></span><br><span class="line">        <span class="comment">//3.使用断言</span></span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们运行测试方法：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171619902.png"></p>
<p>可以看到打印的顺序和我们设想的一样。</p>
<p>JUnit4 利用 JDK5 的新特性 <code>Annotation</code>，使用注解来定义测试规则。<br>以下为几个常用的注解：</p>
<ul>
<li>@Test：把一个方法标记为测试方法</li>
<li>@Before：每一个测试方法执行前自动调用一次</li>
<li>@After：每一个测试方法执行完自动调用一次</li>
<li>@BeforeClass：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰</li>
<li>@AfterClass：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰</li>
<li>@Ignore：暂不执行该测试方法</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtd2VhdmVyX3pob3UvYXJ0aWNsZS9kZXRhaWxzLzc5ODUwMjAy">https://blog.csdn.net/dreamweaver_zhou/article/details/79850202<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JUnit 单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础加强：lambda 表达式之四大函数式接口</title>
    <url>/2022/02/d14522c04f5d.html</url>
    <content><![CDATA[<p><code>Java8</code> 又称 <code>Java 1.8</code> 版本是自 <code>Java 1.5</code> 版本以来最大的一个版本变动，这一次带来了许多的新特性，首当其冲的莫过于 <code>lambda</code> 表达式，为了配合 <code>lambda</code> 表达式的使用，加入了 <code>函数式</code> 接口。</p>
<p>本文通过几个例子，描述 lambda 表达式结合函数式接口的基本使用方式。</p>
<span id="more"></span>

<p><strong>在开始之前，请确定你已经了解并会使用 <code>lambda</code> 表达式</strong></p>
<p>废话不多说，开始！</p>
<h2 id="一、什么是函数式接口"><a href="#一、什么是函数式接口" class="headerlink" title="一、什么是函数式接口"></a>一、什么是函数式接口</h2><p>正如其名，函数式接口其实就是表示为函数方式的接口，虽然是函数式，但依然还是一个接口。<br>这样讲可能有点拗口，通俗点来说，函数式接口就是 <strong>只有一个抽象方法的接口</strong>。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口 <code>Com</code> 可被称作一个函数式接口</p>
<hr>
<h2 id="二、函数式接口的构成"><a href="#二、函数式接口的构成" class="headerlink" title="二、函数式接口的构成"></a>二、函数式接口的构成</h2><p>一个函数式接口通常来说必须满足以下两个必要条件</p>
<ul>
<li>首先，它必须是一个 <strong>标准的接口定义</strong>，不是注解，类，或者枚举。</li>
<li>其次，它的接口体内有且仅有一个 <strong>抽象方法</strong></li>
</ul>
<blockquote>
<p>接口内的方法默认都是 <strong>抽象方法</strong>，没有方法体。虽然 Java 1.8 引入了接口默认方法，其中可以有方法体，但其并不能成为抽象方法。所以，在函数式接口中可以存在多个方法，但 <strong>抽象方法</strong> 必须只有一个。</p>
</blockquote>
<p><strong>FunctionalInterface 注解</strong></p>
<p><strong>@FunctionalInterface</strong> 是 Java 1.8 引入的注解，是为了配合函数式接口、<code>lambda</code> 表达式而设计的，目的是<strong>检查某个接口是否满足函数式接口的定义</strong>。</p>
<p>若在接口上标记该注解，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。</p>
<p>需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。总的来说，这个注解可以帮助我们检查接口定义是否符合函数式接口的规范。</p>
<p><strong>泛型</strong></p>
<p>由于函数式接口的特殊性，通常我们都会给其加上泛型。</p>
<p>所以，标准的函数式接口定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：无默认方法</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runn</span> &lt;T&gt;&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T a)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：有默认方法</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tunn</span> &lt;T&gt;&#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T a)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//无论有多少个默认方法</span></span><br><span class="line">  <span class="comment">//只要满足只有一个抽象方法的接口就是函数式接口</span></span><br><span class="line">   <span class="keyword">default</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">   4<span class="comment">//方法体</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="title function_">to</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">     <span class="comment">//方法体</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、如何使用函数式接口"><a href="#三、如何使用函数式接口" class="headerlink" title="三、如何使用函数式接口"></a>三、如何使用函数式接口</h2><h3 id="3-1-普通方式"><a href="#3-1-普通方式" class="headerlink" title="3.1 普通方式"></a>3.1 普通方式</h3><p>和普通接口一样，函数式接口一样可以通过定义实现类或者匿名内部类的方式进行使用。</p>
<p>定义实现类方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goo</span> <span class="keyword">implements</span> <span class="title class_">Runn</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Goo</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goo</span>();</span><br><span class="line">        go.test(<span class="string">&quot;定义实现类方式实现Runn&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runn&lt;String&gt; runn = <span class="keyword">new</span> <span class="title class_">Runn</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="comment">//必须实现Runn接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">runn.test(<span class="string">&quot;匿名内部类实现Runn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但这些并不是我们的重点，关键看 <code>lambda</code> 表达式是如何使用函数式接口的。</p>
<h3 id="3-2-lambda-表达式方式"><a href="#3-2-lambda-表达式方式" class="headerlink" title="3.2 lambda 表达式方式"></a>3.2 lambda 表达式方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runn&lt;String&gt; runn = (a) -&gt; &#123;System.out.println(a)&#125;;</span><br><span class="line">runn.test(<span class="string">&quot;lambda表达式方式&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，在使用 <code>lambda</code> 表达式之后，整个式子变得非常的简洁。可以说，函数式接口和  <code>lambda</code> 表达式是完全相互融合的。那么，这么简洁的代码是如何执行的呢？又或者说 lambda 表达式的工作又是什么呢？</p>
<p>事实上，lambda 表达式的工作分为 <strong>三个部分</strong>：</p>
<ul>
<li><p>自动实现了等号左边的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runn&lt;String&gt; runn =</span></span><br><span class="line">Runn&lt;String&gt; runn = <span class="keyword">new</span> <span class="title class_">Goo</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将箭头前的参数作为实现的test方法中的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runn&lt;String&gt; runn = (a) -&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String a)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将箭头后的语句作为实现的 test 方法中的方法体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runn&lt;String&gt; runn = (a) -&gt; &#123;System.out.println(a)&#125;;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="四、四大函数式接口"><a href="#四、四大函数式接口" class="headerlink" title="四、四大函数式接口"></a>四、四大函数式接口</h2><p>Java 1.8 引入函数式接口就是为了解决完全面向对象在某些领域内的痛点，而为了让开发者更高效的使用函数式接口，Java 1.8 还在 <code>java.util.function</code> 包下定义了许多内置的函数式接口，其中最常用的莫过于以下四种：</p>
<ul>
<li>Consumer</li>
<li>Supplier</li>
<li>Function</li>
<li>Predicate</li>
</ul>
<h3 id="4-1-Consumer-T-：消费型接口"><a href="#4-1-Consumer-T-：消费型接口" class="headerlink" title="4.1 Consumer &lt; T &gt;：消费型接口"></a>4.1 Consumer &lt; T &gt;：消费型接口</h3><p>消费型接口即指该接口内的唯一抽象方法（<code>void accept(T t)</code> 方法） <strong>只接受输入</strong>(有参数) ，<strong>没有返回值</strong>。<strong>只进不出</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消费型接口，只输入(有参)不输出(无返回值)</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@FunctionalInterface</span></span></span><br><span class="line"><span class="comment">    // 根据给定的参数 t 执行 accept 方法，无返回值.</span></span><br><span class="line"><span class="comment">    // Params：t 输入的参数</span></span><br><span class="line"><span class="comment">    public interface Consumer&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        void accept(T t);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerInterfaceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * lambda表达式方式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda 表达式实际上是自动实现了等号左边的接口</span></span><br><span class="line">    <span class="comment">//然后再将箭头前的参数名作为实现的accept方法中的参数名</span></span><br><span class="line">    <span class="comment">//箭头后的语句作为实现的accept方法中的方法体（&#123;&#125;内的内容为 accept 方法的方法体）</span></span><br><span class="line">    Consumer&lt;String&gt; conn = (t) -&gt; &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    conn.accept(<span class="string">&quot;Consumer 消费型接口&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Consumer 消费型接口</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-Supplier-T-：供给型接口"><a href="#4-2-Supplier-T-：供给型接口" class="headerlink" title="4.2 Supplier &lt; T &gt;：供给型接口"></a>4.2 Supplier &lt; T &gt;：供给型接口</h3><p>供给型接口即指该接口内的唯一抽象方法 <strong>无输入</strong>(无参数) ，<strong>有返回值</strong>。<strong>只出不进</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 供给型接口,只输出(有返回值)不输入(无参)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@FunctionalInterface</span></span></span><br><span class="line"><span class="comment">    public interface Supplier&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        // 获取一个结果.</span></span><br><span class="line"><span class="comment">        T get();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suppierInerfaceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;String&gt; sup = () -&gt; &#123;</span><br><span class="line">         <span class="comment">//方法体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Supplier 供给型接口&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Supplier 供给型接口</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Function-T-R-：函数型接口"><a href="#4-3-Function-T-R-：函数型接口" class="headerlink" title="4.3 Function &lt; T, R &gt; ：函数型接口"></a>4.3 Function &lt; T, R &gt; ：函数型接口</h3><p>函数型接口即指该接口内的唯一抽象方法 <strong>既有输入</strong>(有参数) ，<strong>又有返回值</strong>。<strong>有出有进</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 函数型接口,既输入又输出</span></span><br><span class="line"><span class="comment">  <span class="doctag">@FunctionalInterface</span></span></span><br><span class="line"><span class="comment">  public interface Function&lt;T, R&gt; &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 用给定的参数 t 生成函数.</span></span><br><span class="line"><span class="comment">    // <span class="doctag">@param</span> t 函数的参数</span></span><br><span class="line"><span class="comment">    // <span class="doctag">@return</span> 函数的返回值</span></span><br><span class="line"><span class="comment">    R apply(T t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functionInterfaceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = a -&gt; &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;Function 函数型接口&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Function 函数型接口</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Predicate-T-：断言型接口"><a href="#4-4-Predicate-T-：断言型接口" class="headerlink" title="4.4 Predicate &lt; T &gt;：断言型接口"></a>4.4 Predicate &lt; T &gt;：断言型接口</h3><p>断言型接口即指该接口内的唯一抽象方法 <strong>有输入</strong>(有参数) ，<strong>且返回值必须为布尔值</strong>。<strong>有出有进</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 断言型接口即指该接口内的唯一抽象方法有输入(有参数) ,</span></span><br><span class="line"><span class="comment">* 且返回值必须为布尔值。既出且进。</span></span><br><span class="line"><span class="comment"><span class="doctag">@FunctionalInterface</span></span></span><br><span class="line"><span class="comment">public interface Predicate&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   // 根据给定的参数执行 test 方法</span></span><br><span class="line"><span class="comment">   // <span class="doctag">@param</span> t 输入的参数</span></span><br><span class="line"><span class="comment">   // <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 返回布尔值,</span></span><br><span class="line"><span class="comment">   // otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">   boolean test(T t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">predicateInterfaceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Predicate&lt;String&gt; predicate = (str) -&gt;&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(predicate.test(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate 断言型接口测试&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Predicate 断言型接口测试</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、其他函数式接口"><a href="#五、其他函数式接口" class="headerlink" title="五、其他函数式接口"></a>五、其他函数式接口</h2><p>除了上述 4 种类型的接口外，还有其他的一些接口供我们使用：</p>
<ul>
<li><p>BiFunction &lt; T, U, R &gt;  参数类型有2个，为 T，U，返回值为 R，其中方法为 <code>R apply(T t, U u)</code>。</p>
</li>
<li><p>UnaryOperator &lt; T &gt; (Function子接口) 参数为T，对参数为 T 的对象进行一元操作，并返回 T 类型结果，其中方法为 <code>T apply(T t)</code>。</p>
</li>
<li><p>BinaryOperator &lt; T &gt; (BiFunction子接口) 参数为T，对参数为 T 得对象进行二元操作，并返回 T 类型得结果，其中方法为 <code>T apply（T t1， T t2）</code>。</p>
</li>
<li><p>BiConsumer &lt;T, R&gt; 为 <code>void accept(T t, U u)</code>。</p>
</li>
<li><p>ToIntFunction &lt; T &gt;、ToLongFunction &lt; T &gt;、ToDoubleFunction &lt; T &gt; 参数类型为 T，返回值分别为 int，long，double，分别计算 int，long，double 的函数。</p>
</li>
<li><p>IntFunction &lt; R &gt;、LongFunction &lt; R &gt;、DoubleFunction &lt; R &gt; 参数分别为 int，long，double，返回值为 R。</p>
<p>等等…….</p>
</li>
</ul>
<p>以上就是 Java 8 内置的核心函数式接口，其中包括了大部分的方法类型，可以在使用的时候根据不同的使用场景去选择不同的接口使用。</p>
<h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWFubDU1NTU1L3AvMTM1NTAxMzIuaHRtbA==">Java新特性-四大函数式接口<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>lambda 表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门（一）：概念和发展历史</title>
    <url>/2019/08/dac4986ff492.html</url>
    <content><![CDATA[<p>JavaScript 是世界上最流行的脚本语言。作为 Web 开发者，学习 JavaScript 是我们必须经历的一个环节，这个系列是作者在入门 JavaScript 中学习记下的一些笔记，作为以后复习的参考。</p>
<p>首先，学习 JavaScript 之前，我们来聊聊它的前世今生。</p>
<span id="more"></span>

<h2 id="一、什么是-JavaScript"><a href="#一、什么是-JavaScript" class="headerlink" title="一、什么是 JavaScript"></a>一、什么是 JavaScript</h2><p>概念：JavaScript 是一门客户端脚本语言，也是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于 HTML5 的手机App，交互逻辑都是由 JavaScript 驱动的。</p>
<p>简单来说，JavaScript 是一种运行在浏览器中的解释型的编程语言。</p>
<ul>
<li>客户端：直接运行在客户端浏览器中，每一个浏览器都有 JavaScript 的解析引擎。</li>
<li>脚本语言：代码写好之后不需要编译，可以直接通过浏览器解析引擎解析执行。</li>
</ul>
<p>功能：</p>
<ul>
<li>用来增强用户和 HTML 页面的交互过程，控制 HTML 元素，实现页面的一些动态效果</li>
</ul>
<p>在浏览器的发展中，JavaScript 是唯一一种能跨平台、跨浏览器驱动网页，与用户交互的语言。作为和 Web 打交道的我们，JavaScript 是我们必须掌握的一门语言。</p>
<h2 id="二、JavaScript-的历史"><a href="#二、JavaScript-的历史" class="headerlink" title="二、JavaScript 的历史"></a>二、JavaScript 的历史</h2><h3 id="1-令人捉急网速带来的问题"><a href="#1-令人捉急网速带来的问题" class="headerlink" title="1.令人捉急网速带来的问题"></a>1.令人捉急网速带来的问题</h3><p>上世纪90年代，互联网发展的才刚刚起步，网络的传输速度非常的缓慢，人们再网络上进行交流产生的延迟也是巨大的。</p>
<p>以当时最火的 bbs 论坛为例，用户在使用 bbs 之前必须注册账号。很明显在注册账号时要检查账号的合法性，比如账号中是否有特殊字符，空白…..等，而当时的浏览器并不具备任何逻辑能力，所有的逻辑判断都需要服务器要帮助完成。</p>
<p>在当时令人捉急的网速条件下，每次浏览器与服务器交互花费大量的时间，这样大大降低了用户的体验。</p>
<p>这时有人就想，能不能做出一门浏览器专用的语言，可以对用户的输入内容进行校验，这样就可以大大减少出错的次数，提高用户体验感。</p>
<h3 id="2-三个客户端脚本语言的分足鼎立"><a href="#2-三个客户端脚本语言的分足鼎立" class="headerlink" title="2. 三个客户端脚本语言的分足鼎立"></a>2. 三个客户端脚本语言的分足鼎立</h3><p><strong>1992年</strong>，Nombase 公司，开发出了第一门客户端脚本语言，专门用于浏览器内表单内容的校验。并命名为 C–，想蹭一下当时热门语言 C++ 的热度，但是没有流行起来，后来又命名为 ScriptEase 逐步发展。</p>
<p>虽然这门语言没有如愿发展，但是其提出的在浏览器客户端对表单校验的设计思想被一家公司发现其具有强大的潜力。这家公司就是 **网景(Netscape)**。</p>
<p>在当时，网景公司凭借其 Navigator 浏览器的大热成为互联网的第一代浏览器霸主。</p>
<p><strong>1995年</strong>，网景公司按照 C– 的设计思想开发了一门客户端脚本语言，支持更多的功能，并将其命名为：LiveScript。但是为了不像 C– 一样过的那么惨，而当时 SUN 公司开发的 Java 语言出世，为了乘上 Java 发展的东风，于是将 LiveScript 改名为现在我们见到的 JavaScript ，而我们现在来看，这个命名是多么的明智。</p>
<p><span style="color:red">但是注意：很多人会误以为 JavaScript 和 Java 有很大的关系，其实不然，除了一些语法上的近似，它们俩基本没啥关系。</span></p>
<p><strong>1996年</strong>，微软公司推出了自己的浏览器 IE，为了让自己的浏览器更有竞争力且不和网景公司产生命名专利纠纷，它们抄袭 JavaScript 也推出了客户端脚本语言并将其命名为 JScript，并将其内置在IE浏览器中 ，而事实上 JScript和 JavaScript 基本上没有多大差别，后来 IE 也成功如愿大卖。</p>
<p>但是这样对开发者来说就非常不友好，它们开发 Web 时需要考虑多种客户端脚本语言，极大的降低了开发效率。</p>
<p>而虽然看起来巨硬 (MicroSoft) 抄袭的行径非常的不地道，但是 JSript 的出现也成功搅乱了JavaScript的发展，也突出了其设计的一个缺陷：没有一个标准的语法或特性。为了 JavaScript 语言发展的良性，标准化的工作势在必行。</p>
<h3 id="3-ECMA-标准化的指定"><a href="#3-ECMA-标准化的指定" class="headerlink" title="3. ECMA 标准化的指定"></a>3. ECMA 标准化的指定</h3><p>为了解决这个问题，<strong>ECMA（European Computer Manufacturers Association）欧洲计算机制造协会</strong> 和几个公司基于 JavaScript1.1 版本的草案定制了浏览器脚本语言的标准，且将其命名为 <strong>ECMAScript</strong>。</p>
<p>于是，简单来说，ECMAScript 是一种脚本语言标准，而 JavaScript 是网景公司对这个标准的一个实现。</p>
<p>由于其余的两种浏览器脚本语言现在已经不再提起，只有 JavaScript 活到了现在，所以在大多数时候，如果你遇到 ECMAScript 这个词，我们可以简单把它替换为 JavaScript 也行。</p>
<h3 id="4-现代的-JavaScript"><a href="#4-现代的-JavaScript" class="headerlink" title="4. 现代的 JavaScript"></a>4. 现代的 JavaScript</h3><p>现代的 JavaScript 语言组成基本有以下三部分：</p>
<p><strong>JavaScript &#x3D; ECMAScript(标准&amp;&amp;核心) + DOM(文档对象模型) + BOM(浏览器对象模型)</strong></p>
<p>其中 BOM，DOM 部分具有 JavaScript 独有的一些特性。<strong>所以严格来说， JavaScript 并不等于 ECMAScript</strong>。请大家注意这个点。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门（四）：基本对象</title>
    <url>/2019/08/397dcc1cc20e.html</url>
    <content><![CDATA[<p>在 JavaScript 中，提供了许多的内置对象来方便我们更高效的编写代码，今天我们就来介绍一下它们的使用方法。</p>
<span id="more"></span>

<h2 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h2><h3 id="1-Array-数组对象"><a href="#1-Array-数组对象" class="headerlink" title="1. Array 数组对象"></a>1. Array 数组对象</h3><p>Array 对象用于在单个的变量中存储多个值，也称数组。</p>
<h4 id="1-1-创建方式-访问元素方式"><a href="#1-1-创建方式-访问元素方式" class="headerlink" title="1.1 创建方式&amp;访问元素方式"></a>1.1 创建方式&amp;访问元素方式</h4><p>在 JavaScript 中，创建一个个数组主要有四种方式</p>
<ol>
<li><p>使用 new 关键字创建一个 Array 对象来创建一个空的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 new 关键字创建一个 Array 对象来创建一个数组，同时传入元素列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 new 关键字创建一个 Array 对象来创建一个数组，同时传入默认长度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接定义元素列表创建数组（<strong>推荐使用</strong>）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>访问数组元素的方式和其他语言没有什么区别，使用 <code>数组名[下标]</code>访问，当然下标也是从 0 开始的：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr4[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr4[<span class="number">1</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr4[<span class="number">2</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr4[<span class="number">3</span>] + <span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-数组的特性"><a href="#1-2-数组的特性" class="headerlink" title="1.2  数组的特性"></a>1.2  数组的特性</h4><ol>
<li><p>在 JavaScript 中，数组 Array 中的数据类型是可变的。</p>
<p>在 Java 中，数组在创建之时必须指定存储的数据类型，指定后该数组只能存储该类型的数据，如定义一个存储整型数据且大小为 10的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//该数组只能存储int类型数据</span></span><br></pre></td></tr></table></figure>

<p><strong>在 JavaScript 中，数组中的每个元素都可以看作一个变量，由于 JavaScript 中的变量可以随意变换数据类型，所以， JavaScript 中数组内的数据类型并不局限于一种，而且类型可变。</strong></p>
<p><strong>你可以在数组中保存对象，也可以在数组中保存函数，甚至可以在数组中保存数组。</strong></p>
<p>如定义一个包含 number，string，boolean 类型的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr5 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>,<span class="string">&quot;10&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 JavaScript 中，数组 Array 的长度是可变的。</p>
<p>在 Java 中，数组的大小是固定的，如果访问数组元素的下标超过范围时会报异常。</p>
<p>而在 JavaScript 中，数组的大小是<strong>可以变化的</strong>，访问数组元素下标超过范围时也不会报异常。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">04.数组长度可变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义两个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr6 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">66</span>,<span class="number">99</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6[<span class="number">1</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//可以直接访问第12个元素，但是由于该元素未指定值，所以打印为 undefined</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6[<span class="number">11</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//未赋值时长度不变,不包括该元素，输出2</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6.<span class="property">length</span> + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定值后打印真实值</span></span><br><span class="line">arr6[<span class="number">11</span>] = <span class="number">999</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6[<span class="number">11</span>] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//此时的数组长度length也变为12</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr6.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">66</span>,<span class="number">99</span>,<span class="literal">undefined</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong> 在直接访问超过范围的数组元素时，如该元素未赋值，此时数组的长度不变。</p>
<h4 id="1-3-数组的属性"><a href="#1-3-数组的属性" class="headerlink" title="1.3 数组的属性"></a>1.3 数组的属性</h4><ol>
<li><p>length</p>
<p>功能：获取数组的长度。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">length</span></span><br></pre></td></tr></table></figure>

<p>给数组添加新元素时， length 的值会自动更新。</p>
<p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，但它们的值为 undefined。</p>
</li>
</ol>
<h4 id="1-4-数组的常用方法"><a href="#1-4-数组的常用方法" class="headerlink" title="1.4 数组的常用方法"></a>1.4 数组的常用方法</h4><ol>
<li><p>join() 方法。把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔，并返回该字符串。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">join</span>(separator);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">separator</td>
<td align="left">可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//join()方法，把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔，返回该字符串。</span></span><br><span class="line"><span class="keyword">var</span> arr7 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line"><span class="comment">//不指定参数，默认分隔符为&quot;,&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7.<span class="title function_">join</span>() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//可以指定多种类型的参数作为分隔符</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7.<span class="title function_">join</span>(<span class="number">0</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7.<span class="title function_">join</span>(<span class="string">&quot;&gt;&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7.<span class="title function_">join</span>(<span class="literal">null</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span></span><br><span class="line"><span class="number">2040608010</span></span><br><span class="line"><span class="number">2</span>&gt;<span class="number">4</span>&gt;<span class="number">6</span>&gt;<span class="number">8</span>&gt;<span class="number">10</span></span><br><span class="line">2null4null6null8null10</span><br></pre></td></tr></table></figure>
</li>
<li><p>push() 方法。向数组的末尾添加一个或更多元素，并返回新的数组长度。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(element1,element2.....);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.push()方法，向数组的末尾添加一个或多个元素，并返回新的长度。</span></span><br><span class="line"><span class="keyword">var</span> arr7 = [<span class="string">&quot;p&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;h&quot;</span>];</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//可同时添加多个元素,返回添加元素后数组的长度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7.<span class="title function_">push</span>(<span class="string">&quot;p&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr7);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p,u,s,h</span><br><span class="line"><span class="number">7</span></span><br><span class="line">p,u,s,h,p,o,p</span><br></pre></td></tr></table></figure>

<p>若想了解 Array 中的方法的更多用法，请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9hcnJheS5hc3A=">W3C-Array 对象方法<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面的分析，我们大致可以看出 JavaScript 中 Array 数组对象的一些特点：</p>
<ul>
<li>可变大小，可存储多种元素类型。</li>
<li>拥有许多包装函数供使用。</li>
<li>和 Java 中的 ArrayList 很类似。</li>
</ul>
<hr>
<h3 id="2-Data-日期对象"><a href="#2-Data-日期对象" class="headerlink" title="2. Data 日期对象"></a>2. Data 日期对象</h3><p>Date 对象用于处理日期和时间。</p>
<h4 id="2-1-创建方式"><a href="#2-1-创建方式" class="headerlink" title="2.1 创建方式"></a>2.1 创建方式</h4><p>使用 new 关键字创建 Date 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-相关方法"><a href="#2-2-相关方法" class="headerlink" title="2.2 相关方法"></a>2.2 相关方法</h4><ol>
<li><p>toLocaleString()。返回当前 Date 对象对应的时间本地字符串格式。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">date.<span class="title function_">toLocalString</span>()</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//toLocaleString()方法，返回当前date对象对应的时间本地字符串格式</span></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(date1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(date1.<span class="title function_">toLocaleString</span>());</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Fri</span> <span class="title class_">Aug</span> <span class="number">23</span> <span class="number">2019</span> <span class="number">16</span>:<span class="number">32</span>:<span class="number">04</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line"><span class="number">2019</span>/<span class="number">8</span>/<span class="number">23</span> 下午<span class="number">4</span>:<span class="number">32</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getTime()。返回当前时间距离 1970年1月1日0点 的毫秒数</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">date.<span class="title function_">getTime</span>()</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.getTime()方法，返回当前时间距离1970年1月1日0点的毫秒数。</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(date2.<span class="title function_">getTime</span>() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1566549929455</span></span><br></pre></td></tr></table></figure>

<p>想了解 Date 中更多方法的用法，请移步<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9kYXRlLmFzcA==">W3C-Date 对象方法<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<hr>
<h3 id="3-Math-数学对象"><a href="#3-Math-数学对象" class="headerlink" title="3. Math 数学对象"></a>3. Math 数学对象</h3><p>Math 对象用于执行数学任务。</p>
<h4 id="3-1-创建方式"><a href="#3-1-创建方式" class="headerlink" title="3.1 创建方式"></a>3.1 创建方式</h4><p>和 Java 一样，JavaScript 中的 Math 对象使用时并不需要创建对象实例。当我们需要使用它的方法时，直接使用<code>Math.方法名</code>调用即可使用。</p>
<p>如调用一个生成随机数的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h4><p>通过使用<code>Math.属性名</code>可以获取Math对象的相关属性</p>
<p>在Math对象中，拥有的属性列表如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>E</code></td>
<td align="left">返回算术常量 e，即自然对数的底数（约等于2.718）。</td>
</tr>
<tr>
<td align="left"><code>LN2</code></td>
<td align="left">返回 2 的自然对数（约等于0.693）。</td>
</tr>
<tr>
<td align="left"><code>LN10</code></td>
<td align="left">返回 10 的自然对数（约等于2.302）。</td>
</tr>
<tr>
<td align="left"><code>LOG2E</code></td>
<td align="left">返回以 2 为底的 e 的对数（约等于 1.414）。</td>
</tr>
<tr>
<td align="left"><code>LOG10E</code></td>
<td align="left">返回以 10 为底的 e 的对数（约等于0.434）。</td>
</tr>
<tr>
<td align="left"><code>PI</code></td>
<td align="left">返回圆周率（约等于3.14159）。</td>
</tr>
<tr>
<td align="left"><code>SQRT1_2</code></td>
<td align="left">返回返回 2 的平方根的倒数（约等于 0.707）。</td>
</tr>
<tr>
<td align="left"><code>SQRT2</code></td>
<td align="left">返回 2 的平方根（约等于 1.414）。</td>
</tr>
</tbody></table>
<p>表格上对于功能的描述已经很清楚了，这里不再赘述。</p>
<h4 id="3-3-常用工具方法"><a href="#3-3-常用工具方法" class="headerlink" title="3.3 常用工具方法"></a>3.3 常用工具方法</h4><ol>
<li><p>random()。返回一个 0 ~ 1 之间的随机数，含  0 不含 1。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br></pre></td></tr></table></figure>

<p>例：生成并输出一个 0 ~ 10  之间的随机数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">10</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ceil()。向上取整计算，返回大于或等于函数参数，并且与之最接近的一个整数。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(x);<span class="comment">//x为一个数值</span></span><br></pre></td></tr></table></figure>

<p>例：获取大于 3.3 且与之最接近的整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">3.3</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>floor()。向下取整运算，返回小于或等于函数参数，并且与之最接近的一个整数。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(x)；<span class="comment">//x为一个数值</span></span><br></pre></td></tr></table></figure>

<p>例：获取小于 <code>5.3</code> 且与之最接近的整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">5.3</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>round()。四舍五入取整运算。返回函数参数经过四舍五入运算后的整数值。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(x);<span class="comment">//x为一个数值、</span></span><br></pre></td></tr></table></figure>

<p>例：获取小于 5.3 且与之最接近的整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">7.3</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若想了解 Math 中的更多方法的用法，请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9tYXRoLmFzcA==">W3C-Math 对象方法<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h4 id="3-4-Math-对象小练习"><a href="#3-4-Math-对象小练习" class="headerlink" title="3.4 Math 对象小练习"></a>3.4 Math 对象小练习</h4><p>接触了 Math 对象的取整方法，我们做个小练习实现 1-100（不包括100）内的随机整数。</p>
<p>下面是我的分析步骤加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">03.小测验，输出1-100（不包括100）内的随机整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.使用random()方法获取 0 ~ 99.9999... 的随机数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line"><span class="comment">//2.使用ceil()方法向上取整，去除小数，得到0 ~ 99（包括） 的整数。</span></span><br><span class="line">num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(num);</span><br><span class="line"><span class="comment">//3.对结果加 1 ，得到 1 ~ 99（包括99）</span></span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-RegExp-正则表达式对象"><a href="#4-RegExp-正则表达式对象" class="headerlink" title="4. RegExp 正则表达式对象"></a>4. RegExp 正则表达式对象</h3><h4 id="4-1-什么是正则表达式"><a href="#4-1-什么是正则表达式" class="headerlink" title="4.1 什么是正则表达式"></a>4.1 什么是正则表达式</h4><p>正则表达式是一种定义字符串组成规则的一种表达式，通过正则表达式，我们可以约束字符串的组成规则，也可以从字符串中按照特定的规则取出数据。</p>
<h4 id="4-2-正则表达式字符"><a href="#4-2-正则表达式字符" class="headerlink" title="4.2 正则表达式字符"></a>4.2 正则表达式字符</h4><h5 id="4-2-1-开始结束符号"><a href="#4-2-1-开始结束符号" class="headerlink" title="4.2.1 开始结束符号"></a>4.2.1 开始结束符号</h5><p><strong>^：</strong> 负责规定匹配的字符串必须以该字符后的字符串内容为开始。</p>
<p>如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101712606.png" alt="4.2.1-01"></p>
<p>可以看到，即使是字符串中间仅有一个空格，也不匹配。</p>
<p><strong>$：</strong> $ 字符负责规定匹配的字符串必须以该字符前的字符串内容为结束。</p>
<p>如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101713558.png" alt="4.2.1-01"></p>
<p>可以看到，我在字符串末尾多加一个字符A，该字符串就不能匹配，当然空格也一样不行，因为空格也是一个字符。</p>
<p><strong>当^ ,$ 结合时：</strong> 规定匹配的字符串必须是 ^ 和 $ 之间的内容。</p>
<p>如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101713823.png" alt="4.2.1-01"></p>
<hr>
<h5 id="4-2-2-单个字符"><a href="#4-2-2-单个字符" class="headerlink" title="4.2.2 单个字符"></a>4.2.2 单个字符</h5><p>使用<code>[]</code>代表匹配单个字符，可以在其中使用 <code>-</code> 匹配范围，如：</p>
<ul>
<li>匹配字母 <code>a</code> 字符：[a]</li>
<li>匹配一个小写字母字符：[a-z]</li>
<li>匹配一个大写字母字符：[A-Z]</li>
<li>匹配一个数字字符字符：[0-9]</li>
<li>匹配一个小写字母或者大写字母或者数字或者下划线：[0-9A-Za-z_]</li>
</ul>
<p>很明显，当匹配字符的类型多了，这样的写法很复杂。在正则表达式中，规定了一些特殊符号代表特殊含义的单个字符：</p>
<p><strong>\d：</strong>单个数字字符[0-9]</p>
<p><strong>\w：</strong>单个单词字符[a-zA-Z0-9_]</p>
<hr>
<h5 id="4-2-3-量词符号"><a href="#4-2-3-量词符号" class="headerlink" title="4.2.3 量词符号"></a>4.2.3 量词符号</h5><p><strong>?：</strong> 表示出现0次或1次</p>
<p>*<strong>：</strong> 表示出现0次或多次</p>
<p><strong>+：</strong> 表示出现1次或多次</p>
<p><strong>{m,n}：</strong> 表示 m&lt;&#x3D;出现的次数&lt;&#x3D;n</p>
<ul>
<li>m 如果缺省：{,n} 表示最多n次</li>
<li>n 如果缺省：{m,} 表示最少m次</li>
</ul>
<h4 id="4-3-JavaScript中的正则表达式"><a href="#4-3-JavaScript中的正则表达式" class="headerlink" title="4.3 JavaScript中的正则表达式"></a>4.3 JavaScript中的正则表达式</h4><h5 id="4-3-1-创建方式"><a href="#4-3-1-创建方式" class="headerlink" title="4.3.1 创建方式"></a>4.3.1 创建方式</h5><p>在 JavaScript 中，有两种方式创建一个正则表达式：</p>
<ol>
<li><p>使用 new 关键字新建 RegExp 对象创建（不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式内容&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>/</code>符号包含字符串创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式内容/</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="4-3-2-相关方法"><a href="#4-3-2-相关方法" class="headerlink" title="4.3.2 相关方法"></a>4.3.2 相关方法</h5><ol>
<li><p>test()。验证指定的字符串是否符合正则定义的规范，返回一个boolean值。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reg.<span class="title function_">test</span>(<span class="title class_">String</span>);<span class="comment">//String 为需要验证的字符串</span></span><br></pre></td></tr></table></figure>

<p>例：匹配字符串中是否符合正则表达式<code>^abc</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^abc/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br></pre></td></tr></table></figure>

<p>由于字符串开头为abc，返回的结果为 <code>true</code></p>
</li>
<li><p>exec()。寻找指定的字符串是否存在符合正则定义的规范的文本，返回寻找到的文本。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reg.<span class="title function_">exec</span>(<span class="title class_">String</span>);<span class="comment">//String 为待被寻找的字符串</span></span><br></pre></td></tr></table></figure>

<p>寻找字符串中是否有<code>app</code>字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/app/</span>;</span><br><span class="line">reg.<span class="title function_">exec</span>(str);</span><br></pre></td></tr></table></figure>

<p>由于字符串中存在<code>app</code>字符串，返回的结果为字符串 <code>app</code></p>
</li>
</ol>
<p>想了解 JavaScrip t中 RegExp 正则表达式中的更多方法的用法，请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9yZWdleHAuYXNw">W3C-RegExp 对象方法<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<h2 id="全局对象-全局方法"><a href="#全局对象-全局方法" class="headerlink" title="全局对象&amp;全局方法"></a>全局对象&amp;全局方法</h2><p>全局对象是已经预定义好的对象，作为 JavaScript 的全局函数和全局属性的占位符。</p>
<p>通过使用全局对象，可以访问所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。</p>
<p>在 JavaScript 中，Global 全局对象其实就是一些方法和属性的集合，这些方法和属性的调用只需要直接书写名字即可。</p>
<h3 id="5-1-编解码"><a href="#5-1-编解码" class="headerlink" title="5.1 编解码"></a>5.1 编解码</h3><p>在浏览器的数据传输中，为了让数据在传输的时候更稳定和高效，数据在传输时会被编码，接收时会被解码，在默认情况下，数据提交时在服务器上编码。但是有时候我们会需要自己手动编码一次。</p>
<ol>
<li><p>encodeURI()。将一段字符串编码为 UTF-8 格式，编码的字符有一定的规则，并返回编码后的字符串。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="title class_">String</span>);<span class="comment">//String 为待编码的字符串</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> code_eu1 = <span class="string">&quot;千帆过烬&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="built_in">encodeURI</span>(code_eu1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//编码部分重要的字符，有些字符不被编码，如 &quot;?&quot;&quot; 和 &quot;:&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> code_eu2 = <span class="string">&quot;http://baidu.com/wd?千帆过烬&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="built_in">encodeURI</span>(code_eu2) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC</span></span><br><span class="line"><span class="comment">http://baidu.com/wd?%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如注释中所提到的，encodeURI() 可以实现对字符串的编码，编码的字符有一定规定，如链接中的<code>：</code> 和 <code>？</code>都没有被编码。这也是经常使用的编码方式，可以让我们清楚的看出地址信息。</p>
</li>
<li><p>decodeURI()。相反地，decodeURI() 就是用来解码被 encodeURI() 编码后的字符串。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="title class_">String</span>);<span class="comment">//String 为待解码的字符串</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> code_du1 = <span class="built_in">decodeURI</span>(<span class="string">&quot;%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_du1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//解码时也不对 &quot;?&quot; 和 &quot;:&quot; 进行操作</span></span><br><span class="line">    <span class="keyword">var</span> code_du2 = <span class="built_in">decodeURI</span>(<span class="string">&quot;http://baidu.com/wd?%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_du2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">千帆过烬</span></span><br><span class="line"><span class="comment">http://baidu.com/wd?千帆过烬</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-2-编解码更多字符"><a href="#5-2-编解码更多字符" class="headerlink" title="5.2 编解码更多字符"></a>5.2 编解码更多字符</h3><p>在上面的 encodeURI() 编解码方法之中，<code>?</code> 和 <code>:</code> 字符是不被编码的，为了也编解码这些字符，引入了以下两个方法：</p>
<ol>
<li>encodeURIComponent()。</li>
<li>decodeURIComponent()。</li>
</ol>
<p>这两个方法的用法和上面的方法一样，只是编解码的字符多一点而已，不过要记得使用什么方法编码，就要使用对应的方法解码，避免出现乱码的情况：</p>
<p>看例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1.encodeURIComponent 编码</span></span><br><span class="line">    <span class="keyword">var</span> code_euc1 = <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;千帆过烬&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_euc1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//编码更多字符，编码URI组件，将URI之间的分隔符如 &quot;?&quot;&quot; 和 &quot;:&quot;&quot; 编码</span></span><br><span class="line">    <span class="keyword">var</span> code_euc2 = <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;http://baidu.com/wd?千帆过烬&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_euc2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. encodeURIComponent 解码</span></span><br><span class="line">    <span class="keyword">var</span> code_duc1 = <span class="built_in">decodeURIComponent</span>(code_euc1);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_duc1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//解码对 &quot;?&quot; 和 &quot;:&quot; 也进行操作</span></span><br><span class="line">    <span class="keyword">var</span> code_duc2 = <span class="built_in">decodeURIComponent</span>(code_euc2);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(code_duc2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC</span></span><br><span class="line"><span class="comment">http%3A%2F%2Fbaidu.com%2Fwd%3F%E5%8D%83%E5%B8%86%E8%BF%87%E7%83%AC</span></span><br><span class="line"><span class="comment">千帆过烬</span></span><br><span class="line"><span class="comment">http://baidu.com/wd?千帆过烬</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-3-字符串转数字"><a href="#5-3-字符串转数字" class="headerlink" title="5.3 字符串转数字"></a>5.3 字符串转数字</h3><ol>
<li><p>parseInt() 。解析一个字符串的数字内容，返回该数字内容。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>,radix);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">必需。要被解析的字符串。</td>
</tr>
<tr>
<td align="left">radix</td>
<td align="left">可选。表示以什么进制来解析。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 进制为基数字来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</td>
</tr>
</tbody></table>
<p>说明：parseInt() 方法会从左到右解析字符串，如果字符串第一个为数字，则返回数字内容，如 <code>parse(123abc)</code>返回<code>123</code> ，如果字符串第一个不为数字，则返回 NaN，如<code>parseInt(abc123)</code> 返回 NaN。</p>
</li>
</ol>
<h3 id="5-4-判定一个值是否为NaN"><a href="#5-4-判定一个值是否为NaN" class="headerlink" title="5.4 判定一个值是否为NaN"></a>5.4 判定一个值是否为NaN</h3><ol>
<li><p>isNaN()。判断一个值的内容是否为NaN。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(x);<span class="comment">//x为待检测的值</span></span><br></pre></td></tr></table></figure>

<p>说明：NaN 在与任意值（包括其自身）进行<code>==</code> 比较时，都只会返回 false，所以我们不能通过<code>x==NaN</code>判断一个值是否为NaN，于是引入了 isNaN() 方法来对数值是否为 NaN 进行判断。</p>
</li>
</ol>
<h3 id="5-5-计算某个字符串，并执行其中的的-JavaScript-代码。"><a href="#5-5-计算某个字符串，并执行其中的的-JavaScript-代码。" class="headerlink" title="5.5  计算某个字符串，并执行其中的的 JavaScript 代码。"></a>5.5  计算某个字符串，并执行其中的的 JavaScript 代码。</h3><ol>
<li><p>exval()。计算某个字符串，并执行其中的的 JavaScript 代码（用的较少）。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(string);<span class="comment">//string为含有要计算或执行的JavaScript语句字符串</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;x=10;y=20;document.write(x*y + &#x27;&lt;br/&gt;&#x27;)&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="built_in">eval</span>(<span class="string">&quot;2+2&quot;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>想了解JavaScript中Global全局对象中的更多方法的用法，请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9nbG9iYWwuYXNw">W3C-Global<i class="fa fa-external-link-alt"></i></span> 。</p>
</li>
</ol>
<hr>
<h2 id="Function函数对象"><a href="#Function函数对象" class="headerlink" title="Function函数对象"></a>Function函数对象</h2><p>Function 对象在 JavaScript 中用于描述一个函数（方法）。</p>
<p>在 Java 中，方法（函数）存在于类中，创建对象后是对象的一部分。而在 JavaScript 中，函数就是一个对象。</p>
<h3 id="6-1-函数的创建方式-调用"><a href="#6-1-函数的创建方式-调用" class="headerlink" title="6.1 函数的创建方式&amp;调用"></a>6.1 函数的创建方式&amp;调用</h3><p>在 JavaScript 中，创建一个函数一共有三种方式：</p>
<ol>
<li><p>new 一个 Function 对象，传入形式参数列表和函数体(不推荐)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun_new = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;alert(a)&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>function 函数名称(参数列表){ 函数体  }</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun_name</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>var 函数名 &#x3D; function(参数列表){ 函数体 }</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun_name2 = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>要使用某个函数其实也很简单，和其他语言没有多大区别，使用 <code>方法名(参数列表)</code>调用即可。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个加法的方法</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法，执行对 1 和 3 相加</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果为4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2-函数的特点"><a href="#6-2-函数的特点" class="headerlink" title="6.2 函数的特点"></a>6.2 函数的特点</h3><ol>
<li><p>JavaScript 中函数定义时参数不使用 var 关键字，返回值也不需要声明。</p>
<p>在 Java 中，我们定义一个方式时如果需要参数，那么在定义参数时必须指定数据类型，而且必须指定函数的返回值，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toLearn</span><span class="params">(String name, String age)</span>&#123;<span class="comment">//参数必须使用数据类型关键字定义</span></span><br><span class="line">4<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是在 JavaScript 中，由于其弱类型语言的特性，在定义函数参数时，可以不使用 var 关键字修饰，如果你加了var 还会报错，函数返回值也不用声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用 var,只使用参数名即可，函数也不必声明返回值，直接使用 return 返回需要返回的值即可</span></span><br><span class="line"><span class="keyword">var</span> fun_novar = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">4<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用var，会报错</span></span><br><span class="line"><span class="keyword">var</span> fun_var = <span class="keyword">function</span>(<span class="params"><span class="keyword">var</span> a,<span class="keyword">var</span> b</span>)&#123;</span><br><span class="line">4<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript 的函数是一个对象，而对象又是一种变量。因此也拥有变量的特性，如果定义了多个相同名称的函数，后面的函数会覆盖前面的函数定义，只会存在<strong>一个</strong>真正可用函数实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">4<span class="comment">//定义两个都为fun_same的函数，后者的函数内容会覆盖前者</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> fun_same = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;same_front&quot;</span> + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fun_same = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;same_back&quot;</span> + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    <span class="title function_">fun_same</span>();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出same_back</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 JavaScript 中，函数的调用只与方法的名称有关，和参数列表无关</strong></p>
<p>在 Java 等语言中，方法（函数）在调用时如果需要传入参数，那么就必须将所有参数都传入，使用Java定义一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用时必须将需要的两个参数传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须传入参数</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//不传入则报错找不到方法</span></span><br><span class="line">add();</span><br></pre></td></tr></table></figure>

<p>Java 等面向对象语言中提供了函数重载的功能，可以定义一个相同函数名，不同参数列表的函数来实现同一函数多种功能。</p>
<p>但是这也说明了在 Java等语言中，确定调用的方法（函数）是通过函数名 + 参数列表来实现的。</p>
<p>不同于 Java，在 JavaScript 中，函数的调用只与函数名有关，函数在定义时规定的参数列表只是 <strong>函数的期待参数列表</strong> 而已。</p>
<p>也就是说，JavaScript 的函数在调用时<strong>不用遵循该函数定义时规定的参数列表，可以不传参数，也可以传超出个数的参数，都不会出错。</strong></p>
<p> 请看例子：</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//3. 在JavaScript中，函数的调用只与方法的名称有关，和参数列表无关(重要)</span></span><br><span class="line">    <span class="keyword">var</span> fun_agru1 = <span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(a +<span class="string">&quot;**&quot;</span> + b + <span class="string">&quot;**&quot;</span> + c + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun_agru1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//将全部参数传入</span></span><br><span class="line">    <span class="title function_">fun_agru1</span>(<span class="number">1</span>);<span class="comment">//只传入两个参数</span></span><br><span class="line">    <span class="title function_">fun_agru1</span>();<span class="comment">//不传任何参数</span></span><br><span class="line">    <span class="title function_">fun_agru1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//传入超出函数需要的参数个数</span></span><br><span class="line">   &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   输出结果：</span></span><br><span class="line"><span class="comment">   1**2**3</span></span><br><span class="line"><span class="comment">   1**undefined**undefined</span></span><br><span class="line"><span class="comment">   undefined**undefined**undefined</span></span><br><span class="line"><span class="comment">   1**2**3</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在这个例子中，定义了一个函数，功能为打印传入的参数值，从输出结果中可以看到，四种不同参数个数的调用方式都成功打印了结果。</p>
<ul>
<li><p>当传入的参数足够时，参数值全部被打印，多余的参数未使用但是不会影响函数执行。</p>
</li>
<li><p>当传入的参数不够时，函数在执行时会将未赋值的参数视为未定义。而在 JavaScript 中，未定义则代表值为<code>undefined</code>，所以第2、第 3 个调用未接收到参数值的参数都打印了<code>undefined</code>。</p>
</li>
</ul>
</li>
<li><p><strong>在函数声明中有一个隐藏的内置对象 arguments（数组），封装了所有传入的实际参数（重要）</strong></p>
<p>在第三个特点的介绍中，我们介绍了 JavaScript 中的函数调用时能够接收的实参是不受限制的，当参数个数不够时，未传入实参的形参值为<code>undefined</code>。那么当传入的实参超过需求时，多余的参数又到哪里去了呢？</p>
<p>在 JavaScript 的函数中，有一个 <code>arguments</code> 对象，其本质是一个数组，包含了所有该函数接收到的实参。所有的参数按照调用函数时定义的次序存储在 <code>argments</code> 数组中，上面多余的参数就在这个数组里。</p>
<p>请看例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> fun_agru1 = <span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>] + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>] + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">arguments</span>[<span class="number">3</span>]);</span><br><span class="line">     <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">fun_agru1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//传入超出函数需要的参数个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1**2**3**4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 从打印的结果中可以看到，arguments 对象里面存储了所有的该函数传入的实参，而且按照次序存储在数组中。</p>
<p> 其中 length 属性为 arguments 数组的长度，也就是接收到参数的个数。</p>
<p> arguments[0] 对应 第一个参数 1，argument[1] 对应第二个参数 2 ……等等。</p>
</li>
</ol>
<h3 id="6-3-函数的属性"><a href="#6-3-函数的属性" class="headerlink" title="6.3 函数的属性"></a>6.3 函数的属性</h3><p>length：代表形参的个数</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> fun_attr = <span class="keyword">function</span>(<span class="params">a,b,c</span>);</span><br><span class="line"><span class="keyword">var</span> len = fun_attr.<span class="property">length</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(len + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这里我们就可以看出 JavaScript 中的函数是对象了，因为它有自己的属性，<strong>只有对象才拥有属性</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2luZGV4LmFzcA==">JavaScript 和 HTML DOM 参考手册 (w3school.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p> <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qc3JlZi9qc3JlZi10dXRvcmlhbC5odG1s">JavaScript 和 HTML DOM 参考手册 | 菜鸟教程 (runoob.com)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门（终）：简单的DOM和事件案例</title>
    <url>/2019/10/64a1cc5b2b07.html</url>
    <content><![CDATA[<p>经过了前面的学习，我们对<code>JavaScript</code>算是有了一个初步的了解。但是在真正的开发中，仅仅了解基础是不能帮助我们解决实际问题的。</p>
<p>今天我们就通过一个 <strong>点击按钮切换图片</strong> 的案例来引入 <code>JavaScript</code> 这门语言在实际应用中的用法。</p>
<span id="more"></span>

<h2 id="一、概念引入"><a href="#一、概念引入" class="headerlink" title="一、概念引入"></a>一、概念引入</h2><p>在介绍之前，我们首先引入一些知识，我们可以先不必探究它们到底是什么，只要知道它可以实现这个功能即可。</p>
<h3 id="1-DOM对象"><a href="#1-DOM对象" class="headerlink" title="1. DOM对象"></a>1. DOM对象</h3><p>DOM 对象，全名为文档对象类型，是一种模型或者说一种标准，严格来说其不属于任何一门语言。</p>
<p>DOM 对象为整个 HTML 文档建立一个模型（树结构），将 HTML 中的各个元素都看成一个对象，并定义一系列操作元素的方法，包括对元素的增、删、查、改。</p>
<p>在此案例中，我们需要使用到的是 DOM 中最重要的一个对象，该对象名为<code>document</code>。并使用该对象的一个重要方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br></pre></td></tr></table></figure>

<p>该方法的功能为通过 HTML 元素的 id 属性值获取元素，返回一个对象类型的元素。</p>
<h3 id="2-事件"><a href="#2-事件" class="headerlink" title="2. 事件"></a>2. 事件</h3><p>简单来讲，事件就是一个动作，而 HTML 为这些动作指定了特定的对象，这些对象也称 <strong>HTML事件对象</strong>，例如：</p>
<ul>
<li>点击动作 ： <code>onclick</code></li>
<li>某个键盘被按下： <code>onkeydown</code></li>
</ul>
<p>和 DOM 对象一样，事件不属于任何一门语言，但其是与 HTML 密切相关的。而在 JavaScript 中，通过监听事件可以指定某个事件触发时执行相应的 JavaScript 代码。</p>
<p>例如，我要指定当为点击事件时执行某段 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onclick = <span class="string">&quot;some JavaScript code&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>事件可以作为元素的属性嵌入元素中，也就是指定该元素为触发对象，当在该元素中触发了指定的事件时，就可以执行该事件绑定在该元素上的<code>JavaScript</code>代码。</p>
<p>在此案例中，我们需要利用的事件为点击事件，对象名为：<code>onclick</code></p>
<h2 id="二、代码实现-效果展示"><a href="#二、代码实现-效果展示" class="headerlink" title="二、代码实现&amp;效果展示"></a>二、代码实现&amp;效果展示</h2><p>基本的代码实现如下所示，由于注释的已经很清楚了，我就不再细说了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>点击切换图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">4<span class="comment">&lt;!--图片标签，用于显示图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400x&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./img/01.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取id值为img的标签(元素)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> eleImg = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//设定一个标志变量用来循环切换图片</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//监听此图片标签的onclick事件，当点击这个图片标签时，执行后面的JavaScript函数</span></span></span><br><span class="line"><span class="language-javascript">    eleImg.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(flag)&#123; <span class="comment">//flag为true ，此时显示的为第二张图片，点击切换到第一张</span></span></span><br><span class="line"><span class="language-javascript">            eleImg.<span class="property">src</span> = <span class="string">&quot;./img/01.jpg&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//flag 为false，此时显示的是第一张图片，点击切换到第二张</span></span></span><br><span class="line"><span class="language-javascript">            eleImg.<span class="property">src</span> = <span class="string">&quot;./img/02.jpg&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要用到的两张图片需要放在当前 HTML 文件所在路径的 <code>img</code> 文件夹内，并命名为 <code>01.jpg</code>，<code>02.jpg</code></p>
<p>效果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101715066.gif"></p>
<h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>本系列文章所有代码以及文件都已寄存在github上，地址： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vUHJvamVjdC1XZWJCYXNpYy90cmVlL21hc3Rlci8wOS9mb2xsb3ctU2ltcGxlRE9N">点我跳转<i class="fa fa-external-link-alt"></i></span></p>
<p>通过以上的例子，我们利用 <strong>DOM</strong> 和 <strong>事件</strong> 结合<code>JavaScript</code> 语句实现了一个简单的点击图片相互切换的效果。</p>
<p>这个例子在很多地方都能见到，比如输入验证码时看不清会提示你点击图片刷新验证码，实现原理都是一样的。</p>
<p>当然<code>JavaScript</code>能做到的肯定不止简单的切换图片，这些高级的功能在我们详细学习了 <strong>事件</strong> 以及 <strong>BOM、DOM</strong> 后，我们就会慢慢了解。</p>
<p>而我们的入门阶段就到此结束了，后面，我们正式开始进阶之路第一步：<strong>BOM 浏览器对象模型</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶（一）：BOM对象概述</title>
    <url>/2019/10/6a05d39d3f9a.html</url>
    <content><![CDATA[<p>通过前面的小案例，我们已经知道了将 <strong>JavaScript</strong> <strong>和 DOM</strong>  以及 <strong>事件</strong> 的结合，可以发挥出 <code>JavaScript</code> 独特的巨大能量，但其能量远远不止这些。</p>
<p>为了探究其更深的能量，从本篇开始，我们就开始系统的介绍何为 DOM、BOM、以及事件。</p>
<p>那么首先，我们就从 BOM 开始。</p>
<span id="more"></span>

<h2 id="一、BOM-概念"><a href="#一、BOM-概念" class="headerlink" title="一、BOM 概念"></a>一、BOM 概念</h2><p><strong>BOM</strong>，全名为 Browser Object Model ，翻译过来为 <strong>浏览器对象模型</strong>。</p>
<p>DOM 是将HTML文档中的各个元素封装成一个对象（Document），而 <strong>BOM</strong> 则是将一个浏览器的各个组成部分封装成对象（Browser）供调用使用。</p>
<p>下面我们就来分析 BOM 其中包含哪几个对象以及其中的信息吧。</p>
<h2 id="二、BOM-的组成部分"><a href="#二、BOM-的组成部分" class="headerlink" title="二、BOM 的组成部分"></a>二、BOM 的组成部分</h2><p>首先我们看图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101715816.png" alt="browser-content"></p>
<blockquote>
<p>图片若是看起来不够清晰，请拖动到新窗口打开查看</p>
</blockquote>
<p>在这张图片中， BOM 中各个对象的包含的大致范围和信息都清晰的注明了。</p>
<p>总的来说，BOM 对象大致包含五个部分：</p>
<ul>
<li>Window 对象：浏览器窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：浏览器所处客户端的显示器屏幕对象</li>
<li>History：浏览器当前窗口的访问历史记录对象</li>
<li>Location：浏览器当前窗口的地址栏对象</li>
</ul>
<p>每个对象都有对应的属性和方法，通过这些属性和方法我们可以获取浏览器的信息。在这五个部分中，<strong>Window</strong> 对象尤为重要，根据图片的区域划分，可以很清楚的看出， <strong>Window</strong> 对象其中就已经包含了 History、Location 对象，还有一个非常重要的 <strong>Document</strong> 对象，但由于其重要性太高，所以我们将其单独区分出来，称为 <strong>DOM 对象</strong>。</p>
<p>而另外两个：Navigator、Screen 对象，使用到的次数较少，后面我们对于BOM中的内容主要就涉及 Window、History、Location 三个对象就可以了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript 进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶（二）：BOM 对象详解</title>
    <url>/2019/11/b6aa5bbaf042.html</url>
    <content><![CDATA[<p>上一篇文章中，我们介绍了 BOM 的来源以及其组成部分，为了加深我们对 BOM 的理解，今天我们就将 BOM 中的对象都分析一遍。</p>
<p>下面，我们就开始吧。</p>
<span id="more"></span>

<p>从上一篇文章中，我们已经知道，BOM 主要由以下五大对象组成：</p>
<ul>
<li>Window 对象：浏览器窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：浏览器所处客户端的显示器屏幕对象</li>
<li>History：浏览器当前窗口的访问历史记录对象</li>
<li>Location：浏览器当前窗口的地址栏对象</li>
</ul>
<p>下面我们就将其中最重要的三大对象 Window、History 和 Location 对象进行分析。</p>
<h2 id="一、Window-对象"><a href="#一、Window-对象" class="headerlink" title="一、Window 对象"></a>一、Window 对象</h2><h3 id="1、使用（调用）方式"><a href="#1、使用（调用）方式" class="headerlink" title="1、使用（调用）方式"></a>1、使用（调用）方式</h3><p>不同于一般的对象，BOM 中的 Window 对象不需要创建就可以直接使用，使用其中的方法直接调用即可，类似于我们已知的静态方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.方法名();</span><br></pre></td></tr></table></figure>

<p>比如我们最常用的一个方法，弹出一个警告框 alert：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;window弹出&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但由于在客户端 JavaScript 中，window 对象是全局对象，所有的表达式都在当前的环境中计算。要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。</p>
<p>也就是说，使用 window 对象中的方法可以不用带对象名，直接写方法名即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;no window弹出&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>动图事例：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101721383.gif"></p>
<hr>
<h3 id="2、Window-对象的方法"><a href="#2、Window-对象的方法" class="headerlink" title="2、Window  对象的方法"></a>2、Window  对象的方法</h3><h4 id="2-1-三个带弹出框的方法"><a href="#2-1-三个带弹出框的方法" class="headerlink" title="2.1 三个带弹出框的方法"></a>2.1 三个带弹出框的方法</h4><p>window 对象中，大致有三个方法为带弹出框的，其方法名和大致用法为：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">alert()</td>
<td align="center">显示带有一段消息和一个确认按钮的警告框。</td>
</tr>
<tr>
<td align="center">confirm()</td>
<td align="center">显示带有一段消息以及确认按钮和取消按钮的对话框。</td>
</tr>
<tr>
<td align="center">prompt()</td>
<td align="center">显示可提示用户输入的对话框。</td>
</tr>
</tbody></table>
<p>其中，alert 我们在上面以及前面多次提到了，就不在赘述了，下面我们主要看后面的这两个方法。</p>
<p>首先是 <strong>confirm()</strong> 方法，其负责显示一个带确认取消按钮的对话框，基本用法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">confirm</span>(<span class="string">&quot;确定这样做吗&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101722393.gif"></p>
<p>可以看到，<strong>confirm</strong> 的确实现了带确认取消的弹窗。</p>
<p>但是也可以看到，无论我点击 <strong>confirm</strong> 中的 <strong>确认</strong> 还是 <strong>取消</strong>，好像都没有什么不同。事实上， <strong>confirm</strong> 方法会返回一个布尔值，当用户点击确定时返回 <strong>true</strong>，点击取消时返回 <strong>false</strong>。下面我们用一个例子演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;确定这样做吗？&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">4<span class="title function_">alert</span>(<span class="string">&quot;是的&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">4<span class="title function_">alert</span>(<span class="string">&quot;不&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101722702.gif"></p>
<p>然后就是 <strong>prompt()</strong> 方法了，其负责显示一个具有输入框的弹出框，基本用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">promt</span>(<span class="string">&quot;输入点东西吧&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样的，prompt 也具有返回值，返回的就是用户在输入框输入的信息。</p>
<blockquote>
<p>注意，当点击输入框下方的取消时，无论你是否已经输入了信息，返回值都为 null</p>
</blockquote>
<p>使用示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="title function_">prompt</span>(<span class="string">&quot;输入点东西吧&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(text);</span><br></pre></td></tr></table></figure>

<p>演示效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101722692.gif"></p>
<p>总的来说，这三个带弹出框的方法其实各有异同，他们三个使用的优先级为：</p>
<p><strong>confirm &gt; alert &gt; prompt</strong></p>
<p>更推荐大家使用 <strong>confirm</strong>，用户体验会更舒服。</p>
<h4 id="2-2-与打开和关闭有关的方法"><a href="#2-2-与打开和关闭有关的方法" class="headerlink" title="2.2 与打开和关闭有关的方法"></a>2.2 与打开和关闭有关的方法</h4><p>在 window 对象中，跟打开和关闭有关系，且我们最常用的方法有以下两个：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open()</td>
<td align="center">打开一个新的浏览器窗口或查找一个已命名的窗口。</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">关闭浏览器窗口。</td>
</tr>
</tbody></table>
<p>对于 <strong>open()</strong> 方法，其负责打开一个新的浏览器窗口，可以指定一个 URL 字符串在新窗口打开指定的网页地址。</p>
<p>其基本的用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在新窗口打开百度</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps:  请不要混淆方法 window.open() 与方法 document.open()，这两者的功能完全不同。为了使您的代码清楚明白，请使用 window.open()，而不要使用 open()。</p>
</blockquote>
<p><strong>open()</strong> 方法返回一个 window 对象，该 window 对象为新打开的浏览器窗口。</p>
<p>其次是 <strong>close()</strong> 方法，其负责关闭指定浏览器窗口，使用时需要指定要关闭的 window 对象，若不指定，则默认关闭当前页面所处的窗口。</p>
<p>其基本用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;打开新窗口&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;关闭打开的窗口&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//open方法演示</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> eleBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> newwindow;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        eleBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            newwindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//close用法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> eleBtnc = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnc&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        eleBtnc.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            newwindow.<span class="title function_">close</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>为了更清楚的显示出 close() 方法的用法，在这结合了 open() 方法的使用，close() 方法负责关闭 open() 方法所打开的窗口。</p>
<p>最终呈现效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101722010.gif"></p>
<h4 id="2-3-与定时器有关的方法"><a href="#2-3-与定时器有关的方法" class="headerlink" title="2.3 与定时器有关的方法"></a>2.3 与定时器有关的方法</h4><blockquote>
<p>定时器：类似闹钟，在一个规定的时间或者时间周期内执行</p>
</blockquote>
<p>在 window 对象中，与定时器相关的方法共有四个，其方法名和大致描述如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setTimeout()</td>
<td align="center">在指定的毫秒数后调用函数或计算表达式（一次）。</td>
</tr>
<tr>
<td align="center">clearTimeout()</td>
<td align="center">取消由 setTimeout() 方法设置的时间。</td>
</tr>
<tr>
<td align="center">setInterval()</td>
<td align="center">按照指定的周期（以毫秒计）来调用函数或计算表达式（多次）。</td>
</tr>
<tr>
<td align="center">clearInterval()</td>
<td align="center">取消由 setInterval() 设置的周期。</td>
</tr>
</tbody></table>
<p><strong>setTimeout()：指定时间后执行1次（只执行一次）</strong></p>
<p><code>setTimeout()</code> 方法规定在指定的时间（毫秒）后执行指定的 <code>JavaScript</code> 代码，且仅 <strong>执行一次</strong>。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(code,millisec);</span><br><span class="line"><span class="comment">//code 为指定要执行的JS代码</span></span><br><span class="line"><span class="comment">//millisec 为在执行代码前需要等待的时间（毫秒）</span></span><br></pre></td></tr></table></figure>

<p>基本的用法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 3 秒后弹出一个警告框</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;lololol&#x27;);&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//在 3 秒后弹出一个 confirm 对话框</span></span><br></pre></td></tr></table></figure>



<p>相反地，<code>clearTimeout()</code>则是取消由<code>setTimeout()</code>设定的延迟执行的操作。</p>
<p>在一段 JavaScript 代码中，可能会同时出现多个<code>setTimeout()</code>设定的定时器操作，和上文中的 <code>close()</code> 方法使用的情况类似，<code>clearTimeout()</code>在使用时必须通过 id 值  指定某个特定的定时器。</p>
<p>而实际上， 每一个 <code>setTimeout()</code>方法都会返回一个独特的 id 值，这个 id 值指代了这个定时器。</p>
<p>所以，我们可以使用其返回的这个id值来取消指定的<code>setTimeout</code>定时器。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(id);</span><br><span class="line"><span class="comment">//id 值为特定的 setTimeout() 返回的 id 值</span></span><br></pre></td></tr></table></figure>

<p>基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 3 秒后弹出一个警告框</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;lololol&#x27;);&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//取消该弹出操作</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(id);</span><br></pre></td></tr></table></figure>

<p><strong>setInterval：指定每过一个时间间隔执行一次（多次执行）</strong></p>
<p>假定这样一个情况：由于页面的数据需要实时性，所以每隔一段时间就需要刷新一次页面更新数据。</p>
<p>为了实现这个需求，我们就需要一个每隔一段时间自动执行的代码，它可以帮我们自动拉取并更新数据。</p>
<p>而 <code>setInterval</code> 方法的用法就是按照指定的周期（以毫秒计）来调用函数或计算表达式(循环调用)</p>
<p>语法 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(code,millisec);</span><br><span class="line"><span class="comment">//code 为函数每个周期所执行的 JavaScript 代码</span></span><br><span class="line"><span class="comment">//millisec 指定每隔多少时间（毫秒）执行函数中的方法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：一个 id 值，标识一个独立的定时器，此定时器由setInterval()方法创建</p>
</blockquote>
<p>基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每过 2s 向 html 文档中写入数字 2</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;document.write(&#x27;2&#x27;);&quot;</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>



<p>如 <code>setTimeout()</code> 设定的定时器可以被 <code>clearTimeout()</code>取消一样。<code>setInterval()</code>设定的循环定时器也可以被取消，对应的取消方法为 <code>clearInterval()</code>。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(id);</span><br><span class="line"><span class="comment">//id 值为特定的 setInterval() 返回的id值</span></span><br></pre></td></tr></table></figure>

<p>基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每过 2s 向 html 文档中写入数字 2</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setInterval</span>(<span class="string">&quot;document.write(&#x27;2&#x27;);&quot;</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//过 4s 后取消循环写入数字 2 操作</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;clearInterval(id);&quot;</span>,<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3、Window-对象的属性"><a href="#3、Window-对象的属性" class="headerlink" title="3、Window 对象的属性"></a>3、Window 对象的属性</h3><p>从上篇文章中的图片中，我们可以清晰的看到，其实在 BOM 中，window 对象就已经包含了大部分的对象，而通过对 window 对象的属性访问，同样可以获取到其他的 BOM 对象的引用。</p>
<p>以下是各个 BOM 对象通过 window 对象获取的方式：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
<th align="center">通过window对象获取方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history</td>
<td align="center">对 History 对象的只读引用</td>
<td align="center"><code>window.history</code></td>
</tr>
<tr>
<td align="center">location</td>
<td align="center">对 Location 对象的只读引用</td>
<td align="center"><code>window.location</code></td>
</tr>
<tr>
<td align="center">navigator</td>
<td align="center">对 Navigator 对象的只读引用</td>
<td align="center"><code>window.navigator</code></td>
</tr>
<tr>
<td align="center">screen</td>
<td align="center">对 Screen 对象的只读引用</td>
<td align="center"><code>window.screen</code></td>
</tr>
</tbody></table>
<p>还有还有一个最重要的对象： <strong>document 对象</strong>，也是 window 对象的一部分。</p>
<p>也就是说，可以使用如下方法获取 document 对象的引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>;</span><br></pre></td></tr></table></figure>

<p>在前面的点击切换图片的小案例中，我们使用了这个方法 ： <code>document.getElementByID()</code>。</p>
<p>其实也可以通过如下方式使用该方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>();</span><br></pre></td></tr></table></figure>

<p>我们一般都会将前面的 window 省去，就像 window 中的各种方法一样，直接使用。</p>
<p>但我们还是要了解，其实 无论是 BOM 还是 DOM，<strong>window 对象都是其核心</strong>。</p>
<hr>
<h2 id="二、Location对象"><a href="#二、Location对象" class="headerlink" title="二、Location对象"></a>二、Location对象</h2><h3 id="1、使用（调用）方式-1"><a href="#1、使用（调用）方式-1" class="headerlink" title="1、使用（调用）方式"></a>1、使用（调用）方式</h3><p>location 对象代表浏览器窗口中的地址栏，和 window 对象一样，无需特殊的创建方式，通过对象名就可使用，并调用其中的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.方法名()</span><br></pre></td></tr></table></figure>

<p>而由于 location 对象属于 window 对象的一部分，所以也可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.方法名();</span><br></pre></td></tr></table></figure>

<h3 id="2、Location方法"><a href="#2、Location方法" class="headerlink" title="2、Location方法"></a>2、Location方法</h3><p>location 对象中的方法及用法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>assign()</td>
<td>加载新的文档。</td>
</tr>
<tr>
<td>reload()</td>
<td>重新加载当前文档。</td>
</tr>
<tr>
<td>replace()</td>
<td>用新文档替换当前文档。</td>
</tr>
</tbody></table>
<p>由于这三个方法使用都比较简单，就不细分叙述了，基本使用如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;assign&quot; id=&quot;assign&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;reload&quot; id=&quot;reload&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;replace&quot; id=&quot;replace&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /**</span><br><span class="line">     * 加载新文档,参数为URL地址，会产生历史记录</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    document.getElementById(&quot;assign&quot;).onclick = function()&#123;</span><br><span class="line">        location.assign(&quot;http://www.baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 重新加载文档，参数为一个布尔值，默认为false</span><br><span class="line">     * 1.如该方法没有设定参数值或设定为false，那该方法会使用浏览器缓存来重新加载页面（浏览器默认刷新方式）</span><br><span class="line">     * 2.如该方法参数值为true，那么该方法会无条件向服务器重新下载该文档并重新加载</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    document.getElementById(&quot;reload&quot;).onclick = function()&#123;</span><br><span class="line">        location.reload(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // /**</span><br><span class="line">    //  * 替换当前文档，和 assign 方法类似</span><br><span class="line">    //  * 但是不会产生历史记录，也就是无法通过后退键返回上一个页面</span><br><span class="line">    //  */</span><br><span class="line">    document.getElementById(&quot;replace&quot;).onclick = function()&#123;</span><br><span class="line">        location.replace(&quot;http://www.baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101722709.gif"></p>
<h3 id="3、Location属性"><a href="#3、Location属性" class="headerlink" title="3、Location属性"></a>3、Location属性</h3><p>location 的属性如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">设置或返回从井号 (#) 开始的 URL（锚）。</td>
</tr>
<tr>
<td align="left">host</td>
<td align="left">设置或返回主机名和当前 URL 的端口号。</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">设置或返回当前 URL 的主机名。</td>
</tr>
<tr>
<td align="left">href</td>
<td align="left">设置或返回完整的 URL。</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left">设置或返回当前 URL 的路径部分。</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">设置或返回当前 URL 的端口号。</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">设置或返回当前 URL 的协议。</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">设置或返回从问号 (?) 开始的 URL（查询部分）。</td>
</tr>
</tbody></table>
<p>各个属性的用法描述中已经很清楚了，我就不详细赘述了。</p>
<p>这里只提一个常用的属性：<code>href</code>，其功能为设置或返回完整的 URL 。</p>
<p>通过这个属性，我们可以获取浏览器地址栏的完整地址，或是设置地址为新地址，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">4<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;href获取&quot;</span> <span class="attr">id</span>=<span class="string">&quot;href01&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;href设置&quot;</span> <span class="attr">id</span>=<span class="string">&quot;href02&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">4<span class="comment">/**</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">     * href 属性</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">     * 设置或返回完整URL</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">     * 当其设置一个新href时，其效果和assign()一样，加载新URL，并产生历史记录</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">     */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;href01&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(location.<span class="property">href</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;href02&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        location.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101723816.gif"></p>
<h2 id="三、History对象"><a href="#三、History对象" class="headerlink" title="三、History对象"></a>三、History对象</h2><blockquote>
<p>特别注意：这里的 History 对象记录的历史记录只和当前窗口有关，并不是浏览器的全部历史记录。</p>
</blockquote>
<h3 id="1、使用（调用）方式-2"><a href="#1、使用（调用）方式-2" class="headerlink" title="1、使用（调用）方式"></a>1、使用（调用）方式</h3><p>history 对象表示当前窗口的历史记录，同样通过对象名可以直接调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.方法名();</span><br><span class="line">history.属性名</span><br></pre></td></tr></table></figure>

<p>history对象也属于 window 对象的一部分，所以也可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.方法名();</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.属性名</span><br></pre></td></tr></table></figure>

<h3 id="2、History方法"><a href="#2、History方法" class="headerlink" title="2、History方法"></a>2、History方法</h3><p>在 history对象中，共有三个方法，它们分别为：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">back()</td>
<td align="left">加载当前窗口 history 列表中的前一个 URL。</td>
</tr>
<tr>
<td align="left">forward()</td>
<td align="left">加载当前窗口 history 列表中的下一个 URL。</td>
</tr>
<tr>
<td align="left">go()</td>
<td align="left">加载当前窗口 history 列表中的某个具体页面。</td>
</tr>
</tbody></table>
<p>为了完成这三个方法的演示，我们需要两个html文档，第一个文档<code>history00.html</code>核心内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./history.html&quot;</span>&gt;</span>去history对象页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>第二个文档<code>history.html</code>核心内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>打开一个页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;goForward前进&quot; onclick=&quot;goForward()&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;goBack后退&quot; onclick=&quot;goBack()&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;go去后一个页面&quot; onclick=&quot;go()&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * forward()方法</span><br><span class="line">     * 加载当前窗口历史列表的前一个页面</span><br><span class="line">     * 类似于浏览器中的前进按钮</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    function goForward() &#123;</span><br><span class="line">        history.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * back()方法</span><br><span class="line">     * 加载当前窗口历史列表的后一个页面</span><br><span class="line">     * 类似于浏览器中的后退按钮</span><br><span class="line">    */</span><br><span class="line">    function goBack() &#123;</span><br><span class="line">        history.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * go()方法</span><br><span class="line">     * 加载当前窗口历史列表的一个具体页面</span><br><span class="line">     * 参数可以为一个URL或者一个数字，数字代表要访问的URL在历史记录的相对位置</span><br><span class="line">     */</span><br><span class="line">    function go() &#123;</span><br><span class="line">        //-1表示向后一个页面</span><br><span class="line">        history.go(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101723002.gif"></p>
<h3 id="3、History属性"><a href="#3、History属性" class="headerlink" title="3、History属性"></a>3、History属性</h3><p>history 对象只有一个属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">length</td>
<td align="left">返回浏览器历史列表中的 URL 数量。</td>
</tr>
</tbody></table>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>例子，在上面第二个html文档中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取历史记录数量&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getLength()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;script&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *length属性</span></span><br><span class="line"><span class="comment">    * 显示当前窗口历史记录数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="title function_">alert</span>(history.<span class="property">length</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;script&gt;</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101723981.gif"></p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>本节中所有使用的演示代码及资料都可以在我的github上找到，直达链接 ： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vUHJvamVjdC1XZWJCYXNpYy90cmVlL21hc3Rlci8wOS9KYXZhU2NyaXB0UHJvRGVtby9mb2xsb3ctQk9N">点我跳转<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>本节，我们介绍了 BOM 对象中的各个对象以及各个对象中的相关方法和属性，我们算是对 BOM 有一个大概的认识了。</p>
<p>下节，我们开始 DOM 的学习，探究 DOM 这个强大的文档对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始React（一）：构建webpack项目</title>
    <url>/2020/03/4bb03b1c752d.html</url>
    <content><![CDATA[<p><em>webpack</em> 是一个现代 JavaScript 应用程序的 <strong>静态模块打包器</strong>。</p>
<p>为了使用 <em>React</em>  的便利，我们需要先熟悉如何构建一个简单的 <em>webpack</em>  项目。</p>
<span id="more"></span>

<blockquote>
<p>  本博客的内容会实时在Github上同步更新，博客内涉及的代码也会在GitHub上上传：</p>
<p>  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vcmVhY3QtcHJhY3Rpc2U=">https://github.com/qianfanguojin/react-practise<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>工具：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">VSCode <i class="fa fa-external-link-alt"></i></span>（安装一些必要的<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjY5NzIxOQ==">插件<i class="fa fa-external-link-alt"></i></span>）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js<i class="fa fa-external-link-alt"></i></span></li>
<li>一台电脑</li>
</ul>
<p>确保满足以上条件后，我们开始下面的步骤。</p>
<h3 id="1-建立必要文件-夹"><a href="#1-建立必要文件-夹" class="headerlink" title="1. 建立必要文件(夹)"></a>1. 建立必要文件(夹)</h3><p>打开<code>VSCode</code>，建立一个空文件夹 <code>react_basic</code>，在<code>react_basic</code> 根目录下建立新文件夹 <code>src</code> 、<code>dist</code>，在<code>src</code>目录新建 <code>index.html</code> ,<code>index.js</code>。</p>
<p>编辑<code>index.html</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此时处于内存中的index.html会自动引用根目录下的main.js,不需要手动导入 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src=&quot;../main.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello React</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时项目结构：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311202537.png"></p>
<h3 id="2-初始化npm项目"><a href="#2-初始化npm项目" class="headerlink" title="2. 初始化npm项目"></a>2. 初始化npm项目</h3><p>在终端中进入 <code>react_basic</code> 目录，接下来所有的命令都在这个目录下执行。</p>
<p>执行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>根目录会生成 <code>package.json</code> 文件。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311202953.png"></p>
<h3 id="3-安装配置-webpack"><a href="#3-安装配置-webpack" class="headerlink" title="3. 安装配置 webpack"></a>3. 安装配置 webpack</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装<code>webpack</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i webpack -D</span><br></pre></td></tr></table></figure>

<p>安装<code>webpack-cli</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 可以看到：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195622.png" alt="img-01"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在项目根目录新建 <code>webpack.config.js</code>，并填入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">module.exports =<span class="punctuation">&#123;</span></span><br><span class="line">4mode<span class="punctuation">:</span>&#x27;development&#x27; <span class="comment">//生成不压缩的代码，production：会压缩代码</span></span><br><span class="line">    <span class="comment">// webpack4.x中约定默认打包入口为src-&gt;index.js</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>最终的项目结构如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195712.png" alt="img-02"></p>
<p>终端输入 <code>webpack</code> ，会在dist目录生成<code>main.js</code>文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195757.png" alt="img-03"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195811.png" alt="image-20200311142401824"></p>
<h3 id="4-安装配置-webpack-dev-server"><a href="#4-安装配置-webpack-dev-server" class="headerlink" title="4. 安装配置 webpack-dev-server"></a>4. 安装配置 webpack-dev-server</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>安装<code>webpack-dev-server</code> ,<code>webpack-dev-server</code>工具可以实时监听代码文件的更改来执行内存打包，速度非常快。</p>
<p>这样我们就可以实时在网页中看到代码修改的效果，而不用每次使用<code>webpack</code>手动打包了：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195842.png" alt="image-20200311142658000"></p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>为了方便调用<code>webpack-dev-server</code>工具，我们编辑<code>package.json</code>文件中的<code>scripts</code>部分，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> scripts<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span><span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311195853.png" alt="image-20200311142826506"></p>
<p>之后使用<code>npm run dev</code>命令调用 <code>dev</code> 对应的命令，就会自动启动<code>webpack-dev-server</code>，此时当前项目将被托管于本地的web服务器，默认托管于8080端口。</p>
<p>同时会在项目根目录下生成<code>main.js</code>(内存中，磁盘中不会存在此文件)，可以直接通过<code>localhost:8080/main.js</code>访问。</p>
<p>同时在<code>index.html</code> 的<code>head</code>标签下引人：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;../main.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311200732.png" alt="image-20200311155407161"></p>
<p>这样，<code>index.js</code> (生成<code>main.js</code>)的内容更改就会实时更新配置到<code>index.html</code>中。</p>
<p>运行测试：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311200807.png" alt="image-20200311155514231"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311200836.png" alt="image-20200311154937096"></p>
<h3 id="5-安装辅助工具"><a href="#5-安装辅助工具" class="headerlink" title="5. 安装辅助工具"></a>5. 安装辅助工具</h3><p>虽然 <code>index.js</code> 通过<code>webpack-dev-server</code> 自动打包<code>main.js</code>更新<code>index.html</code>，但是由于<code>index.html</code>文件存放于<code>src</code>目录，目前访问<code>index.htm</code>l还需要切换至<code>src</code>目录，而且<code>index.html</code>也无法实时更改、自动更新。</p>
<p>因此我们需要将<code>index.html</code>也加载到内存中，实现自动加载更新。</p>
<p>借助新的工具 <code>html-webpack-plugin</code> ，其可以提供将<code>index.html</code>自动加载到项目根目录中（内存中），通过<code>localhost:8080</code>可以直接访问<code>index.html</code>,并且可以将<code>main.js</code>自动导入到<code>index.html</code>。</p>
<h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311200940.png" alt="image-20200311143213485"></p>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>编辑<code>webpack-config.js</code>文件，使用require导入<code>html-webpack-plugin</code>，同时导入node的系统内置模块path。</p>
<p><strong>这段语句放在 <code>module.exports</code>  前</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> =  <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"><span class="comment">//创建插件对象，使用path拼接当前项目的路径，如果直接写/,是相对于系统磁盘的，此时/不代表项目的根目录，因此需要使用path模块进行拼接</span></span><br><span class="line"> <span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">template</span>:path.<span class="title function_">join</span>((__dirname),<span class="string">&quot;/src/index.html&quot;</span>),</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;index.html&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置<code>plugins</code>选项来启用插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">//production：会压缩代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// webpack4.x中约定默认打包入口为src-&gt;index.js</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>:[htmlPlugin]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再运行，<code>main.js</code>会被自动引入，而且<code>index.html</code>的更新也会被实时反映到浏览器中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311201013.png" alt="image-20200311162642328"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始React（二）：搭建React环境</title>
    <url>/2020/03/b69dceabf563.html</url>
    <content><![CDATA[<p>上一节我们通过一些简单的配置，搭建了基于  <em>webpack</em>  的开发环境。</p>
<p>本节介绍如何搭建 React 的工作环境。</p>
<span id="more"></span>

<blockquote>
<p>  本博客的内容会实时在Github上同步更新，博客内涉及的代码也会在GitHub上上传：</p>
<p>  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vcmVhY3QtcHJhY3Rpc2U=">https://github.com/qianfanguojin/react-practise<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>首先确保你有一个 <code>webpack</code> 构建好的项目，不然接下来的步骤无法结合。</p>
<p>不知道如何搭建的，请看我上一篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cucWlhbmZhbmd1b2ppbi50b3AvMjAyMC8wMy8xMS8lRTQlQkIlOEUlRTklOUIlQjYlRTUlQkMlODAlRTUlQTclOEJSZWFjdCVFRiVCQyU4OCVFNCVCOCU4MCVFRiVCQyU4OSVFRiVCQyU5QSVFNiU5RSU4NCVFNSVCQiVCQXdlYnBhY2slRTklQTElQjklRTclOUIlQUUvI21vcmU=">从零开始React（一）：构建webpack项目<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="2-React-介绍"><a href="#2-React-介绍" class="headerlink" title="2. React 介绍"></a>2. React 介绍</h2><p>两大组件：react 、react-dom</p>
<p>概念：</p>
<ul>
<li><p>react：专门用于创建组建和虚拟的dom元素 同时，组建的生命周期也在react包中</p>
</li>
<li><p>react-dom：专门进行DOM操作的，最主要的应用场景就是 <code>ReactDOM.render()</code></p>
</li>
<li><p>容器(一个div 标签)：React 创建的虚拟DOM元素会被渲染到该容器中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>在搭建好的<code>webpack</code>项目 (我这里是上一节的<code>react_basic</code>项目)，在根目录终端执行以下命令(可以再开启一个终端,之前终端被<code>webpack</code>占用):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i react react-dom -S:安装React插件和React Dom插件</span><br></pre></td></tr></table></figure>

<p>在根目录的 <code>package.json</code> 文件中可以看到 <code>dependencies</code> 下有react 和 react-dom ，说明安装成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200311220614.png"></p>
<h2 id="4-开始使用"><a href="#4-开始使用" class="headerlink" title="4. 开始使用"></a>4. 开始使用</h2><p>在已经配置好的<code>webpack</code>项目中，在 <code>/src/index.js</code> 中加入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span> <span class="comment">//导入react 包并命名为 React</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span> <span class="comment">// 导入ReactDOM并命名为ReactDOM</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.使用React中的createElement()方法创建虚拟dom元素 &lt;h1 title:&#x27;标题&#x27;,id:&#x27;myh1&#x27;&gt;我是一个标题&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> *   参数一：表示要创建的dom元素（h1）</span></span><br><span class="line"><span class="comment"> *   参数二：对象类型的参数&#123;&#125;，表示 创建的元素的属性节点 如果没有属性可以设置为null或者&#123;&#125;</span></span><br><span class="line"><span class="comment"> *   参数三：对象类型（dom）标签内的内容</span></span><br><span class="line"><span class="comment"> *   参数四~参数n：子节点</span></span><br><span class="line"><span class="comment"> * 2.使用ReactDOM中的render()方法渲染虚拟dom元素</span></span><br><span class="line"><span class="comment"> *   参数一：要渲染的虚拟dom对象（myh1）</span></span><br><span class="line"><span class="comment"> *   参数二：指定要渲染到的容器dom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> myh1 = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="literal">null</span>,<span class="string">&#x27;h1标题&#x27;</span>);<span class="comment">//创建虚拟元素</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(myh1,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));<span class="comment">//将myh1渲染到id=&#x27;app&#x27;的容器标签下</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20200311153146.png" alt="image-20200311153143914"></p>
<p>浏览器效果：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20200311153235.png" alt="image-20200311153229566"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门（三）：运算符与流程控制语句</title>
    <url>/2022/01/232461b1ec4a.html</url>
    <content><![CDATA[<p>续接前文，我们继续讲 JavaScript 中 ECMAScript 的部分，这节主要讲 JavaScript 中的运算符与流程控制语句的用法。</p>
<span id="more"></span>

<h2 id="1-JavaScript-常用运算符"><a href="#1-JavaScript-常用运算符" class="headerlink" title="1. JavaScript 常用运算符"></a>1. JavaScript 常用运算符</h2><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul>
<li><p>自增运算符 <code>++</code> ，自减运算符<code>--</code>和Java相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(i + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//i 值为 1</span></span><br><span class="line">i++</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(i + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//自增一次 i 值变为 2。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正负号：<code>+(-)</code>。正负号只有数据类型为数字number类型时才有意义，如果将正负号运算符放在非 number 数据类型之前，则需要进行类型转换。</p>
<p>一些类型转 number 的介绍：</p>
<ul>
<li>string 转 number：按照字面值转换，如果字面值不是数字，则转为 NaN。如字符串 “123” 转为 123 ，字符串 “123ab” 则转为 NaN。</li>
<li>boolean 转 number：true 值转为 1 ，false 转为 0</li>
</ul>
</li>
</ul>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>和 Java一样，JavaScript 的算数运算符的用法基本相同：</p>
<ul>
<li>算数运算符加： <code>+</code></li>
<li>算数运算符减： <code>-</code></li>
<li>算数运算符乘： <code>*</code></li>
<li>算数运算符除： <code>/</code>。这里注意，在 JavaScript 中，由于 number 数据类型可以表示为整数以及小数，所以在执行除法时结果会有小数。如 5&#x2F;2，结果为2.5。</li>
<li>算数运算符取余： <code>%</code></li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>在 JavaScript 中，比较运算符的类型和其他语言差不多，它们分别是：</p>
<ul>
<li>比较运算符大于&amp;大于等于：<code>&gt;</code> <code>&gt;=</code></li>
<li>比较运算符小于&amp;小于等于：<code>&lt;</code> <code>&lt;=</code></li>
<li>比较运算符等于：<code>==</code></li>
<li>比较运算符不等于：<code>!=</code></li>
<li>比较运算符<strong>全等于</strong>：<code>===</code></li>
</ul>
<p>比较运算符的类型和其他语言差不多，不过要注意 JavaScript 中特有的<code>===</code><strong>全等于</strong>比较运算符，稍后我们会给到解释。现在我们先来介绍一下在 JavaScript 中运算符作用的两种情况：</p>
<ol>
<li><p>比较的数据类型相同：直接比较。</p>
<p>这里就不过多解释了，直接上示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    比较运算符，类型相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="number">1</span> &gt; <span class="number">3</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="number">2</span> &gt; <span class="number">1</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="number">1</span> == <span class="number">1</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串在进行比较时按字典顺序比较</span></span><br><span class="line">    <span class="comment">// 按位逐一比较，直到得出大小</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;123&quot;</span> &gt; <span class="string">&quot;121&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;abc&quot;</span> &gt; <span class="string">&quot;abd&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;abc&quot;</span> &lt; <span class="string">&quot;abd&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较的数据类型不同：先进行类型转换，在进行比较。</p>
<p>同样给出示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">44<span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较运算符，类型不同</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//字符串和数字比较，字符串转为数字类型再进行比较</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;123&quot;</span> == <span class="number">123</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);<span class="comment">//true</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;123&quot;</span> &gt; <span class="number">123</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//全等于运算符&quot;===&quot;,再比较之前，先判断两边的数据类型，如果类型不同，直接返回fals</span></span><br><span class="line">        <span class="comment">//字符串和数字类型不同，返回false</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>((<span class="string">&quot;123&quot;</span> === <span class="number">123</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>JavaScript 中的逻辑运算符类型：</p>
<ul>
<li>逻辑运算符与： <code>&amp;</code> ,短路 <code>&amp;&amp;</code>。</li>
<li>逻辑运算符或：<code>|</code>,短路 <code>||</code>。</li>
<li>逻辑运算符非：<code>!</code>。</li>
</ul>
<h3 id="运算数类型的自动转换"><a href="#运算数类型的自动转换" class="headerlink" title="运算数类型的自动转换"></a>运算数类型的自动转换</h3><p>在 Java 中，逻辑运算符两边的数据类型必须为 boolean 类型才能进行逻辑运算，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以，a&gt;b 和 a&lt;b 返回的都是boolean值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>((a&gt;b) &amp;&amp; (a&lt;b))&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//报错，两个整型值进行逻辑运算</span></span><br><span class="line">    <span class="keyword">if</span>(a &amp;&amp; b) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在 JavaScript 中，逻辑运算符两边的数据类型可以<strong>不仅限于boolean类型</strong>；在进行运算时，如果某个运算数不是 boolean 类型，运算数则会参照下表规则转为相应的 boolean 类型：</p>
<table>
<thead>
<tr>
<th>运算数类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>false</td>
</tr>
<tr>
<td>Null</td>
<td>false</td>
</tr>
<tr>
<td>Boolean</td>
<td>结果等于输入的参数（不转换）</td>
</tr>
<tr>
<td>Number</td>
<td>如果参数为 +0, -0 或 NaN，则结果为 false；否则为 true。</td>
</tr>
<tr>
<td>String</td>
<td>如果参数为空字符串，则结果为 false；否则为 true。</td>
</tr>
<tr>
<td>Object</td>
<td>true</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     逻辑运算符，运算符类型不同时的相互转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//null转为false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((!!(<span class="literal">null</span>)) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="comment">//undefined转为false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((!!(<span class="literal">undefined</span>)) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="comment">//number数据类型：0 或 NaN 为false，大于0为true</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(!!(<span class="number">0</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(!!(<span class="title class_">NaN</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(!!(<span class="number">1</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//string数据类型：空字符串 &quot;&quot;为false，其余都为true</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(!!(<span class="string">&quot;&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(!!(<span class="string">&quot;a&quot;</span>) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//Object对象数据类型：除了对象为空(null),其余都为true</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((!!(obj)) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>((!!(obj)) + <span class="string">&quot;&lt;br/&gt;&quot;</span>); <span class="comment">//false</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="不同逻辑运算符返回值的区别"><a href="#不同逻辑运算符返回值的区别" class="headerlink" title="不同逻辑运算符返回值的区别"></a>不同逻辑运算符返回值的区别</h4><p><span style="color:red">不同于 Java，在 JavaScript 中，只有逻辑运算符 <code>!</code> 返回值才一定是 boolean 类型。逻辑运算符<code>&amp;&amp;</code> 和 <code>||</code>运算符并不一定返回 boolean 类型的值，而是会返回一个指定操作数的值。</span></p>
<p>逻辑运算符<code>!</code>的规则如下：</p>
<ul>
<li>如果运算数是对象，返回 false</li>
<li>如果运算数是数字 0，返回 true</li>
<li>如果运算数是 0 以外的任何数字，返回 false</li>
<li>如果运算数是 null，返回 true</li>
<li>如果运算数是 NaN，返回 true</li>
<li>如果运算数是 undefined，发生错误</li>
</ul>
<p>逻辑运算符<code>&amp;&amp;</code>的规则如下：</p>
<ul>
<li>如果一个运算数是对象，另一个是 Boolean 值，返回该对象。</li>
<li>如果两个运算数都是对象，返回第二个对象。</li>
<li>如果某个运算数是 null，返回 null。</li>
<li>如果某个运算数是 NaN，返回 NaN。</li>
<li>如果某个运算数是 undefined，发生错误。</li>
</ul>
<p>逻辑运算符<code>||</code>的规则如下：</p>
<ul>
<li>如果一个运算数是对象，并且该对象左边的运算数值均为 false，则返回该对象。</li>
<li>如果两个运算数都是对象，返回第一个对象。</li>
<li>如果最后一个运算数是 null，并且其他运算数值均为 false，则返回 null。</li>
<li>如果最后一个运算数是 NaN，并且其他运算数值均为 false，则返回 NaN。</li>
<li>如果某个运算数是 undefined，发生错误。</li>
</ul>
<p><span style="color:red">但是，尽管 <code>&amp;&amp;</code> 和 <code>||</code> 运算符能够返回非布尔值的操作数, 但它们依然可以被看作是布尔操作符，因为它们的返回值总是能够被转换为布尔值。如果要显式地将它们的返回值（或者表达式）转换为布尔值，请使用双重非运算符（即<code>!!</code>）或者 Boolean 构造函数。</span></p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>语法格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">表达式 ? 值<span class="number">1</span>:值<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     三元运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 解释：1大于2吗？，大于返回5，不大于则返回6</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">1</span>&gt;<span class="number">2</span> ? <span class="number">5</span> : <span class="number">6</span>);<span class="comment">//返回6</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="2-流程控制语句"><a href="#2-流程控制语句" class="headerlink" title="2. 流程控制语句"></a>2. 流程控制语句</h2><p>共有以下五种：</p>
<ul>
<li>if….else</li>
<li>switch</li>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
<p>特别注意这里的 switch 语句，在 Java 中，switch 语句可以接受的数据类型是有限制的：byte、int、short、char、enum（jdk1.5）、String（jdk1.7）。而在 JavaScript 中，switch 可以接受任意的原始数据类型（number、string、boolean……）。</p>
<p>一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//您可以通过变换不同的 a 值来测试</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;整型&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;abc&quot;</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">true</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;布尔型&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">null</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;默认&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除 switch 外，JavaScript 中其余的流程控制语句和 Java 并无区别，这里就不再细述。</p>
<h2 id="3-JavaScript-变量特殊语法"><a href="#3-JavaScript-变量特殊语法" class="headerlink" title="3. JavaScript 变量特殊语法"></a>3. JavaScript 变量特殊语法</h2><ol>
<li><p>在一行 JavaScript 语句的结尾<code>;</code>可以被省略。（<strong>不建议省略</strong>）如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>和</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>   两种声明效果相同，也就是 JavaScript 中，换行符以及分号都能判断一行语句的结束。</p>
<ol start="2">
<li><p>变量的定义使用 <code>var</code>关键字，也可以不使用（<strong>不建议不使用</strong>）。两者的作用域不一样。</p>
<p>使用<code>var</code> 关键字定义的变量为局部变量，不使用 <code>var</code>关键字定义的变量为全局变量。</p>
<p><strong>注意：</strong> 在最新的 ECMAScript 6 （简称 ES6） 中，关键字 <code>let</code>、<code>const</code>被引入用来定义变量。其中 <code>let</code> 可定义普通变量，和 <code>var</code> 的区别仅仅在于其拥有 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqeV9hbmRyb2lkX2Jsb2cvYXJ0aWNsZS9kZXRhaWxzLzgwODYzNDI1">变量作用域<i class="fa fa-external-link-alt"></i></span>；而<code>const</code> 则用来定义常量，定义之后数据不可改变。更多细节可参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2VzNi1sZXQtY29uc3QuaHRtbA==">ES6 let 与 const | 菜鸟教程 (runoob.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lczYucnVhbnlpZmVuZy5jb20vI2RvY3MvbGV0">let 和 const 命令 - ECMAScript 6入门 (ruanyifeng.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><code>var</code> 的用法请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    变量的定义可以不使用var关键字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">4<span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    4<span class="comment">//用关键定义为局部变量，范围为函数体内</span></span><br><span class="line">    4<span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">    4<span class="comment">//不用关键字定义，范围为全局</span></span><br><span class="line">        b = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>();</span><br><span class="line">    <span class="comment">//变量a不会输出</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(b);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(a);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>在函数体内用<code>var</code>关键字定义的变量a作用域为函数体内，在函数外无法使用；而不使用var关键字定义的变量b 可以在函数体外使用。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9lczYucnVhbnlpZmVuZy5jb20vI2RvY3MvbGV0">let 和 const 命令 - ECMAScript 6入门 (ruanyifeng.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qcy9qcy10dXRvcmlhbC5odG1s">JavaScript 教程 | 菜鸟教程 (runoob.com)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript入门（二）：引入方式、数据类型和变量</title>
    <url>/2022/01/de9cb1ca5b5c.html</url>
    <content><![CDATA[<p>在前面的文章中，我们介绍了 JavaScript 心酸的发展历程，从开始的大乱斗，到后来的标准化……。</p>
<p>而目前我们所用的 JavaScript 是由三部分内容组成的：<strong>ECMAScript（标准） + DOM（文档对象） + BOM（浏览器对象）</strong>。</p>
<p>JavaScript 的基本语法和基本对象等都是来自于 ECMAScript 的 ,可以说 ECMAScript是 JavaScript 的核心部分。</p>
<p>在学习 JavaScript 时，我们先从 ECMAScript 中开始讲起，也就是 JavaScript 的核心部分：<strong>基本语法和基本对象。</strong></p>
<span id="more"></span>

<h2 id="JavaScript-基本语法"><a href="#JavaScript-基本语法" class="headerlink" title="JavaScript 基本语法"></a>JavaScript 基本语法</h2><p>JavaScript 的语法和 Java 有许多近似之处，所以如果你是一个有过 Java 基础的同学，学起来其实并不会很累。</p>
<h3 id="1-JavaScript-与-HTML-的结合方式"><a href="#1-JavaScript-与-HTML-的结合方式" class="headerlink" title="1. JavaScript 与 HTML 的结合方式"></a>1. JavaScript 与 HTML 的结合方式</h3><p>与 CSS 代码一样，JavaScript 的代码也有多种方式可以和 HTML 进行结合。</p>
<p>而不管是什么方式结合，在 HTML 中声明 JavaScript 的方式都需要通过<code>&lt;script&gt;&lt;/script&gt;</code>标签。</p>
<p>声明 JavaScript 的两种方式如下：</p>
<ul>
<li><p>HTML 内部 JavaScript ，即 JavaScript 代码直接写在 HTML 文件内，在<code>&lt;script&gt;</code>标签内编写JS代码。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- alert() 方法用于显示带有一条指定消息和一个确定按钮的警告框。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101709430.png"></p>
<p>这是Chrome浏览器的显示效果，在不同的浏览器中显示样式不同，但是效果都是一个警告框。</p>
<p>在 Microsoft 的旧版 Edge 浏览器上，显示效果为：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101709050.png"></p>
</li>
<li><p>外部 JavaScript 。和外部引入 CSS 类似，即 JavaScript 代码编写在独立的且后缀为<code>.js</code>的文件中，然后通过<code>&lt;script&gt;&lt;/script&gt;</code>标签中的 <code>src</code> 属性进行引用。</p>
<p>示例：</p>
<p>新建一个 <code>js</code>文件夹用于存放所有的 <code>JavaScript</code> 文件，然后新建一个名为<code>js_combine.js</code>的文件，将以下内容粘贴：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;外部的Hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后在 HTML 的<code>&lt;script&gt;</code>标签中引用该文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- alert() 方法用于显示带有一条指定消息和一个确定按钮的警告框。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/js_combine.js&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101710956.png"></p>
</li>
</ul>
<p><span style="color:red"><strong>注意事项：</strong></span></p>
<ol>
<li><code>&lt;script&gt;</code>标签的声明可以在 HTML 文档的任何位置，甚至包括<code>&lt;html&gt;&lt;/html&gt;</code>标签外。</li>
<li><code>&lt;script&gt;</code>标签声明的位置会影响 JavaScript 代码执行的时刻。JavaScript 代码的执行和 HTML 元素的渲染在同一个序列中， HTML 从上到下解析，当解析到 <code>&lt;script&gt;</code> 标签时候，才会执行对应的 JavaScript 代码。所以要注意<code>&lt;script&gt;</code>标签放置的位置。</li>
<li><code>&lt;script&gt;</code>标签声明在<code>&lt;html&gt;&lt;/html&gt;</code> 标签外时，浏览器会优先执行该<code>&lt;script&gt;</code>标签中的内容。</li>
<li>在默认情况下，当我们要使用 JavaScript 修改 HTML 元素时，我们应将 JavaScript 代码声明在<code>&lt;html&gt;&lt;/html&gt;</code>标签内，且在最尾端，这个位置代表前面的 HTML 元素已经渲染完成，此时修改 HTML 元素才为最佳。</li>
</ol>
<h3 id="2-JavaScript-注释"><a href="#2-JavaScript-注释" class="headerlink" title="2. JavaScript  注释"></a>2. JavaScript  注释</h3><p>每一种语言都拥有注释的功能，JavaScript 的注释的使用方法和 Java 近似，分为以下两种：</p>
<ul>
<li><p>单行注释，和 Java 一样使用 <code>//</code></p>
</li>
<li><p>多行注释，也和 Java 一样，使用<code>/*....*/</code></p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//单行注释</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            多</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            注</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            释</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-JavaScript-变量-数据类型"><a href="#3-JavaScript-变量-数据类型" class="headerlink" title="3. JavaScript 变量&amp;数据类型"></a>3. JavaScript 变量&amp;数据类型</h3><h4 id="3-1-强类型语言和弱类型语言"><a href="#3-1-强类型语言和弱类型语言" class="headerlink" title="3.1 强类型语言和弱类型语言"></a>3.1 强类型语言和弱类型语言</h4><p>强类型语言，即不允许隐式变量类型转换，变量在在定义时就确定了数据类型，变量所处的内存空间也就只能存储该数据类型的值。</p>
<p>Java 就是一种典型的强类型语言。如果在 Java 代码中声明了一个变量为整型（int），那么其肯定不能赋值为字符串：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101710211.png"></p>
<p>与强类型语言相对的就是弱类型语言，弱类型语言的变量允许隐式变量类型转换，变量在定义时没有明确的数据类型，变量所处的内存空间可以存储多种数据类型的值。</p>
<p>而 JavaScript 就是一种弱类型语言。使用 JavaScript 将字符串转为数字类型非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//直接进行赋值操作即可将str的数据类型转换为数字类型</span></span><br><span class="line">str = <span class="number">111</span>;</span><br></pre></td></tr></table></figure>

<p>在弱类型语言中，变量的类型不固定，你想让其成为什么类型，它就能成为什么类型，语言的解释器会自动将数据类型进行隐式转换。</p>
<h4 id="3-2-JavaScript-数据类型"><a href="#3-2-JavaScript-数据类型" class="headerlink" title="3.2 JavaScript 数据类型"></a>3.2 JavaScript 数据类型</h4><p>和 Java 一样， JavaScript 中也将数据类型分为两个种类。一类是原始数据类型（基本类型），一类是引用数据类型（对象）。它们的内容如下：</p>
<ul>
<li>原始数据类型<ul>
<li>number	  数字类型。包括整数，小数 ，以及一个特殊数 <strong>NaN</strong>（ Not a Number：不是数字）。</li>
<li>string         字符串类型。包括字符&#x2F;字符串 ，声明时使用 “123” 和 ‘123’ 都是可行的。</li>
<li>boolean     布尔类型。 true 或 false。</li>
<li>null             对象为空，但其实是个 Bug。</li>
<li>undefined   未定义。 当变量定义时没有设定默认值，变量的数据类型即为 undefined，变量的值也就为 undefined。</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>基本对象、BOM（浏览器对象）、DOM 对象（文档对象）。</li>
</ul>
</li>
</ul>
<p>我们其实并不用强行去记这些类型，通过日常使用久了，自然就能够懂了。</p>
<p>下面我们通过声明不同的变量来逐一介绍各种数据类型。</p>
<h4 id="3-3-JavaScript-变量"><a href="#3-3-JavaScript-变量" class="headerlink" title="3.3 JavaScript 变量"></a>3.3 JavaScript 变量</h4><p>在 JavaScript 中，由于 JavaScript 为弱类型语言，变量没有固定的数据类型，定义时可不指定数据类型关键字，统一用<code>var</code>关键字来定义。定义一个变量的语法格式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = 初始化值;</span><br></pre></td></tr></table></figure>

<p>下面是相应数据类型的变量定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//定义 number 数字类型 ，包括整数，小数 ，以及一个特殊数NaN(Not a Number : 不是数字)。</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">1.2</span>;</span><br><span class="line">    <span class="keyword">var</span> num3 = <span class="title class_">NaN</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义 string  字符串类型。包括字符/字符串 ，声明时使用 &quot;123&quot; 和 &#x27;123&#x27; 都是可行的。</span></span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="string">&quot;a&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> str3 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义 boolean  布尔类型。 true 或 false</span></span><br><span class="line">    <span class="keyword">var</span> bol1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> bol2 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义 null</span></span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义undefined 当变量定义时没有默认值，变量的数据类型为undefined，变量值为undefined</span></span><br><span class="line">    <span class="keyword">var</span> ud1 = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">var</span> ud2;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>document</code>对象将上述声明的变量打印到网页上，在代码中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用document对象中的write方法将变量逐个输出网页上显示</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num3 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str3 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(bol1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(bol2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(obj1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(ud1 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(ud2 + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果和上面对应：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101710670.png"></p>
<p><span style="color:red"><strong>注意：</strong></span></p>
<ol>
<li><p>在JavaScript中，您可以同时声明两个相同的变量，而且不会报错，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>但是在内存中只会存在于一个变量名的内存空间：</p>
<blockquote>
<p>JavaScript 从来不会告诉你是否多次声明了同一个变量，遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）</p>
</blockquote>
<p>也就是说，上面的语句等效于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line">x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>可以理解为后面的重复的定义会把前面的定义覆盖，效果就相当于赋值操作。</p>
</li>
<li><p>不同函数内的局部变量可以相同，而且函数与函数之间不受影响。</p>
</li>
<li><p>在函数中的声明的变量名和全局变量名重名时，函数内优先使用局部变量。</p>
</li>
</ol>
<h4 id="3-4-使用-typeof-运算符判断变量的数据类型"><a href="#3-4-使用-typeof-运算符判断变量的数据类型" class="headerlink" title="3.4 使用 typeof 运算符判断变量的数据类型"></a>3.4 使用 typeof 运算符判断变量的数据类型</h4><p>在刚才的示例中，我们知道，JavaScript 为弱类型语言，变量的定义声明都使用<code>var</code>关键定，而且变量可以自由变换为多种数据类型，变量的使用变的非常的简便。但是这样的设定也存在一些问题。</p>
<p>在 Java 中，我们定义不同数据类型的变量时要使用不同的关键字，如字符串使用 String，整型使用 int，这样我们在使用时可以很清楚的知道某个变量的数据类型。</p>
<p>而在 JavaScript 中，定义变量时并不指定数据类型，都使用 <code>var</code> 关键字，我们无法直接判断出某个变量的数据类型。</p>
<p>为了应对这个问题，在JavaScript中提供了一个运算符 <strong>typeof</strong> 用来判断某个变量的数据类型，其语法格式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(变量名);</span><br></pre></td></tr></table></figure>

<p><strong>typeof</strong> 运算符执行后会返回一个字符串类型的变量，描述该变量的数据类型。</p>
<p>为了演示 <strong>typeof</strong> 运算符的效果，修改上面<code>document</code>对象打印内容的代码，在每个变量打印后面添加 **typeof **判断后的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用document对象中的write方法逐个输出网页上显示，同时显示它们对应的数据类型</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num1 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(num1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num2 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(num2) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(num3 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(num3) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str1 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(str1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str2 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(str2) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str3 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(str3) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(bol1 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(bol1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(bol2 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(bol2) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(obj1 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(obj1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(ud1 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(ud1) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(ud2 + <span class="string">&quot;--数据类型：&quot;</span> + <span class="title function_">typeof</span>(ud2) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101710163.png"></p>
<p>可以看到每个变量的数据类型都对应相应的名称，但是注意一个变量值 null，其使用 <strong>typeof</strong> 得出的是 object (对象）数据类型。但是我们在前面提过， null 和 undefined 一样，都是一种原始数据类型，null 值对应的数据类型应该是 <code>nul</code>l。</p>
<p>要解释这个问题比较复杂，其实这是 JavaScript 在设计之初的一个Bug，下面引用 W3C 对这个问题的解释：</p>
<blockquote>
<p><strong>注释：</strong>您也许会问，为什么 typeof 运算符对于 null 值会返回 “Object”。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。</p>
</blockquote>
<p>也就是说 null 依旧是一种数据类型，可以理解为对象 Object 数据类型包括了 null 数据类型，null 值作用与对象，表示对象为空。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzL2luZGV4LmFzcA==">W3C-JavaScript教程<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVjaGVuZzYvcC85NjkwMzQwLmh0bWw=">JS中创建多个相同的变量出现的问题<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之路：安装 JDK 1.8</title>
    <url>/2019/12/100f4e51e436.html</url>
    <content><![CDATA[<p>不管是运行<code>tomcat</code>还是使用各种<code>Java</code>的服务，<code>JDK</code> 都是必不可少的。但是在 Linux 服务器上，安装 <code>JDK</code> 并不容易。</p>
<p>本篇文章就介绍如何在 Linux 下安并配置 <code>JDK1.8</code></p>
<span id="more"></span>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>文章中的命令都是在 root 用户权限下执行的，操作之前，请确保能使用root用户的权限。</p>
<p>如果是普通用户，请在命令前加 <code>sudo</code></p>
</blockquote>
<h3 id="1-下载-JDK-1-8-x64"><a href="#1-下载-JDK-1-8-x64" class="headerlink" title="1. 下载  JDK 1.8 x64"></a>1. 下载  JDK 1.8 x64</h3><p>要安装 <code>JDK</code>，首先需要下载安装包。而和 <code>Windows</code> 下不同，<code>Linux</code> 的包依赖关系很复杂，直接使用安装包安装大概率是会出现依赖问题的，为了避免出现不必要的错误，我推荐直接使用压缩包的方式手动配置安装。</p>
<p>关于 <code>JDK1.8</code> 的下载地址，我这里收集了几个，随机选择一个就可以：</p>
<ul>
<li>官方：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamF2YS5jb20vemgtQ04vZG93bmxvYWQvbWFudWFsLmpzcA==">适用于所有操作系统的 Java 下载<i class="fa fa-external-link-alt"></i></span></li>
<li>华为镜像：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9qYXZhL2pkay84dTE1MS1iMTIv">Index of java-local&#x2F;jdk&#x2F;8u151-b12 (huaweicloud.com)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>进入页面中可以看到很多文件，我们是在 <code>Linux</code> 下安装的，我们选择带 Linux ，64 标记的版本，如果有后缀，记得是 <code>.tar.gz</code> 的。在自己电脑上下载好后，可以通过 <span class="exturl" data-url="aHR0cHM6Ly93d3cub25saW5lZG93bi5uZXQvc29mdC8xMDc0OTQ2Lmh0bQ==">Xftp<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93aW5zY3AubmV0L2VuZy9pbmRleC5waHA=">WinSCP<i class="fa fa-external-link-alt"></i></span> 等工具将下载好的文件传到 <code>Linux</code> 服务器上，这种方式比较繁琐，我不再赘述。</p>
<p>其实如果怕麻烦，可以直接选择以下命令的任何一条，在 Linux 的终端中运行，直接下载到 Linux 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/java/jdk/8u151-b12/jdk-8u151-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://javadl.oracle.com/webapps/download/AutoDL?BundleId=245797_df5ad55fdd604472a86a45a217032c7d</span><br></pre></td></tr></table></figure>

<p>不管是上传的还是命令下载的，最终我们需要目录下有一个 <code>.tar.gz</code> 后缀的压缩包：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1//others20210308095035.png"></p>
<p>至此，下载完成。</p>
<h3 id="2-配置存放目录"><a href="#2-配置存放目录" class="headerlink" title="2. 配置存放目录"></a>2. 配置存放目录</h3><p>在 <code>Windows</code> 下，每个软件都有一个安装目录，在 <code>Linux</code> 下，用户软件一般都是安装在 <code>/usr/local/</code> 下，为了方便寻找，我们将 <code>JDK</code> 文件都存放到这个目录。</p>
<p>回到我们的 Linux 终端窗口 ，在 <code>/usr/local/</code>目录下新建 <code>java</code>文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/java</span><br></pre></td></tr></table></figure>

<p>将上文中下载好的压缩文件中的内容解压到该文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf jdk-8u151-linux-x64.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure>

<p>进入该文件夹，查看解压完成后的文件信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/java</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l jdk1.8.0_151</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1//others20210308095419.png"></p>
<p>可以看到 <code>JDK</code> 相关的文件都在这里。</p>
<h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><p>给Linux中配置环境变量有多种方法，如果有想了解的可以查看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veW91eW91aS9wLzEwNjgwMzI5Lmh0bWw=">Linux中配置环境变量<i class="fa fa-external-link-alt"></i></span></p>
<p>这里我们使用修改系统配置文件的方法。</p>
<p>使用 vim 编辑 <code>/etc/profile</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>按键盘字母  <code>i</code>  进入编辑模式，光标滑到文件最后，在文本末尾加上如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置JAVA环境变量，格式如下</span></span><br><span class="line"><span class="comment">#JAVA_HOME=your jdk home</span></span><br><span class="line"><span class="comment">#PATH=$JAVA_HOME/bin:$PATH #CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="comment">#export PATH JAVA_HOME CLASSPATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置JAVA环境变量</span></span><br><span class="line"><span class="comment">#注意这里的 JAVA_HOME 路径替换为你解压的路径</span></span><br><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_151</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/jre/lib/ext:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1//others20210308095817.png"></p>
<p>确认无误后，按 <code>esc</code>键 ，输入<code>:wq</code> ，再按 <code>Enter</code> 保存。</p>
<p>最后回到控制台，使用<code>source /etc/profile</code> 让 更改的 <code>profile</code> 文件立即生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="3-检查效果"><a href="#3-检查效果" class="headerlink" title="3. 检查效果"></a>3. 检查效果</h3><p>在 Linux 终端分别执行 <code>java</code> ， <code>javac</code> <code>java -version</code>查看效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152950.png"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152959.png"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1//others20210308100014.png"></p>
<p> 大功告成！！！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Java - Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之路：Centos安装 Docker</title>
    <url>/2020/02/c003aa798f14.html</url>
    <content><![CDATA[<p>Docker 提供轻量的虚拟化，你能够从 Docker 获得一个额外抽象层，你能够在单台机器上运行多个Docker微容器。</p>
<p>而每个微容器里都有一个微服务或独立应用，例如你可以将Tomcat运行在一个Docker，而MySQL运行在另外一个Docker。快速启动，易于弹性伸缩和拓展等特性使得 Docker 发展飞速。</p>
<p>本篇我们就介绍如何在 Centos 上安装docker</p>
<span id="more"></span>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>文章中的命令都是在 root 用户权限下执行的，操作之前，请确保能使用root用户的权限。</p>
</blockquote>
<h3 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h3><p>Docker 从 2013 年 3 月 20 日发布 <strong>Docker0.1</strong>，到现在已经发布了多个版本，从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: <strong>DockerCE</strong> 和 <strong>DockerEE</strong>。</p>
<p>官网 ：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=">https://www.docker.com/<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>DockerCE</strong> 即社区免费版，可永久免费使用；<br><strong>DockerEE</strong> 即企业版，功能更全，更强调安全，但需付费使用；</p>
<p>对于普通用户，我们只需使用 <strong>DockerCE</strong> 就可以了。</p>
<p>首先，要在<strong>centos</strong>上运行docker，您必须确定您的系统版本为 7.x，通过以下命令可以查看当前系统版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152105.png">如果系统为6.x，建议先升级到7.x。</p>
<blockquote>
<p>PS：如果您以前安装过docker，建议您先把旧版移除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2. 开始安装"></a>2. 开始安装</h3><ol>
<li><p>更新软件包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>


</li>
<li><p>安装一些必要的工具。安装 <code>yum-utils</code>，它提供一个 <code>yum-config-manager</code> 单元，同<br>时安装的<code>device-mapper-persistent-data</code>和 <code>lvm2</code> 用于储存设备映射<code>（devicemapper）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">ps:-y 表示遇到要输入<span class="built_in">yes</span> or no？时候默认为<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>配置docker软件源仓库，这里建议使用阿里云的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152210.png"></p>
</li>
<li><p>安装最新版<code>docker-ce</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Docker 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Docker 服务状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>如果能看到如下结果 <code>绿色单词</code>  则代表安装并启动成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152234.png"></p>
</li>
</ol>
<h3 id="3-配置国内镜像源"><a href="#3-配置国内镜像源" class="headerlink" title="3. 配置国内镜像源"></a>3. 配置国内镜像源</h3><p>如果是接触过 linux 的比较清楚，大多数系统的默认软件源都在国外，下载很慢。</p>
<p>Docker也是如此，所以我强烈建议您配置国内的镜像源</p>
<p>1、 国内镜像源加速站点</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5kb2NrZXItY24uY29tLw==">https://registry.docker-cn.com<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2h1Yi1taXJyb3IuYy4xNjMuY29tLw==">http://hub-mirror.c.163.com<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3IuY2NzLnRlbmNlbnR5dW4uY29tLw==">https://mirror.ccs.tencentyun.com<i class="fa fa-external-link-alt"></i></span></p>
<p>如果想使用阿里云的加速，需要注册账号，具体可参考阿里的官方教程：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzYwNzUwLmh0bWw/c3BtPTUxNzYuMTA2OTU2NjIuMTk5NjY0NjEwMS5zZWFyY2hjbGlja3Jlc3VsdC4yN2UyNzNkNGhkNmFlRCZhbHlfYXM9UHZOc1NVNkI=">官方镜像加速<i class="fa fa-external-link-alt"></i></span></p>
<p>2、使用命令来配置加速站点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#以下内容建议手打或者单独复制，避免出现错误</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://j3qp5gr4.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用脚本来配置加速站点</p>
<p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -sSL https://raw.githubusercontent.com/wss434631143/xiaoshujiang/master/articles/Docker/shell/set_mirror.sh | sh -s &lt;your accelerate address&gt;</span><br></pre></td></tr></table></figure>


<p>3、以上操作后重新加载daemon并重启 Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>docke info</code> 查看docker信息，在最下面可以看到你配置的docker的镜像地址</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152259.png"></p>
<p>4、测试</p>
<p>配置好之后我们测试拉取一个镜像，比如<code>mysql</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<p>根据网速，一般来说十来秒就可以下载完成，配置成功。</p>
<h3 id="3-基本命令和配置"><a href="#3-基本命令和配置" class="headerlink" title="3. 基本命令和配置"></a>3. 基本命令和配置</h3><p>大多数时候，我们都不想每次启动服务器手动启动服务，我强烈推荐将docker服务设为自启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Docker-服务信息查看"><a href="#3-2-Docker-服务信息查看" class="headerlink" title="3.2 Docker 服务信息查看"></a>3.2 Docker 服务信息查看</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -v 查看版本</span><br><span class="line">docker info 运行 docker 后查看，查看 docker 系统信息</span><br><span class="line">docker version 运行 docker 后查看</span><br><span class="line">docker 查看所有的帮助</span><br><span class="line">docker commond （如 stop）--<span class="built_in">help</span> 查看某个 commond 命令的帮助信息</span><br></pre></td></tr></table></figure>

<h4 id="3-3-测试运行HELLO-WORLD"><a href="#3-3-测试运行HELLO-WORLD" class="headerlink" title="3.3 测试运行HELLO-WORLD"></a>3.3 测试运行HELLO-WORLD</h4><p>拉取镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>

<p>运行镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>运行成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152319.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之路：Centos安装 MySQL</title>
    <url>/2020/02/fb9556222bce.html</url>
    <content><![CDATA[<p><code>MySQL</code> 是最流行的关系型数据库管理系统，在 WEB 应用方面 <code>MySQL</code> 是最好的 <code>RDBMS(Relational Database Management System</code>：关系数据库管理系统)应用软件之一。</p>
<p>本节，我们介绍<code>Centos</code>中安装 <code>MySQL</code>  。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="卸载可能冲突的mariadb"><a href="#卸载可能冲突的mariadb" class="headerlink" title="卸载可能冲突的mariadb"></a>卸载可能冲突的mariadb</h3><p>MariaDB是MySQL源代码的一个分支，有些系统可能安装过此程序，为了避免冲突，必须先卸载。</p>
<p>1.查询安装了是否mariadb,获取mariadb的包名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></table></figure>

<p>2.卸载mariadb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rpm -e mariadb-libs-5.5.64-1.el7_5.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>接下来我以Centos7 (el7) ,  MySQL 5.7 (MySQL57) 为例，完成MySQL的安装.</p>
<h3 id="寻找yum源文件"><a href="#寻找yum源文件" class="headerlink" title="寻找yum源文件"></a>寻找yum源文件</h3><p>通常来说，我都建议通过CentOS的<code>yum</code>命令来安装MySQL，这样可以减去很多依赖的麻烦。</p>
<p>为了能在<code>yum</code>中搜索到MySQL，首先我们得导入MySQL的 yum 源。</p>
<p>进入如下网站：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://repo.mysql.com/</span><br></pre></td></tr></table></figure>

<p>可以看到在这有很多源文件，他们分别作用于不同系统不同版本，需要注意的是我们的系统是<code>Centos</code>，对应的代号是<strong>el</strong> <code>(Red Hat E nterprise L inux(EL))</code></p>
<p>如图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152427.png"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152440.png"></p>
<p><strong>其中前面的 mysql57 、 mysql80 分别代表 mysql5.7 版本和 8.0 版本，后面的 el5、el6、el7….. 分别代表 <code>Centos</code> 的系统版本，安装之前，请按自己的系统版本选择对应的 rpm 源文件。</strong></p>
<blockquote>
<p>Centos中查看系统版本的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
</blockquote>
<p>选定好对应的系统版本和 MySQL 版本后，鼠标右击指定的文件，选择 <strong>复制链接&#x2F;复制链接地址</strong>。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619201959.png" alt="image-20210619201951914"></p>
<h3 id="1、下载安装源文件"><a href="#1、下载安装源文件" class="headerlink" title="1、下载安装源文件"></a>1、下载安装源文件</h3><p>在命令行中，将刚才复制的链接地址粘贴到 <code>wget</code> 命令后，使用 <code>wget</code> 命令下载 <code>yum</code> 源文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql57-community-release-el7.rpm</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152533.png"></p>
<p>然后使用rpm安装此源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7.rpm</span><br></pre></td></tr></table></figure>

<p>安装完成之后，会在 <code>/etc/yum.repos.d/</code> 目录下新增 <code>mysql-community.repo 、mysql-community-source.repo</code> 两个 yum 源文件。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152544.png"></p>
<p>此时我们可以查看mysql 的yum安装包，各种版本的都在其中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152555.png"></p>
<p><strong>如果您想要修改默认安装的yum安装包(mysql版本)，请按如下步骤操作，如果不想，请跳过</strong>：</p>
<blockquote>
<p>在上图中，我们可以看到列出的安装包中，<code>mysql57-community</code> 为 enabled（启用） ，这代表默认安装则为mysql5.7 版本，而有时候我们可能需要更新或者说需要安装更高版本的mysql，此时我们就需要更改默认的安装包。</p>
<p>修改成mysql8.0：</p>
<ol>
<li><p>安装 <code>yum-utils</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>yum-config-manager --disable mysql57-community</code>来取消 mysql57-community的默认安装</p>
</li>
<li><p>然后使用<code>yum-config-manager --enable mysql80-community</code>来使能 mysql80-community成为yum默认安装版本。</p>
</li>
</ol>
</blockquote>
<h3 id="2、执行安装"><a href="#2、执行安装" class="headerlink" title="2、执行安装"></a>2、执行安装</h3><p>安装 mysql-community-server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152609.png"></p>
<p>安装 mysql-devel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-devel</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152629.png"></p>
<p>查看服务状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152643.png"></p>
<p>如能显示出服务信息，代表已经安装成功。</p>
<h3 id="3、进入mysql"><a href="#3、进入mysql" class="headerlink" title="3、进入mysql"></a>3、进入mysql</h3><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS:设置为自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure>

<p>获取临时密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/mysqld.log | grep password</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152705.png"></p>
<p>登录进入mysql（密码为获取到的临时密码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>登录成功效果</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107152714.png"></p>
<h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>建议进入之后，建议立刻修改mysql的密码，具体如何操作，请使用666法则。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之路：Centos安装 Tomcat</title>
    <url>/2021/06/225722d67a52.html</url>
    <content><![CDATA[<p>Java Web 开发有三件秘宝：<code>JDK</code>、<code>MySQL</code>、<code>Tomcat</code>。一般来说，开发时我们会将这些组件都安装到我们的本机电脑中，这使得我们开发更为便捷。然而实际情况中，<code>Tomcat</code>，<code>MySQL</code> 等往往都是安装在服务器中，而服务器大多采用 <code>Linux</code> 系统，其中以<code>CentOS</code>居多。于是，学习在 <code>CentOS</code> 系统中安装三件套势在必行。</p>
<p>在之前，笔者已经给出<code>JDK</code>，<code>MySQL</code> 在<code>CentOS</code>的安装方式：</p>
<p>今天我们就了解在<code>CentOS</code>中安装 <code>Tomcat</code>、并发布 <code>Web</code> 项目到其中，同时适用于其他<code>Linux</code>系统的操作。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>若要优雅的阅读并使用本文中的内容，请确定您已经知晓：</p>
<ul>
<li>使用SSH连接到Linux服务器</li>
<li>Linux中已经 <span class="exturl" data-url="aHR0cHM6Ly93d3cucWlhbmZhbmd1b2ppbi50b3AvMjAxOS8xMi8xOS9MaW51eCVFNCVCOSU4QiVFOCVCNyVBRiVFRiVCQyU5QUNlbnRvcyVFNSVBRSU4OSVFOCVBMyU4NWpkazEuOC8jbW9yZQ==">安装并配置好JDK环境变量<i class="fa fa-external-link-alt"></i></span></li>
<li>会使用 wget 命令下载文件</li>
<li>基本的Linux命令，以及操作</li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="1-作者提供"><a href="#1-作者提供" class="headerlink" title="1. 作者提供"></a>1. 作者提供</h3><p>😁若是怕麻烦，可以从作者君这里的 <span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9qaXVuaWFuXzI3NjEvMTg5MTIxNDc=">Tomcat9 下载<i class="fa fa-external-link-alt"></i></span> 直接下载 ，支持卑微的作者。</p>
<p>下载完到本地 <code>Windows</code> 中，找到下载好的文件，它应该是一个压缩包，名称如下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520181051273.png" alt="image-20210520181051273"></p>
<p>记住这个压缩包的所在的文件夹，打开 <code>XShell</code> 或任意一款 <code>SSH</code> 工具，连接到 <code>CentOS</code> 中：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520181441451.png" alt="image-20210520181441451"></p>
<p>输入上传文件的命令 <code>rz -be</code>，点按 <code>Enter</code> ，会弹出选择文件的选择框：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520183319577.png" alt="image-20210520183319577"></p>
<blockquote>
<p>有些CentOS&#x2F;Linux系统可能会出现 <strong>command not found</strong>，提示命 <strong>rz</strong>令未找到，这是由于系统中没有安装此命令的原因，此时我们只需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install lrzsz</span><br></pre></td></tr></table></figure>

<p>安装一下就好了</p>
</blockquote>
<p>找到刚刚下载的 <code>Tomcat9</code> 的压缩文件，选择此文件，文件会自动上传到当前所处文件夹:</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520202828489.png" alt="image-20210520202828489"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520202903030.png" alt="image-20210520202903030"></p>
<h3 id="2-从镜像网站"><a href="#2-从镜像网站" class="headerlink" title="2. 从镜像网站"></a>2. 从镜像网站</h3><p>若上述方式不满意，我建议选择镜像网站 <code>wget</code> 直接下载到 <code>Linux</code> 中。</p>
<p>先进入任意一个镜像网站，这里我选择清华大学的 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2FwYWNoZS90b21jYXQv">TUNA镜像站<i class="fa fa-external-link-alt"></i></span>，逐级寻找目录，找到 <code>apache-tomcat-9.0.xx.tar.gz</code> 文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520205440902.png" alt="image-20210520205440902"></p>
<p>右键点击该项，选择复制链接：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520205928056.png" alt="image-20210520205928056"></p>
<p><span id="jump1">接着</span>回到命令行，首先获取 <code>root</code> 权限，再使用 <code>wget</code> + <code>复制的链接</code> 下载该文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520212719576.png" alt="image-20210520212719576"></p>
<h3 id="3-从官网"><a href="#3-从官网" class="headerlink" title="3. 从官网"></a>3. 从官网</h3><p>一般来说，特别是对于软件开发来说，软件最好是从官方渠道下载，这样可以避免软件的篡改等等。</p>
<p>对于<code>Tomcat</code>，由于其是 <code>Apache</code> 国外开源基金会的产品，服务器在国外，没有科学操作之前，下载可能较慢，但我们还是需要这个过程。</p>
<p>首先打开 <span class="exturl" data-url="aHR0cHM6Ly90b21jYXQuYXBhY2hlLm9yZy8=">Apache Tomcat官网<i class="fa fa-external-link-alt"></i></span> ，在左侧 <code>Download</code>中，点击选择指定的版本，这里我建议选择 <code>Tomcat9</code>，因为实现在<code>JDK8</code>，这也是目前建议的版本。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520175044385.png" alt="image-20210520175044385"></p>
<p>选择 Core 中的 <code>tar.gz</code> 版本，右键复制链接（不要点到后面的pgp，sha512）：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520175422955.png" alt="image-20210520175422955"></p>
<p>随后回到命令行，按照 <a href="#jump1">点击此处</a> 的方法，使用 <code>wget</code> 命令下载即可。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>获取 <code>root</code> 权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>将下载的此文件解压到 <code>/opt/</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf apache-tomcat-9.0.46.tar.gz -C /opt/</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/ii.png"></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入启动文件夹目录 <code>/opt/apache-tomcat-9.0.46/bin</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/apache-tomcat-9.0.46/bin</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520213752976.png" alt="image-20210520213752976"></p>
<p>执行 <code>startup.sh</code>  , 启动 <code>Tomcat</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>

<p>若能看到如下图，则说明 <code>Tomcat</code>安装并启动成功</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520214033544.png" alt="image-20210520214033544"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>若是在服务器上，大多数时候，我们的 <code>Tomcat</code> 不会和我们在本地一样运行完就关闭。</p>
<p>接下来，我们则来配置如何将Tomcat设置为服务并自启动。</p>
<h3 id="设置服务"><a href="#设置服务" class="headerlink" title="设置服务"></a>设置服务</h3><p><code>Linux</code>系统中所有的服务都对应有一个脚本在 <code>/etc/init.d/</code> 目录下，新建一个服务也即新建一个脚本在该目录下。</p>
<p>这里，我们新建 <code>Tomcat</code>的启动脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/tomcat9</span><br></pre></td></tr></table></figure>

<p>将以下内容填写进入其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line">#chkconfig:2345 61 61</span><br><span class="line">####上行必须添加，才能使用chkconfig命令设为自启动，2345参数表示,在哪些运行级别启动,启动序号61;关闭序号61；两位数字即可</span><br><span class="line"></span><br><span class="line">### BEGIN TOMCAT SERVICE</span><br><span class="line">### END INIT INFO</span><br><span class="line"></span><br><span class="line">### 这里是你的环境变量，Java 环境变量配置自己安装的JDK目录</span><br><span class="line">### 详细可参照我前面的文章。</span><br><span class="line">export JAVA_HOME=/usr/work/jdk1.8.0</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.</span><br><span class="line">export CATALINA_HOME=/opt/opt/apache-tomcat-9.0.46</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">        exit 0</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">        exit 0</span><br><span class="line">        ;;</span><br><span class="line">debug)</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/catalina.sh run</span><br><span class="line">        exit 0</span><br><span class="line">        ;;</span><br><span class="line">force-reload|restart)</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">        $&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">        exit 0</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line">        echo &quot;Usage: /etc/init.d/tomcat9 &#123;start|stop|restart|force-reload|debug&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>修改文件为可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod o+x /etc/init.d/tomcat9</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520220848411.png" alt="image-20210520220848411"></p>
<p>执行服务并启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service tomcat9 start</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/image-20210520221139448.png" alt="image-20210520221139448"></p>
<h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><p>使用 <code>chkconfig</code> 命令添加为自启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add tomcat9</span><br></pre></td></tr></table></figure>

<h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><h3 id="系统内访问"><a href="#系统内访问" class="headerlink" title="系统内访问"></a>系统内访问</h3><p>若你安装的系统有GUI图形化界面，最简单且最方便的方式就是用默认浏览器访问 <code>http://127.0.0.1:8080</code>。</p>
<p>若没有，可以使用 <code>wget http://127.0.0.1:8080</code> ，若能获取到一个名为 <strong>index.html</strong> 的文件，则访问成功。</p>
<h3 id="外部主机访问"><a href="#外部主机访问" class="headerlink" title="外部主机访问"></a>外部主机访问</h3><p>如果你的系统安装在云服务器上，在本机电脑输入 <code>http://服务ip地址:8080</code>。</p>
<p>这有可能会访问不到，确定你的服务器安全组中放行了<code>8080</code> 端口，再次访问即可。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d5YnNoZW4vYXJ0aWNsZS9kZXRhaWxzLzc5NTY0NjEz">Linux tomcat作为服务开机自启动_Cloud-Future的博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos - Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MySQL的远程连接的一些总结</title>
    <url>/2021/06/edeac314c6a3.html</url>
    <content><![CDATA[<p>MySQL是目前非常流行的数据库之一，也是中小企业持久化存储的首选数据库。</p>
<p>本篇介绍如何远程连接 MySQL，以及在不同版本（5.x，8.x）上远程连接方式的不同。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不同于我们日常学习，在实际应用中，MySQL服务都会挂载在某台服务器上。如果MySQL部署在某台云服务器上，这样一来，操纵数据库每次都需要先连接服务器，再进入数据库操作，不是很方便。</p>
<p>于是，学习远程连接 MySQL 的方法是数据库在服务器上时的必修课。</p>
<p>但为了安全考虑，MySQL的远程连接并不是一键容易事，特别是在MySQL8.x版本时，下面会介绍到。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在这个阶段，确保你已经进入了你想要远程访问的数据库服务中，通常的界面如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619210426.png" alt="image-20210619210426836"></p>
<h2 id="放行远程主机访问"><a href="#放行远程主机访问" class="headerlink" title="放行远程主机访问"></a>放行远程主机访问</h2><p>通常来说，MySQL只允许用户在本地主机访问。通过查询 <code>user</code> 表，也可以看到允许的主机信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host,user from mysql.user</span><br></pre></td></tr></table></figure>

<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619211330.png" alt="image-20210619211330751"></p>
<p><code>host</code> 字段下面的 <code>localhost</code> 代表只接受本地主机。</p>
<p> 所以，我们的工作就很清晰了，就是修改访问权限信息，使得指定的用户能够接受远程访问。通常来说，我们有两种方式实现这个效果。</p>
<h3 id="第一种：改账号权限（建议）"><a href="#第一种：改账号权限（建议）" class="headerlink" title="第一种：改账号权限（建议）"></a>第一种：改账号权限（建议）</h3><p>既然远程主机没有权限连接，我们可以通过 GRANT 语句修改指定用户的权限。</p>
<p>GRANT 语句的语法大致为：<strong>GRANT 权限 ON 数据库对象 TO 用户</strong>。</p>
<p>授予对所有数据库操作的所有权限给<strong>任何主机</strong>（’%’）访问的 <code>root</code> 用户 ，这样任何连接到该数据库的root用户的能访问所有信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;你的密码&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>刷新权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>再次查询，可以发现会新增一条记录，<code>host</code> 字段下的 <code>%</code> 表示任何主机：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619215118.png" alt="image-20210619215118534"></p>
<p>如果只是想授予<strong>某个单独的主机</strong>访问权限，则 <code>%</code> 可以修改为指定的 IP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;172.16.28.71&#x27; IDENTIFIED BY</span><br><span class="line">&#x27;你的密码&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>效果类似：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619215641.png" alt="image-20210619215641750"></p>
<p>刷新权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h3 id="第二种：改表法"><a href="#第二种：改表法" class="headerlink" title="第二种：改表法"></a>第二种：改表法</h3><p>使用 GRANT 语句的方法是直接添加一条新记录，我个人建议按上面的方式做。</p>
<p>但是，我们同样可以采用直接修改 <code>user</code> 为 <code>root</code> 的<code>host</code> 字段内容，直接使用 <code>UPDATE</code> 语句修改表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>刷新权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>效果如图，直接修改 <code>host</code> 字段值，而不是添加。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619221211.png" alt="image-20210619221211627"></p>
<p>到这一步，大多数情况下，我们就可以使用数据库工具如：Web SQLyog、Navicat、Dbeaver等等连接上我们的远程数据库了。</p>
<h2 id="MySQL-8-x-的注意点"><a href="#MySQL-8-x-的注意点" class="headerlink" title="MySQL 8.x 的注意点"></a>MySQL 8.x 的注意点</h2><p><strong>但请注意，如果你的 MySQL 版本是 8.x的话，由于密码加密方式的不同，连接时可能会出现如下提示：</strong></p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210620164641.png" alt="image-20210620164641501"></p>
<p>因此，我们必须 <strong>修改加密方式</strong> 以实现远程连接，使用 <code>ALTER</code> 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>最后不要忘了刷新权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>OK，教程整体到这里就结束了，如果遇到什么问题，欢迎大家在评论区发表看法</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbHZtaW5nXzE5OTQwODE2L2FydGljbGUvZGV0YWlscy84MjE1MTc0NA==">mysql开启远程连接<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Navicat</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>为你的VMware 15.5 MacOS手动安装VMware Tools</title>
    <url>/2024/08/e0cc1f50f04c.html</url>
    <content><![CDATA[<p><strong>VMware Tools</strong> 是VMware软件提供的一个辅助工具，可以提升虚拟机的使用体验，默认伴随虚拟机自动安装，但有时候自动安装会出错。</p>
<p>本篇就介绍我们如何手动安装支持 MAC OS X 的 VMware Tools。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天，偶然在网上看到一个VMware 虚拟机安装MAC OS X 的教程：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy51c2JtaS5jb20vMzkxMC5odG1s">http://www.usbmi.com/3910.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>安装的过程是非常顺利的，但是当我满心欢喜的打开系统时，发现在虚拟机下，拖动鼠标具有明显的掉帧现象，不能实现全屏也就是调节分辨率，也不支持传输文件。</p>
<p>于是我咨询了万能的百度，发现是需要安装 VMware Tools ，于是我在VMware 软件中点击安装VMware Tools 的选项，然而却弹出：</p>
<blockquote>
<p>无法在更新服务器上找到组件。请联系VMware技术支持或您的系统管理员。</p>
</blockquote>
<p>查询了一下资料，发现在VMware 上安装的Mac OSX 安装 VMware Tools 需要用到一个<strong>darwin.iso</strong> 的文件，这款软件包括了虚拟机、硬件、驱动等和主机间进行沟通，并且进行支持！安装原版虚拟机不带此镜像文件的，必须自行下载！</p>
<p>许多文章都只是介绍了如何在虚拟机下安装MACOS，并没有告诉我们<strong>darwin.iso</strong>在哪里下载，MacOS 中的 VMware Tools 如何安装？这也就是我写这篇文章的目的。</p>
<h2 id="1、为什么需要安装VMware-Tools"><a href="#1、为什么需要安装VMware-Tools" class="headerlink" title="1、为什么需要安装VMware Tools"></a>1、为什么需要安装VMware Tools</h2><p><strong>VMware Tools</strong>是VMware软件提供的一个辅助工具，支持多种操作系统，其中的实用程序可以提高虚拟机中客户机操作系统的性能和改善虚拟机管理。</p>
<p>在虚拟机中的MAC OS X 中，<strong>VMware Tools</strong>  可以提高鼠标操作的流畅度，实现全屏显示，文件共享…..等等多种优化，为了更优雅的食用MAC OSX，安装VMware Tools还是很有必要的。</p>
<h2 id="2、获取Darwin文件"><a href="#2、获取Darwin文件" class="headerlink" title="2、获取Darwin文件"></a>2、获取Darwin文件</h2><p>在VMware 上安装的Mac OSX 安装 VMware Tools 需要用到一个叫<strong>darwin.iso</strong> 的文件。</p>
<p>如果是使用了unlocker 破解VMware ，unlocker会帮你下载一个最新版的 <strong>darwin.iso</strong> ，并复制到 VMware Tools 的根目录，但是由于官方源的不稳定，可能会失效，有时候需要我们手动安装。</p>
<p>我们可以先检查一下当前VM根目录是否有该文件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202405141123227.png"></p>
<p>如果已经有了这个文件，那么请直接跳转到下一节开始安装。</p>
<p>如果和我一样，安装根目录并没有这个文件，那么我们就需要下载这个文件，这个文件会随着</p>
<p><strong>VMware Tools</strong> 的更新而一直更新，最新版本为 11.0，可以在这个网站上下载：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3NvZnR3YXJldXBkYXRlLnZtd2FyZS5jb20vY2RzL3Ztdy1kZXNrdG9wL2Z1c2lvbi8=">http://softwareupdate.vmware.com/cds/vmw-desktop/fusion/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>找到最新的版本号，下载 packge 目录下具有 darwin文件的压缩包：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202405141124234.png"></p>
<p>下载下来是一个压缩文件，逐级打开压缩文件，在payload目录中可以找到<strong>darwin.iso</strong>文件，将其解压并放到VMware的安装根目录，也就是上文图片中的位置。</p>
<p><strong>由于是外国网站，如果遇到下载出错等问题的的话，可以从这里下载 <span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2Rvd25sb2FkL2ppdW5pYW5fMjc2MS8xMjA5OTM1Nw==">darwin11<i class="fa fa-external-link-alt"></i></span> 支持一下卑微的作者。</strong></p>
<h2 id="3、开始安装"><a href="#3、开始安装" class="headerlink" title="3、开始安装"></a>3、开始安装</h2><p>将你虚拟机中的MacOS关机，在虚拟机设置中将CD&#x2F;DVD指定为 <strong>darwin.iso</strong>：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202405141124534.png"></p>
<p>启动系统，在桌面右边可以看到VMware Tools，双击打开：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107143717.png"></p>
<p>双击安装，按照步骤一步步来即可：<br><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107143813.png"></p>
<blockquote>
<p>注意，这里要选择信任（先点击左下角的图标解锁），允许 系统载入 VMware Tools。</p>
</blockquote>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210107143841.png"></p>
<p>最后重新启动，你就可以看到熟悉的MacOS系统，赶紧全屏，体验一下VMware Tools带来的操作的顺畅感觉吧！</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>VMware Tools</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>新知识！虚拟机网卡造成你的DNS解析变慢</title>
    <url>/2021/01/684371b31698.html</url>
    <content><![CDATA[<p>对于 <code>DNS</code> 解析的问题，其实对于会上网查询问题的同学来说可能都是一个老生常谈的问题，大多数时候，我们都会得到一个结论，即去修改 <strong>本机网卡的DNS地址</strong> ，但是，笔者却遇到了不同的情况，最终摸索出了答案，在此记录下来，希望能帮助到有相同情况的读者。</p>
<span id="more"></span>

<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>其实，笔者的电脑的 DNS 解析慢已经有过一段时间了，经常出现的情况就是打开网页解析主机的时间异常的长。而经过测试，如 <code>QQ、微信</code> 等软件直连的都没有问题，在之前，笔者一直以为是路由器或者其他网络设备的问题，又因为它勉强还能承受过去，笔者就没有过多在意。</p>
<p>但某天晚上，当笔者打开 <code>Spring Boot</code> 官网查看文档，里面的许多链接都跳往不同的网站，在多次点击不同链接，看着浏览器上不断转动的小圈圈，笔者陷入了沉思。</p>
<p>于是痛定思痛，发誓一定解决这个问题。</p>
<h2 id="尝试解决方案"><a href="#尝试解决方案" class="headerlink" title="尝试解决方案"></a>尝试解决方案</h2><p>但事情哪里有那么简单，由于之前的错误判断，笔者首先怀疑到的就是路由器或网络设备。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>于是，笔者进入路由器后台，将路由器的 DNS 设为自定义的公共DNS，然而，故障如常，为了确定非路由器问题，笔者还用不同的电脑在同一路由器下测试，发现独独笔者的电脑是个特例…….。</p>
<p>一法不行，再来一法。确定网络设备问题排除在外，笔者开始寻找在本机电脑上的解决方案。</p>
<p>首先，笔者在像大多数情况一样，在网络设置中自定义DNS为通用的 114.114.114.114。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129215053.png" alt="image-20210129215045973"></p>
<p>很不幸，问题并没有解决。可能会有人问，肯定是你的DNS地址不行。事实是，笔者几乎试了所有能排的上号的DNS地址，故障如常。</p>
<p>此时，笔者已经开始想起是不是要重装电脑系统了，但想到重装系统后复杂的软件安装和配置，笔者决定还是继续多研究几次。</p>
<h3 id="觉醒"><a href="#觉醒" class="headerlink" title="觉醒"></a>觉醒</h3><p>至此，笔者重新理清思路，猜测是否是 DNS 地址是否没有设置上，在控制台输入 <code>ipconfig /all</code>，发现DNS是设置成功的。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129215923.png" alt="image-20210129215923777"></p>
<p>那难道真的是系统问题？既然来到了控制台，就测测 DNS 解析吧：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129220310.png" alt="image-20210129220309973"></p>
<p>嗯？服务器不应该是 114.114.114.114 吗？难道真的是没有生效？系统BUG？，抱着怀疑的想法，笔者打开网络适配器确认DNS地址：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129220504.png" alt="image-20210129220504244"></p>
<p>很明显，并没有问题，正当笔者考虑重装系统时，笔者看到适配器中的两个 <code>Vmware虚拟机网络适配器</code> ：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129220648.png" alt="image-20210129220648805"></p>
<p>由于这两个适配器是很早时候装 Vmware 虚拟机时附带的，笔者都忘了有什么用了，于是顺便点进去看了看网络信息：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129220912.png" alt="image-20210129220912054"></p>
<p>嗯？怎么这么眼熟？回去翻看控制台，发现这不就是控制台的相同 DNS吗？难道就是你这个逼崽子？于是笔者试着将两个适配器禁用，再次在控制台测试：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210129221050.png" alt="image-20210129221050397"></p>
<p>好家伙，我直接好家伙，原来是多个网卡冲突的问题，笔者还是第一次遇见，只能怪自己学艺不精了。</p>
<p>重新打开浏览器，啊~，这清爽的感觉（意会）</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>杂七杂八</tag>
        <tag>Vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>解锁你的网易云歌曲：Windows篇</title>
    <url>/2021/06/ae4a82580e0c.html</url>
    <content><![CDATA[<p>网易云音乐是我们常常使用的音乐软件，但是它的版权问题的确令人堪忧，</p>
<p>本篇文章向大家引入一个开源项目，解决网易云无版权歌曲的播放问题。</p>
<span id="more"></span>

<h2 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h2><blockquote>
<p>如果客户端出现未连接网络等问题，可以尝试重启服务，若还是不行，推荐重新安装服务。<br>下面更新了最新的文件，服务运行稳定性有所增强，具体请跳到 <a href="#jump1">软件安装</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打开我的歌单，想听歌解解闷，发现我的歌单中<strong>变灰</strong>（无法播放）的歌曲更多了，我不禁陷入了沉思：网易云的版权越来越少，难道要换软件？但是我不舍得多年来使用网易云的习惯。</p>
<p>于是我打开了Github，寻找有没有大佬的解决方案，在茫茫项目中，我突然发现了一个利用代理拦截实现的解锁网易云的工具：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vbmRhbmVlL1VuYmxvY2tOZXRlYXNlTXVzaWM=">https://github.com/nondanee/UnblockNeteaseMusic<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521232158.png" alt="2019-09-22_17-45-41"></p>
</blockquote>
<p>一段时间上手后，发现使用起来非常愉悦，于是就有了这篇博客。</p>
<!--more-->

<h2 id="1、项目实现原理"><a href="#1、项目实现原理" class="headerlink" title="1、项目实现原理"></a>1、项目实现原理</h2><p>通过观察源码以及个人上手之后的体验后发现，此项目通过拦截网易云音乐的HTTP连接，将网易云音乐中的变灰以及版权歌曲链接替换为QQ &#x2F; 虾米 &#x2F; 百度 &#x2F; 酷狗 &#x2F; 酷我 &#x2F; 咕咪 &#x2F;  音源链接，从而实现我们可以在客户端播放以及下载具有版权和变灰的歌曲。</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p><strong>需要的运行环境：</strong></p>
<ul>
<li>Node &gt;&#x3D; 12</li>
<li>正常启动的电脑</li>
</ul>
<p>由于项目依赖于 Node 环境，我们首先需要安装 <code>Node.js</code>。如果您是前端开发人员或者接触过 Node ，大概率个人电脑是已经装好了这个软件。</p>
<p>可以在 <code>cmd</code> 输入 <code>node -v</code> 测试是否已经安装此软件：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521202415.png" alt="image-20210521202415812"></p>
<p>若能显示版本号，则表明您已经拥有了 Node 环境，可以直接跳到 <a href="#jump1">安装软件</a> 这步。</p>
<p>若提示找不到命令：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521202751.png" alt="image-20210521202751684"></p>
<p>则代表没有 Node 环境，那么我们需要安装 Node 环境，接下来演示如何安装 Node 环境。</p>
<p>首先在 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9kb3dubG9hZC8=">Node 的官网<i class="fa fa-external-link-alt"></i></span>下载 <code>Node.js</code> 的最新稳定版，找到 Windows 安装包64位：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521151014.png" alt="image-20210521150859091"></p>
<p>运行下载好的安装包，建议在 <strong>安装路径这里选择你常用的软件安装位置</strong>，当然你也可以选择不修改，直接 <code>Next</code></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521203137.png" alt="image-20210521203137212"></p>
<p>接下来一直 <code>Next</code> 就行了，不要做任何选择：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521203302.png" alt="image-20210521203302570"></p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521203326.png" alt="image-20210521203326089"></p>
<p>点击 <code>Install</code>，安装即可。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521203349.png" alt="image-20210521203349321"></p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a><span id="jump1">安装软件</span></h3><p>最简单且最直接的办法就是下载作者本人打包好的运行脚本，下载地址：</p>
<p><strong>2022.1.9 更新:</strong> 替换最新脚本，更新运行命令，解决高版本客户端显示未连接网络的问题</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mYXN0bHkuanNkZWxpdnIubmV0L2doL3FpYW5mYW5ndW9qaW4vQ0ROQG1hc3Rlci9Db21wcmVzc2VkL1VuYmxvY2tOZXRlYXNlTXVzaWMuemlw">白嫖<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9qaXVuaWFuXzI3NjEvMTg5NDI4MDc=">关爱<i class="fa fa-external-link-alt"></i></span></p>
<p>下载后，将压缩包中所有文件解压到你安装软件的常用文件夹下面的某个文件夹，放置脚本文件。</p>
<p>这里我选择在默认的 <code>C:\Program Files\</code> 新建 <code>UnblockNeteaseMusic</code> 文件夹，并将所有文件解压到其中：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521211652.png" alt="image-20210521211652893"></p>
<p>以管理员身份打开 <code>cmd</code> ，并进入此目录：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521212147.png" alt="image-20210521212147690"></p>
<p><strong>2022.1.9 更新:</strong> 添加一条命令</p>
<p>执行 安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i node-windows</span><br></pre></td></tr></table></figure>

<p>执行 <code>UblockWin.js</code> 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node ./UblockWin.js</span><br></pre></td></tr></table></figure>

<p>没有异常的话，在目录下会生成一个 <code>daemon</code> 文件夹：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521212647.png" alt="image-20210521212647042"></p>
<p>打开系统服务，可以看到已经成功注册服务：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521212950.gif"></p>
<h2 id="3、配置使用"><a href="#3、配置使用" class="headerlink" title="3、配置使用"></a>3、配置使用</h2><p>打开网易云音乐客户端，打开网易云PC端，选择 <strong>设置 &gt;&gt; 工具 &gt;&gt; Http代理</strong>。</p>
<p>选择 <strong>自定义代理</strong>，<strong>HTTP代理</strong>  输入服务器为：<code>127.0.0.1</code> ，端口为 <code>8086</code> 点击确定，重启软件。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521214204.png" alt="image-20210521214204770"></p>
<p>重新进入软件，找到周董的一首歌，测试是否可以播放：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210521214600.png" alt="image-20210521214600884"></p>
<p>如果可以的话，说明你已经成功解锁，开始你全新的网易云生活吧。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>将  Windows Terminal  添加到 Windows 右键菜单（管理员方式、可选配置）</title>
    <url>/2021/11/fdb5da7ac541.html</url>
    <content><![CDATA[<p>有时候，我们往往需要在某个目录进入控制台窗口，特别是在某个目录打开管理员窗口，而大多数控制台的默认路径都会从用户家目录出发，不太方便。</p>
<p>本篇引入一个开源项目，介绍如何将 Windows Terminal 在当前目录打开，以及以管理员方式打开的办法。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原项目：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xleHRtL3dpbmRvd3N0ZXJtaW5hbC1zaGVsbA==">lextm&#x2F;windowsterminal-shell<i class="fa fa-external-link-alt"></i></span>  <em>A project backed by <span class="exturl" data-url="aHR0cHM6Ly93d3cubGV4dHVkaW8uY29tLw==">LeXtudio Inc.<i class="fa fa-external-link-alt"></i></span></em></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vd2luZG93c3Rlcm1pbmFsLW1lbnU=">qianfanguojin&#x2F;windowsterminal-menu: 一个 Powershell 脚本，实现在当前目录打开 Windows Terminal <i class="fa fa-external-link-alt"></i></span>  <em>Modified by <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4=">qianfanguojin<i class="fa fa-external-link-alt"></i></span></em></p>
<h3 id="注意：Win-11-的新版右键菜单暂不支持"><a href="#注意：Win-11-的新版右键菜单暂不支持" class="headerlink" title="注意：Win 11 的新版右键菜单暂不支持"></a>注意：Win 11 的新版右键菜单暂不支持</h3><p>感谢原作  <span class="exturl" data-url="aHR0cHM6Ly93d3cubGV4dHVkaW8uY29tLw==">LeXtudio Inc.<i class="fa fa-external-link-alt"></i></span>  提供的工具，笔者在这里对其中的内容进行翻译，以及本地化修改。</p>
<p>此脚本的目的就是为了解决这个问题，最终实现的效果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202111162049240.jpg"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>安装 Window Terminal <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC90ZXJtaW5hbA==">Windows Terminal installation | Microsoft Docs<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>安装 PowerShell 7  <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vcG93ZXJzaGVsbC9zY3JpcHRpbmcvaW5zdGFsbC9pbnN0YWxsaW5nLXBvd2Vyc2hlbGwtb24td2luZG93cw==">在 Windows 上安装 PowerShell - PowerShell | Microsoft Docs<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>下载 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vd2luZG93c3Rlcm1pbmFsLW1lbnU=">本仓库 <i class="fa fa-external-link-alt"></i></span> 提供的 <code>install.ps1</code> 文件，<span class="exturl" data-url="aHR0cHM6Ly9mYXN0bHkuanNkZWxpdnIubmV0L2doL3FpYW5mYW5ndW9qaW4vd2luZG93c3Rlcm1pbmFsLW1lbnUvaW5zdGFsbC5wczE=">加速下载<i class="fa fa-external-link-alt"></i></span> 。</p>
</li>
<li><p>使用 <strong>管理员权限</strong> 启动 Powershell 7 控制台，然后运行仓库中的 <code>install.ps1</code> 文件。程序会自动寻找电脑中的终端和 shell 配置，并将其添加到右键菜单。</p>
<blockquote>
<p>不知道如何运行 ps1 文件？很简单，找到 ps1 后缀名的文件所在的位置，在控制台输入即可。<br>如, <code>install.ps1</code> 文件放在桌面上，那路径就是 C:\Users\yourname\Desktop\install.ps1。<br>那我们只要进入桌面，输入该文件名，然后按 Enter ，即可运行 <code>install.ps1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &quot;C:\Users\yourname\Desktop&quot;</span><br><span class="line">.\install.ps1</span><br></pre></td></tr></table></figure>

<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/202111162108997.png" alt="image-20211116210828147"></p>
</blockquote>
<blockquote>
<p>此外，若是感觉上面的方式麻烦，想要快速安装最新版本的 <code>install.ps1</code> 安装脚本，那么可以选择将下面的代码依次 (<strong>2 行</strong>) 复制到 Powershell 7 (<strong>管理员权限</strong>) 的控制台中运行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>;</span><br><span class="line">[<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/qianfanguojin/windowsterminal-menu/master/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>若提示下载失败 <code>&quot;请求的名称有效，但是找不到请求的类型的数据。 (raw.githubusercontent.com:443)&quot;</code> 等错误，可以将上面的链接替换为如下的链接，感谢 <span class="exturl" data-url="aHR0cHM6Ly9mYXN0bHkuanNkZWxpdnIubmV0L2do">@jsdeliver<i class="fa fa-external-link-alt"></i></span> :</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;https://fastly.jsdelivr.net/gh/qianfanguojin/windowsterminal-menu/install.ps1&#x27;</span></span><br><span class="line">或</span><br><span class="line"><span class="string">&#x27;https://fastly.jsdelivr.net/gh/qianfanguojin/windowsterminal-menu/install.ps1&#x27;</span></span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>用和安装同样的方式，运行 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5mYW5ndW9qaW4vd2luZG93c3Rlcm1pbmFsLW1lbnU=">仓库 <i class="fa fa-external-link-alt"></i></span>中的 <code>unistall.ps1</code> 脚本来删除右键菜单中的 <code>在此处打开 Windows Terminal </code> 项。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>安装步骤中的一键安装命令需要从 Github 获取最新的安装的文件，这可能需要你的网络畅通(你懂的) 。</p>
<p>目前的版本只支持在 Windows10&#x2F;11 电脑上运行，而且要求 Windows Terminal 是通过 Microsoft Store 或者 <code>.appx</code> 方式安装的。</p>
<p>安装脚本必须在 <strong>管理员权限</strong> 模式下运行，不知道 Powershell 如何获取管理员权限的请自行百度或谷歌。</p>
<p>从 Microsoft Store 安装的 Powershell 7 不支持此脚本。</p>
<p><code>install.ps1</code> 和 <code>uninstall.ps1</code> 仅仅会修改 <strong>当前用户</strong> 的资源管理器右键菜单。如果系统中有多个用户，只有当前登录的用户的右键菜单会被修改。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC食用指南（一）：基础入门</title>
    <url>/2019/08/88ee63da116f.html</url>
    <content><![CDATA[<p>在使用 Java 连接数据库进行操作时，我们不可避免的要接触到 <strong>JDBC</strong> 这个名字。</p>
<p>这次，我们就从头到尾一点点讲述基本的 JDBC 如何使用。</p>
<span id="more"></span>

<h2 id="1-JDBC概念"><a href="#1-JDBC概念" class="headerlink" title="1. JDBC概念"></a>1. JDBC概念</h2><p>JDBC 是英文词语 <strong>Java DataBase Connectivity</strong> 的缩写，我们也将其称为 Java 数据库连接。</p>
<p>这样解释肯定太过笼统，那 JDBC 的本质是什么呢？</p>
<p>众所周知，Java 的发展闪光点之一就是其跨平台的特性。其实现了一份代码，多个平台都能运行，而这个特性的核心技术在于 <strong>JVM</strong> 这个中间人的存在，帮助java 字节码在不同平台上都能成功运行。</p>
<p>而 JDBC 也是做一个中间人的作用。我们希望，我们写同样的数据库操作，能在不同的数据库中都能使用。</p>
<p>但是不同的数据库厂商又有自己的规范，Sun 公司也发现了这个问题，于是其定义了一套 Java 中关于数据库操作的规范（接口）API，每个数据库厂商再根据这套规范编写相应的驱动（jar 包），我们使用这套接口进行代码的编写，真正执行的则是相应数据库提供的jar包中的实现类。</p>
<p>具体看下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171627950.png"></p>
<h2 id="2-JDBC-入门使用"><a href="#2-JDBC-入门使用" class="headerlink" title="2. JDBC 入门使用"></a>2. JDBC 入门使用</h2><p>JDBC 操作数据库的步骤大致可以分为五步：</p>
<ol>
<li><p>注册驱动，告诉程序要连接哪个数据库。</p>
</li>
<li><p>获取连接对象，和数据库牵个手，建立联系。</p>
</li>
<li><p>组装SQL语句，确定要对数据库的操作。</p>
</li>
<li><p>获取SQL语句执行对象，向数据库要执行sql语句的能力。</p>
</li>
<li><p>执行SQL语句，执行组装好的SQL语句。</p>
</li>
<li><p>对执行SQL的结果进行处理，确定SQL语句执行正确。</p>
</li>
<li><p>释放连接对象，和数据库分手。</p>
</li>
</ol>
<p>接下来我们从零开始体验一次</p>
<h3 id="2-1-建立测试所用的数据库和表"><a href="#2-1-建立测试所用的数据库和表" class="headerlink" title="2.1 建立测试所用的数据库和表"></a>2.1 建立测试所用的数据库和表</h3><p>为了给下面的示例测试所用，我们先建立一个数据库和一张表。</p>
<p>首先进入 mysql 的控制台，进入成功的结果应该是这样：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171627347.png"></p>
<p>然后新建一个数据库 hk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database hk;</span><br></pre></td></tr></table></figure>

<p>然后进入 hk 数据库，并新建一张user表，这个表有两个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user hk；</span><br><span class="line">create table user(user char(10),password char(16));</span><br></pre></td></tr></table></figure>

<p>插入两条数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into user value(&#x27;小明&#x27;,&#x27;123456&#x27;);</span><br><span class="line">insert into user value(&#x27;小华&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-编写连接数据库代码"><a href="#2-1-编写连接数据库代码" class="headerlink" title="2.1 编写连接数据库代码"></a>2.1 编写连接数据库代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">simpleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动,告诉程序要连接哪个数据库.</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取连接对象，和数据库牵个手，建立联系。</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/hk&quot;</span>,<span class="string">&quot;root &quot;</span>,<span class="string">&quot;987075&quot;</span>);</span><br><span class="line">        <span class="comment">//3.组装SQL语句，确定要对数据库的操作。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set user = &#x27;小李&#x27; where user = &#x27;小明&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">//4.获取SQL语句执行对象，向数据库要执行sql语句的能力。</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stm</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//5.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> stm.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//6.对执行SQL的结果进行处理，确定SQL语句执行正确。</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//7.释放连接对象，和数据库分手。</span></span><br><span class="line">        stm.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我执行了数据库更新操作，更新<code>user</code>表中将第一行记录的名字从小明改为小李。</p>
<p>然后我们检查一下SQL语句是否真的执行了，在mysql控制台中使用 <code>select * from user</code> sql语句查询表所有记录，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+----------+</span><br><span class="line">| user   | password |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 小李   | 123456   |</span><br><span class="line">| 小华   | 123456   |</span><br><span class="line">+--------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>修改成功。</p>
<h2 id="3-JDBC-使用的各个类功能解析"><a href="#3-JDBC-使用的各个类功能解析" class="headerlink" title="3. JDBC 使用的各个类功能解析"></a>3. JDBC 使用的各个类功能解析</h2><h3 id="3-1-DriverManager-功能解析"><a href="#3-1-DriverManager-功能解析" class="headerlink" title="3.1 DriverManager 功能解析"></a>3.1 DriverManager 功能解析</h3><h4 id="f1-注册驱动"><a href="#f1-注册驱动" class="headerlink" title="f1. 注册驱动"></a>f1. 注册驱动</h4><p>我们使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 这行代码来实现数据库连接驱动的注册。</p>
<p>如果有过反射的基础的同学的话，我们知道，<code>Class.forName</code> 的功能是将指定的类的 class文件 装载进内存而形成 Class 对象。</p>
<p>那么在这里意思就是将类 <code>com.mysql.jdbc.Driver</code> 加载进内存形成 Class 对象；但是，形成Class对象肯定就能实现注册驱动的功能？，我们查看 <code>com.mysql.jdbc.Driver</code> 类的源码，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到类中有一段静态代码块，静态代码块会在类加载时就会执行。</p>
<p>再查看静态代码块中的内容，这里使用 <strong>DriverManager</strong> 类调用了其的一个静态方法registerDriver并传入 Driver 类的一个实例。</p>
<p>那么registerDriver 方法是什么呢，从名字上看是注册驱动，为了确定结果，我们翻阅 api 文档找到 DriverManager类中的registerDriver 方法，文档中如此解释：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void registerDriver(Driver driver)</span><br><span class="line">                        throws SQLException</span><br></pre></td></tr></table></figure>

<p>注册与给定的驱动程序<code>DriverManager</code> 。  新加载的驱动程序类应该调用方法<code>registerDriver</code>其自己已知的<code>DriverManager</code>  。 如果驱动目前已注册，则不采取任何行动。</p>
</blockquote>
<p>到这里大致就清楚了，注册驱动其实真正的实现是：加载<code>com.mysql.jdbc.Driver</code> 类-&gt; 自动执行静态代码块 -&gt; 调用<strong>DriverManager</strong>类的静态方法registerDriver实现注册，真正是新注册驱动功能的是 registerDriver方法。</p>
<h4 id="f2-获取连接数据库的对象"><a href="#f2-获取连接数据库的对象" class="headerlink" title="f2. 获取连接数据库的对象"></a>f2. 获取连接数据库的对象</h4><p>数据库连接操纵中我们使用 <code>DriverManager.getConnection(String url,String user,String password)</code>方法来获取数据库连接对象，这个方法接收三个参数，三个参数的具体含义如下：</p>
<ul>
<li><p>url : 指定数据库连接的路径</p>
<ul>
<li><p>url 在不同的数据库中的格式不一样。</p>
</li>
<li><p>在mysql数据库中，格式为：<strong>jdbc:mysql:&#x2F;&#x2F;ip地址:mysql数据库使用的端口&#x2F;数据库名</strong>。</p>
<p>比如我要访问本机（本机ip地址为 127.0.0.1 或 localhost）上的mysql数据库（端口号默认为3306）中的hk数据库，url 应该这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/hk</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果访问的本机上的mysql而且端口号是3306，则 url 中ip地址和端口号可省略，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:///hk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>user：数据库的用户名，我们使用的mysql用户名默认是root。</p>
</li>
<li><p>password：数据库用户的密码。</p>
</li>
</ul>
<p>总结：DriverManager 主要负责注册数据库驱动以及获取对应数据库的连接对象，不同的数据库驱动不一样，获取连接对象时需要指定的参数值也不同。</p>
<hr>
<h3 id="3-3-Connection-功能解析"><a href="#3-3-Connection-功能解析" class="headerlink" title="3.3 Connection 功能解析"></a>3.3 Connection 功能解析</h3><h4 id="f1-获取执行SQL语句的对象"><a href="#f1-获取执行SQL语句的对象" class="headerlink" title="f1. 获取执行SQL语句的对象"></a>f1. 获取执行SQL语句的对象</h4><ul>
<li><p>获取执行SQL语句的 Statement对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stm</span> <span class="operator">=</span> connection.createStatement();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取执行SQL语句的 PrepareStatement对象（<strong>推荐</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrepareStatement = connection.prepareStatement(String sql);</span><br></pre></td></tr></table></figure>

<p>通常来说 PrepareStatement 比Statement 更安全且快速，在大多数时候我们都应使用PrepareStatement来操作SQL语句。</p>
</li>
</ul>
<h4 id="f2-事务管理"><a href="#f2-事务管理" class="headerlink" title="f2. 事务管理"></a>f2. 事务管理</h4><p>事务就是一个业务操作，其一般包含多个数据库操作，Connection类中也提供了事务管理的方法，使用的步骤为：</p>
<ol>
<li><p>开启手动事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connection.setAutoCommit(false);</span><br></pre></td></tr></table></figure>

<p>默认所有的SQL操作都是自动提交的，将自动提交关闭代表我想手动提交，也就是开启事务。</p>
</li>
<li><p>提交事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.commit();</span><br></pre></td></tr></table></figure>
</li>
<li><p>回滚事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connection.rollback();</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-4-Statement-功能解析"><a href="#3-4-Statement-功能解析" class="headerlink" title="3.4 Statement 功能解析"></a>3.4 Statement 功能解析</h3><p>Statement 是执行sql语句的对象，封装了许多方法用于对数据库的操作。</p>
<p>一般我们不使用这个类来操作SQL语句，只需大概了解就行。</p>
<h4 id="f1-执行DML、DDL语句"><a href="#f1-执行DML、DDL语句" class="headerlink" title="f1. 执行DML、DDL语句"></a>f1. 执行DML、DDL语句</h4><p>DML（insert、update、delete）,DDL语句（create、alter、drop）相关的数据库操作在Statement 类中都使用<strong>excuteUpdate(String sql)</strong> 方法来实现。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set user = &#x27;小李&#x27; where user = &#x27;小明&#x27;&quot;</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stm</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> stm.executeUpdate(sql);</span><br></pre></td></tr></table></figure>

<p><strong>excuteUpdate(String sql)</strong> 方法返回一个整数代表SQL语句执行后对数据库中内容影响的行数，可以通过这个结果来判断SQL语句执行是否成功。</p>
<h4 id="f2-执行DQL语句"><a href="#f2-执行DQL语句" class="headerlink" title="f2. 执行DQL语句"></a>f2. 执行DQL语句</h4><p>DQL（select）语句是指数据库中查询记录的语句，在Statement类中使用<strong>excuteQuery（String sql）</strong>方法实现。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">      <span class="type">Statement</span> <span class="variable">stm</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">      <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stm.executeUpdate(sql);</span><br></pre></td></tr></table></figure>

<p><strong>excuteUpdate(String sql)</strong> 返回一个 ResultSet（结果集对象），里面存储了从数据库中查询出来的记录集合。</p>
<hr>
<h3 id="3-5-ResultSet-功能解析"><a href="#3-5-ResultSet-功能解析" class="headerlink" title="3.5 ResultSet 功能解析"></a>3.5 ResultSet 功能解析</h3><p>结果集(ResultSet)是从数据库中执行查询（select）得到结果后返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可以完成对其拥有的数据的获取、更新等等。</p>
<h4 id="f1-游标cursors"><a href="#f1-游标cursors" class="headerlink" title="f1. 游标cursors"></a>f1. 游标cursors</h4><p>在ResultSet结果集中 ，对数据的操作都是以游标（cursors）来操控的，游标类似指针，指向ResultSet 的某一行。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171627595.png"></p>
<p>当我们通过执行SQL语句获得了 ResultSet 对象，此时游标位置默认如上图一样，指向查询结果中第一条记录的上一个位置，通过使用ResultSet类中控制游标的方法，可以将其位置自由移动，如 <code>next()</code>游标向下移动一行就指向了查询出的第一行数据。</p>
<h4 id="f2-使用getXXX-parameter…-方法获取数据"><a href="#f2-使用getXXX-parameter…-方法获取数据" class="headerlink" title="f2. 使用getXXX(parameter…..)方法获取数据"></a>f2. 使用getXXX(parameter…..)方法获取数据</h4><ul>
<li><p>XXX代表获取的数据类型，如Int则方法名为<code>getInt</code>、String 则为<code>getString</code></p>
</li>
<li><p>parameter 代表参数类型：</p>
<ul>
<li><p>参数为 Int：代表列的编号，如：</p>
<p><code>getString(1)</code> 表示获取当前游标行第一列的字符串类型数据</p>
<p><strong>注意</strong>：这里列号是从<strong>1</strong>开始的，而不是和数组一样从0开始。</p>
</li>
<li><p>参数为String：代表列的名称，如：</p>
<p><code>getString(&quot;user&quot;)</code>表示获取当前游标行中列名为<strong>user</strong>的字符串类型数据</p>
</li>
</ul>
</li>
</ul>
<h4 id="f3-结合游标和getXXX-遍历结果集"><a href="#f3-结合游标和getXXX-遍历结果集" class="headerlink" title="f3. 结合游标和getXXX()遍历结果集"></a>f3. 结合游标和getXXX()遍历结果集</h4><p>几个关键点：</p>
<ul>
<li><p>使用 boolean next() 方法</p>
<p>当使用ResultSet 的对象调用<code>next()</code>方法时，游标会向下移动一行，返回值有两种结果:</p>
<ul>
<li>返回<code>true</code>：表示该行存在，游标指向该行。</li>
<li>返回<code>false</code>：表示该行在结果集中不存在，游标此时指向最后一行之后。</li>
</ul>
</li>
<li><p>使用while循环</p>
<p>每次获取一行数据之前都通过执行 <code>next()</code>判断下一行是否存在，存在则使用相应的<code>getXXX()</code>方法获取该行的数据。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 循环实现遍历结果集</span><br><span class="line"> */</span><br><span class="line">//每次获取数据之前都判断下一行数据是否存在</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">4....</span><br><span class="line">4String user = rs.getString(&quot;user&quot;);//获取当前行列名为user的数据</span><br><span class="line">4String password = rs.getString(&quot;password&quot;);//获取当前行列名为password的数据</span><br><span class="line">4...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-PrepareStament-功能解析"><a href="#3-6-PrepareStament-功能解析" class="headerlink" title="3.6 PrepareStament 功能解析"></a>3.6 PrepareStament 功能解析</h3><p>PrepareStament 和 Statemt 一样都是执行 SQL 语句的对象，但是PrepareStatement 比 Statement 更安全和高效，我们以后使用中都推荐使用这个对象来执行SQL语句。</p>
<p>在使用了PrepareStatement之后，我们操作数据库的步骤有所改变：</p>
<ol>
<li><p>首先注册驱动，告诉程序要连接哪个数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>获取连接对象，和数据库牵手，建立联系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/hk&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;987075&quot;</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>编写带有占位符 ”?“ 的SQL语句。</p>
<p>原始的SQL语句定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user  where password = &#x27;123456&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>带占位符的SQL语句定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里对于哪里填充占位符没有特定的规定，填充了占位符的地方后面就需要进行占位符赋值。</p>
<p>一般来说我们都是在控制语句 where 后面的赋值语句中设置占位符，这样我们可以根据后面对占位符赋值的不同来获取不同的SQL操作结果。</p>
</li>
<li><p>获取SQL语句执行对象并传入带有占位符的sql语句，此时SQL语句会被预编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrepareStatement</span> <span class="variable">pst</span> <span class="operator">=</span> connection.prepareStament(sql);</span><br></pre></td></tr></table></figure>


</li>
<li><p>对SQL语句中的占位符进行赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在PrepareStament 类中有许多 setXXX(参数1,参数2)  方法负责对SQL语句中的占位符进行赋值。</p>
<p>每个setXXX方法中接收两个参数：</p>
<ul>
<li><p>参数1：指定要赋值的占位符位置。如<code>setInt(1,1)</code>会将第一个占位符设置为整型值 1</p>
</li>
<li><p>参数2：指定要赋值的占位符数值，该数据的类型应和方法名中XXX指定的数据类型相同。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二个参数传入的值数据类型为long,方法名中执行的数据也为long</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setLong</span><span class="params">(<span class="type">int</span> parameterIndex,<span class="type">long</span> x)</span> <span class="keyword">throws</span> SQLException</span><br><span class="line"><span class="comment">//方法功能：将指定的参数设置为给定的Java long值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>：占位符的位置是从<strong>1</strong>开始的，第一个占位符的索引为<strong>1</strong>而不是0。</p>
</li>
<li><p>执行SQL语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>PrepareStatement 是 Statement 的子类，会继承Statement的所有方法，在调用执行SQL语句的方法时，注意不要调用到 Statement 的方法。区别的办法就是 PrepareStatement 特有的方法都是 <strong>无参</strong> 的，如：</p>
<ul>
<li>查询方法为 <code>executeQuery()</code>  。对应数据库中 DQL（select）操作，返回结果集ResultSet对象。</li>
<li>更新方法为 <code>executeUpdate()</code> 。对应数据库中DML（insert、update、delete）,DDL语句（create、alter、drop）操作,返回执行该SQL语句对数据库影响的行数。</li>
</ul>
</li>
<li><p>对执行SQL语句的结果进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;    密码：&quot;</span> + pas);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用户名：小明    密码：<span class="number">123456</span></span><br><span class="line">用户名：小华    密码：<span class="number">123456</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>释放连接对象，和数据库分手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">    pst.close();</span><br><span class="line">    connection.close();</span><br></pre></td></tr></table></figure>

<p>关闭连接的时候要记得遵循先小后大的顺序。在这里 rs 对象由 pst 对象获取到，而 pst 对象又由 connection 对象获取到。所以顺序应为 rs &gt; pst &gt; connection。</p>
</li>
</ol>
<p>根据上面的步骤，合并起来的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动,告诉程序要连接哪个数据库.</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取连接对象，和数据库牵个手，建立联系。</span></span><br><span class="line">44<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/hk&quot;</span>,<span class="string">&quot;root &quot;</span>,<span class="string">&quot;987075&quot;</span>);</span><br><span class="line">        <span class="comment">//3.编写带有占位符 ”?“ 的SQL语句。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//4.获取SQL语句执行对象并传入带有占位符的sql语句。</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//5. 对SQL语句中的占位符进行赋值。</span></span><br><span class="line">        pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//6.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line">        <span class="comment">//7.对执行SQL语句的结果进行处理</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;    密码：&quot;</span> + pas);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.释放连接对象，和数据库分手。</span></span><br><span class="line">        rs.close();</span><br><span class="line">        pst.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-JDBC-使用进阶"><a href="#4-JDBC-使用进阶" class="headerlink" title="4. JDBC 使用进阶"></a>4. JDBC 使用进阶</h2><h3 id="4-1-更严谨的使用JDBC，使用try-catch捕获异常"><a href="#4-1-更严谨的使用JDBC，使用try-catch捕获异常" class="headerlink" title="4.1 更严谨的使用JDBC，使用try catch捕获异常"></a>4.1 更严谨的使用JDBC，使用try catch捕获异常</h3><p>在上面的连接数据库的示例中，我们在<code>main</code>方法上抛出了多个异常，也就是说，我们操作数据库的步骤中可能会遇到多种异常，在示例中我将这些异常直接抛出，不做任何处理，这样是非常不安全的做法。</p>
<p>而程序在遇到异常时如果只是直接抛出的话，程序很可能会直接结束运行，这样可能会造成我们创建的对象没有释放，容易造成内存泄漏。</p>
<p>所以，在使用数据库操作时，我们更推荐将异常捕获而不是直接抛出，把可能发生异常的代码用 try 包括，然后根据捕获到的不同异常使用 catch 进行不同的异常处理；最后，无论程序有没有异常我们都要关闭资源，将关闭资源的代码写在 finally 代码块中。</p>
<p>根据以上内容，我们将上面的示例修改为使用 try catch  之后的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 使用了 try catch 之后的数据库连接操作写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryPreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动,告诉程序要连接哪个数据库.</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获取连接对象，和数据库牵个手，建立联系。</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/hk&quot;</span>,<span class="string">&quot;root &quot;</span>,<span class="string">&quot;987075&quot;</span>);</span><br><span class="line">            <span class="comment">//3.编写带有占位符 ”?“ 的SQL语句。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//4.获取SQL语句执行对象并传入带有占位符的sql语句。</span></span><br><span class="line">            pst = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//5. 对占位符进行赋值。</span></span><br><span class="line">            pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="comment">//6.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">            rs = pst.executeQuery();</span><br><span class="line">            <span class="comment">//7.对执行SQL的结果进行处理</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;    密码：&quot;</span> + pas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.释放连接对象，和数据库分手。</span></span><br><span class="line">            <span class="comment">//关闭结果集对象</span></span><br><span class="line">            <span class="comment">//释放前应该判断对象是否为空，不为空再执行关闭操作，避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    rs.close();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭数据库操作对象</span></span><br><span class="line">            <span class="keyword">if</span>(pst != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    pst.close();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭连接对象</span></span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-2-优化JDBC代码冗余，设计简单的-JDBC-工具类"><a href="#4-2-优化JDBC代码冗余，设计简单的-JDBC-工具类" class="headerlink" title="4.2. 优化JDBC代码冗余，设计简单的 JDBC 工具类"></a>4.2. 优化JDBC代码冗余，设计简单的 JDBC 工具类</h3><p>使用数据库操作对象 PrepareStatement 对象后，我们操作数据库的步骤一共有八步，分别是：</p>
<ol>
<li>注册驱动。</li>
<li>获取连接对象。</li>
<li>编写带有占位符 ”?“ 的SQL语句。</li>
<li>获取SQL语句执行对象并传入带有占位符的SQL语句。</li>
<li>对SQL语句中的占位符进行赋值。</li>
<li>执行SQL语句。</li>
<li>对执行SQL的结果进行处理。</li>
<li>释放资源。</li>
</ol>
<p>这些步骤都需要编写代码完成，里面再加上异常处理的代码，代码量就比较感人了，我们的程序可读性就比较差了。这样显然是不是最佳的使用方式。</p>
<p>但是我们仔细观察这些步骤的相关的代码，可以发现其实其中有许多步骤使用的代码逻辑都是重复的，也就是可复用的。如</p>
<ul>
<li>注册驱动。</li>
<li>获取连接对象。</li>
<li>资源释放。</li>
</ul>
<p>根据我们以前学过的知识，对于这种可以复用的代码，我们一般都推荐使用工具类来对其进行包装。那么，我们接下来就来实现一下这个工具类 <code>JDBCUtils</code>；</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>对于工具类来说，我们应该让其使用起来方便调用，所以我们定义的方法应该都是静态的，这样我们就可以直接通过类名调用。</p>
</blockquote>
<p>下面我们依次分析我们功能的具体实现步骤：</p>
<h4 id="f1-注册驱动功能"><a href="#f1-注册驱动功能" class="headerlink" title="f1. 注册驱动功能"></a>f1. 注册驱动功能</h4><p>对于注册驱动的功能，我们希望在程序最开始执行时就注册驱动，而一般来说，在一个程序的运行过程之中我们也只需注册一次数据库驱动即可，那么如何让注册驱动的代码其最先执行且仅执行一次呢？</p>
<p>很多人肯定已经想起来了，可以使用静态代码块来实现，在静态代码块中的内容会在类被加载时就执行且在该类生命周期内仅执行一次。</p>
<p>于是我们可以在 JDBCUtils 工具类中添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *静态代码块，仅在 JDBCUtils 类加载时调用一次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//注册驱动</span></span><br><span class="line">           Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> OK ,注册驱动步骤结束。</p>
<h4 id="f2-获取连接对象功能"><a href="#f2-获取连接对象功能" class="headerlink" title="f2. 获取连接对象功能"></a>f2. 获取连接对象功能</h4><h5 id="1-使用成员变量默认值配置参数"><a href="#1-使用成员变量默认值配置参数" class="headerlink" title="1. 使用成员变量默认值配置参数"></a>1. 使用成员变量默认值配置参数</h5><p>在获取连接对象时，我们需要使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DriverManager.getConnection(String url, String user, String password);</span><br></pre></td></tr></table></figure>

<p>该方法需要我们每次使用都需传入三个参数。而既然使用了工具类，显然每次还要输入这么多参数是极度不方便的。</p>
<p>解决这个问题的办法也很简单，先将这些参数在工具类 <code>JDBCUtils</code> 中定义为成员变量并赋好对应的值，只要在使用 <code>DriverManager.getConnection(String url, String user, String password)</code> 获取连接对象时使用成员变量作为参数值就可以了。</p>
<p>于是我们可以在 <code>JDBCUtils</code> 中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hk&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;987075&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回获取的连接对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">      <span class="keyword">return</span> DriverManager.getConnection(URL,USER,PASSWORD);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>经过这样处理，我们只要使用 <code>JDBCUtils.geConnection()</code>就可直接得到连接对象，看起来是不是方便了许多？</p>
<p>但是这样还是会有一点弊端，当我们需要连接另一个数据库，或者说我的数据库密码修改了，此时的连接需要的参数url,user,password 可能不一样，此时我们要去修改 <code>JDBCUtils</code>中成员变量的值来保证连接正确。</p>
<p>而每次变换配置都需要去修改程序中的代码显然是不够方便的，这也和我们工具类的设计理念不合。接下来介绍一种更推荐的定义参数方法。</p>
<h5 id="2-使用配置文件Properties配置参数"><a href="#2-使用配置文件Properties配置参数" class="headerlink" title="2. 使用配置文件Properties配置参数"></a>2. 使用配置文件Properties配置参数</h5><p>我们在平时使用软件时会使用一种叫做 <strong>配置文件</strong> 的东西，很多软件也都可以通过修改配置文件来实现不同的设置效果。</p>
<p>相对于修改代码，修改配置文件更简单也更安全。</p>
<p>那么我们也可以将数据库连接所需的参数放到配置文件中，然后通过读取配置文件获得我们需要的值，当我们需要更改连接参数时也只需更改配置文件中的信息即可，无需修改代码，更方便也更安全。</p>
<p>在 Java 中，配置文件都是 .properties 格式存在的文件，里面的数据是以键值对(key&#x3D;value)作为参数配置的。同时 Java 在 java.util 包中也提供了一个 <strong>Properties类</strong> 负责对  .properties 格式的文件进行数据处理。</p>
<p>为了我们的工具类具有更强的适应性，使用配置文件来控制和修改参数是推荐的方式，下面介绍如何使用配置文件来配置参数值：</p>
<p>首先我们在 src 目录下新建一个 jdbc.properties 文件用作存储数据库连接所需的配置参数，并在里面添加以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/hk</span></span><br><span class="line">user=root</span><br><span class="line">password=<span class="number">987075</span></span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>然后在 <code>JDBCUtils</code>中将url，user，password的默认值都删除，并修改staic代码块中代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取配置文件信息</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//加载文件</span></span><br><span class="line">            pro.load(in);</span><br><span class="line">            <span class="comment">//将获取到的配置文件中的数值赋给相应的参数</span></span><br><span class="line">            URL = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            USER = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            PASSWORD = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(pro.getProperty(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过配置文件动态配置我们连接时所需要的各种参数了，后期调试应用也方便许多。</p>
<h4 id="f3-关闭资源处理功能"><a href="#f3-关闭资源处理功能" class="headerlink" title="f3. 关闭资源处理功能"></a>f3. 关闭资源处理功能</h4><p>解决完上面两个功能之后，我们来处理最后一个功能，如何关闭资源。</p>
<p>对于每次数据库连接操作来说，连接对象<code>Connection</code>以及SQL语句执行对象d<code>PrepareStatement</code>是必不可少的。</p>
<p>而在执行查询DQL（select)操作后还需要结果集 ResultSet 对象处理查询出的数据；这样一来，有的时候就只需要关闭两个对象，有的时候则需要关闭三个对象。</p>
<p>而我们方法的设计肯定是一个功能一个方法名；解决这个问题，我们可以使用方法重载来解决这个问题，使用相同的方法名，但是需要的参数数量不同；明白了这点之后，我们在 <code>JDBCUtils</code>添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭资源，关闭三个对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">      <span class="comment">//关闭结果集对象</span></span><br><span class="line">      <span class="comment">//释放前应该判断对象是否为空，不为空再执行关闭操作，避免空指针异常</span></span><br><span class="line">      <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              rs.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭数据库操作对象</span></span><br><span class="line">      <span class="keyword">if</span>(pst != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              pst.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭连接对象</span></span><br><span class="line">      <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              conn.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭资源，关闭两个对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">      <span class="comment">//调用三参的方法，将第一个参数设为null，间接关闭两个对象</span></span><br><span class="line">      close(<span class="literal">null</span>,pst,conn);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="工具类功能合并及测试"><a href="#工具类功能合并及测试" class="headerlink" title="工具类功能合并及测试"></a>工具类功能合并及测试</h4><p>通过上面的步骤，我们的一个 JDBC工具类就设计完成了，整合后的一个工具类的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 简单的JDBC工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String URL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PASSWORD;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *静态代码块，在 JDBCUtils 仅在类加载时调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理properties配置文件的对象</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//加载文件</span></span><br><span class="line">            pro.load(in);</span><br><span class="line">            <span class="comment">//将获取到数值赋给相应的参数</span></span><br><span class="line">            URL = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            USER = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            PASSWORD = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回获取的连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(URL,USER,PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源，关闭三个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">        <span class="comment">//关闭结果集对象</span></span><br><span class="line">        <span class="comment">//释放前应该判断对象是否为空，不为空再执行关闭操作，避免空指针异常</span></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭数据库操作对象</span></span><br><span class="line">        <span class="keyword">if</span>(pst != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                pst.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接对象</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源，关闭两个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">        <span class="comment">//调用三参的方法，将第一个参数设为null，间接关闭两个对象</span></span><br><span class="line">        close(<span class="literal">null</span>,pst,conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们修改上面的示例，在使用了 <code>JDBCUtils</code>工具类后代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动,告诉程序要连接哪个数据库.</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取连接对象，和数据库牵个手，建立联系。</span></span><br><span class="line">        connection = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//3.编写带有占位符 ”?“ 的SQL语句。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//4.获取SQL语句执行对象并传入带有占位符的sql语句。</span></span><br><span class="line">        pst = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//5. 对占位符进行赋值。</span></span><br><span class="line">        pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//6.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">        rs = pst.executeQuery();</span><br><span class="line">        <span class="comment">//7.对执行SQL的结果进行处理</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;     密码：&quot;</span> + pas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//8.释放连接对象，和数据库分手。</span></span><br><span class="line">        JDBCUtils.close(rs,pst,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比可以看出，刚才的代码为70多行，使用了工具类之后我们就只有30多行了，成功简化代码。</p>
<hr>
<h3 id="4-3-使用JDBC控制事务"><a href="#4-3-使用JDBC控制事务" class="headerlink" title="4.3 使用JDBC控制事务"></a>4.3 使用JDBC控制事务</h3><h4 id="4-3-1-事务概述"><a href="#4-3-1-事务概述" class="headerlink" title="4.3.1 事务概述"></a>4.3.1 事务概述</h4><p>事务：一个包含一个或多个步骤的业务操作。如果这个业务操作被事务管理，那么这个操作要么同时成功，要么同时失败。可以将一个事务看作一次数据库操作中一个或多个SQL语句的执行。</p>
<h4 id="4-3-2-简单的事务操作"><a href="#4-3-2-简单的事务操作" class="headerlink" title="4.3.2 简单的事务操作"></a>4.3.2 简单的事务操作</h4><p>在 JDBC 操作中，我们可以使用Connection 对象来对事务进行管理。</p>
<p>在上文中介绍 [Connection 对象的功能](#3.3 Connection 功能解析 ) 中介绍了Connection对象可控制事务操作，包括 ：</p>
<blockquote>
<ol>
<li>开启手动事务操作：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;connection.setAutoCommit(false);</span><br></pre></td></tr></table></figure>

<p>JDBC中所有的SQL操作默认都是自动提交的，也就是执行一句SQL就提交，将自动提交关闭代表我想手动提交，此时可以自由控制执行SQL语句的数量以及提交的时间，也就是手动操作事务。</p>
<ol start="2">
<li>提交事务：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;connection.commit();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>回滚事务：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;connection.rollback();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接下来使用一个转账的示例来演示如何使用事务：</p>
<p>首先我们先查询表中此时两人所有的钱款数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">user</span>,money <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>   <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> 小明   <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 小李   <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>首先我们使用我们现有的方式编写转账的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * JDBC 事务的简单示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.注册驱动以及获取数据库连接对象.</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.编写带有占位符 ”?“ 的SQL语句，并对相应的SQL语句占位符赋值</span></span><br><span class="line">            <span class="comment">//2.1 小明账户减500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user set money = money - ? where user = ?&quot;</span>;</span><br><span class="line">            pst1 = conn.prepareStatement(sql1);</span><br><span class="line">            pst1.setInt(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pst1.setString(<span class="number">2</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">            <span class="comment">//2.2 小李账户加500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user set money = money + ? where user = ?&quot;</span>;</span><br><span class="line">            pst2 = conn.prepareStatement(sql2);</span><br><span class="line">            pst2.setInt(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pst2.setString(<span class="number">2</span>,<span class="string">&quot;小李&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.执行SQL语句</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> pst1.executeUpdate();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> pst2.executeUpdate();</span><br><span class="line">            System.out.println(count1);</span><br><span class="line">            System.out.println(count2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.释放连接对象，和数据库分手。</span></span><br><span class="line">            JDBCUtils.close(pst1,conn);</span><br><span class="line">            JDBCUtils.close(pst2,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，查询此时两人的钱款数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">user</span>,money <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>   <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> 小明   <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 小李   <span class="operator">|</span>  <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>修改成功，但是因为这是没有产生异常情况下的，此时如果我主动产生一个异常让其在执行第一次SQL操作时产生异常会发生什么呢，修改部分代码实现在第一次和第二次SQL执行之间制造一个除0异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.执行SQL语句</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> pst1.executeUpdate();</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> pst2.executeUpdate();</span><br></pre></td></tr></table></figure>

<p>再执行一次程序，程序会抛出异常，此时查询两人的钱款数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select user,money from user;</span><br><span class="line">+--------+-------+</span><br><span class="line">| user   | money |</span><br><span class="line">+--------+-------+</span><br><span class="line">| 小明   |   <span class="number">500</span> |</span><br><span class="line">| 小李   |  <span class="number">2000</span> |</span><br><span class="line">+--------+-------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，此时数据出现了问题，小明的钱款已经减去了500，而小李却没有如愿增加500，这明显不符合转账的规则。</p>
<p>原因其实也很简单，在默认情况下，一次SQL操作就被被视为一个事务，且该项事务是自动提交的，只要SQL语句执行了，该项事务就会提交。在这里程序中先执行了第一个SQL操作小明钱款减去500，这项SQL操作被提交了；而在执行第二个SQL操作小李钱款加500前程序因为出现异常而终止，第二个SQL操作无法正常提交，数据就出现了异常。</p>
<p>为了解决这个问题，我们可以引入手动管理事务操作，将两次的SQL操作都纳入同一个事务，利用事务的原子性，我们可以容易控制这个BUG的产生。</p>
<p>引入事务操作后，代码内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * JDBC 事务的简单示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.注册驱动以及获取数据库连接对象.</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            <span class="comment">//默认情况下，所有数据库操作都会被自动提交没执行一条SQL语句就提交一次</span></span><br><span class="line">            <span class="comment">//如果要开启事务就应将其设为false，手动选择提交时间</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//3.编写带有占位符 ”?“ 的SQL语句，并对相应的SQL语句占位符赋值</span></span><br><span class="line">            <span class="comment">//3.1 小明账户减500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user set money = money - ? where user = ?&quot;</span>;</span><br><span class="line">            pst1 = conn.prepareStatement(sql1);</span><br><span class="line">            pst1.setInt(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pst1.setString(<span class="number">2</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">            <span class="comment">//3.2 小李账户加500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user set money = money + ? where user = ?&quot;</span>;</span><br><span class="line">            pst2 = conn.prepareStatement(sql2);</span><br><span class="line">            pst2.setInt(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pst2.setString(<span class="number">2</span>,<span class="string">&quot;小李&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.执行SQL语句</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> pst1.executeUpdate();</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> pst2.executeUpdate();</span><br><span class="line"></span><br><span class="line">            System.out.println(count1);</span><br><span class="line">            System.out.println(count2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            <span class="comment">//代码运行到这里该次业务操作的逻辑不出任何差错，此时提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意这里catch的异常应该要用范围更大的异常类</span></span><br><span class="line">            <span class="comment">// 这样才能在无论代码中出现什么异常的情况下我们都能抓到然后进行事务回滚</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.释放连接对象，和数据库分手。</span></span><br><span class="line">            JDBCUtils.close(pst1,conn);</span><br><span class="line">            JDBCUtils.close(pst2,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行一次程序，此时查询两人的钱款数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select user,money from user;</span><br><span class="line">+--------+-------+</span><br><span class="line">| user   | money |</span><br><span class="line">+--------+-------+</span><br><span class="line">| 小明   |   <span class="number">500</span> |</span><br><span class="line">| 小李   |  <span class="number">2000</span> |</span><br><span class="line">+--------+-------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br></pre></td></tr></table></figure>

<p>可以看到两人的钱款数并没有变动。也就是就算我们程序有异常，但是并没有像上面一样出现数据错误的问题，事务能处理异常情况保证数据的正常。</p>
<p>同时再测试一下没有异常的情况能不能正常修改数据，删除异常的代码，也就是这句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>执行程序，查询两人的钱款数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select user,money from user;</span><br><span class="line">+--------+-------+</span><br><span class="line">| user   | money |</span><br><span class="line">+--------+-------+</span><br><span class="line">| 小明   |     <span class="number">0</span> |</span><br><span class="line">| 小李   |  <span class="number">2500</span> |</span><br><span class="line">+--------+-------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br></pre></td></tr></table></figure>

<p>两人的钱款数修改正常，事务能处理正常的SQL操作。</p>
<p>由上得知，在引入事务控制管理后，我们能有效的避免一些程序设计上产生的小问题。</p>
<p>特别是在执行多个SQL语句时，事务操作尤为重要，最佳的使用方式就是如果一个功能实现有多次SQL操作，我们应该将其使用事务进行管理来保证数据的一致和安全性。</p>
<h4 id="4-3-3-事务操作的注意点"><a href="#4-3-3-事务操作的注意点" class="headerlink" title="4.3.3 事务操作的注意点"></a>4.3.3 事务操作的注意点</h4><ul>
<li>在该项事务的第一个SQL操作之前开启事务： <code>conn.setAutoCommit(false);</code></li>
<li>在该项事务的最后一个SQL操作之后提交事务： <code>conn.commit();</code></li>
<li>在异常处理 catch 中进行事务回滚： <code>conn.rollback();</code></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>JDBC事务</tag>
        <tag>JDBC工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC食用指南（二）：数据库连接池的使用</title>
    <url>/2019/08/7a8b3dac848e.html</url>
    <content><![CDATA[<p>在上一篇文章中我们已经知道了如何简单使用 JDBC 连接数据库，并且设计了一个简单的工具类来方便我们的使用，最后介绍了一点 JDBC 事务管理的操作。</p>
<p>这篇文章我们就开始进阶使用我们的 JDBC ，体验数据库连接池的技术。</p>
<span id="more"></span>

<h2 id="一-使用数据库连接池"><a href="#一-使用数据库连接池" class="headerlink" title="一. 使用数据库连接池"></a>一. 使用数据库连接池</h2><h3 id="1-什么是数据库连接池"><a href="#1-什么是数据库连接池" class="headerlink" title="1. 什么是数据库连接池"></a>1. 什么是数据库连接池</h3><p>百科定义：数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<p>个人理解：每次数据库连接都要申请一个连接对象，这项操作要经过系统底层，相对来说是非常耗时的。我们可以在程序开始时初始化多个数据库连接对象，并将其保留在一个容器（池子）中，该池子中的连接对象可以重复被使用，使用时直接向该容器获取连接对象，使用完后再将连接对象归还给该容器，这个容器（池子）称为数据库连接池。</p>
<h3 id="2-为什么使用数据库连接池"><a href="#2-为什么使用数据库连接池" class="headerlink" title="2. 为什么使用数据库连接池"></a>2. 为什么使用数据库连接池</h3><h4 id="2-1-传统的数据库连接方式"><a href="#2-1-传统的数据库连接方式" class="headerlink" title="2.1 传统的数据库连接方式"></a>2.1 传统的数据库连接方式</h4><p>每一个获取数据库连接对象的操作都需要从系统底层获取资源，申请资源又是一件极度耗时的工作。</p>
<p>每一次使用完这个数据库连接之后，我们又直接将资源释放给系统底层，下次使用还是要重新向系统申请资源。</p>
<p>这样来回反复，会浪费大量的时间以及系统资源。并且，当同时连接数据库的次数数量很大时，此时系统资源和时间都被消耗在数据库连接上，我们想要得到的数据库中的数据的时间就被延迟，这是非常影响用户的体验的。又因为每一次我们使用完数据库连接就要完全释放该连接，在大量的数据库连接中，程序如果出现异常，此时资源并没有完全释放，大量的连接资源没有及时释放，容易发生内存泄漏。</p>
<p>在上述模式下，数据库连接如下图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171620675.png"></p>
<h4 id="2-2-引入数据库连接池后的数据库连接模式"><a href="#2-2-引入数据库连接池后的数据库连接模式" class="headerlink" title="2.2 引入数据库连接池后的数据库连接模式"></a>2.2 引入数据库连接池后的数据库连接模式</h4><p>在上面的分析中我们得知，程序在获取数据库连接时这段操作其实是非常耗时的，而一般的程序运行的速度都很快，如果让程序运行的时间大部分花在等待数据库的连接操作中，这样的程序效率是很低的。</p>
<p>那么有没有办法解决呢？我们可以思考一下，其实解决这个问题的关键点就在于两点：</p>
<ol>
<li>如何解决请求连接对象速度的问题，</li>
<li>如何有效管理大量的连接。</li>
</ol>
<p>我们在学操作系统的时候，许多时候都提到了<strong>缓存</strong>这个技术，缓存的出现就是为了解决速度不匹配的问题。那么在我们这里我们可以这样想，在程序需要请求数据库连接之前我们就把连接对象创建好，此时的连接对象在内存中已经初始化好了，程序只要直接拿就是了，获取连接对象的速度就会快很多。第一个问题解决。</p>
<p>但是当产生大量的连接请求时，此时我们需要初始化多个连接对象，这些连接对象的创建服务于一次请求，用完又被释放掉了，这样会产生大量的资源浪费，而且如果程序出现异常，多个连接对象没有被完全释放，容易造成内存泄漏，这是不可取的。</p>
<p>而在程序设计中，我们有一个知识叫做 <strong>复用性</strong> ,将一样的东西放在一起，然后不同的地方都可以使用。利用这个知识，我们可以引入 <strong>容器（池子）</strong> ，将一定数量建立好的连接对象放入容器中，每次连接都向该容器获取，用完又放回该容器，这样一个对象就可以在不同的时候服务不同的连接；同时，在处理多个连接时，我们可以通过控制容器中最大连接对象的数量，避免无穷无尽的连接请求；通过对容器资源的释放，又可将其中的连接对象资源同时释放。</p>
<p>更关键的是我们可以在容器中加入相应的管理模块和监视模块，可以对其中的连接对象进行管理，方便开发人员进行测试以及优化。</p>
<p>为了实现上述这些想法和操作，人们提出了一个技术：**&#x3D;&#x3D;数据库连接池&#x3D;&#x3D;**，其目的就是用来解决和实现我们刚才讨论的这些问题。</p>
<p>在引入数据库连接池后，此时的数据库连接如图：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171620588.png"></p>
<p><strong>注意一点</strong>：数据库连接池的实现是在客户端实现的，而不是在服务端的数据库的中实现，在客户端对连接对象进行请求和管理。在数据库端对应也有一个叫做线程池的东西，和连接池的效果都差不多，当然，这都是后话了。</p>
<h4 id="2-3-实现一个简单的数据库连接池"><a href="#2-3-实现一个简单的数据库连接池" class="headerlink" title="2.3 实现一个简单的数据库连接池"></a>2.3 实现一个简单的数据库连接池</h4><p>说了这么多，我们还是来实践一下把，我们接下来就来手动实现一个简单的连接池。</p>
<p>首先我们要确定我们设计的连接池需要实现的目标：</p>
<ol>
<li>一次性创建多个连接对象</li>
<li>新增连接对象</li>
<li>回收连接对象</li>
</ol>
<p>简单实现的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 自己简单设计的一个数据库连接池</span></span><br><span class="line"><span class="comment"> * 须实现DataSource接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用链表来存放多个Connection对象</span></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;Connection&gt; connectionLinkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化多个连接对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//初始化十个连接对象，并将其放到链表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//注册驱动</span></span><br><span class="line">                    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取连接对象</span></span><br><span class="line">                    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.</span><br><span class="line">                            getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/hk1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;987075&quot;</span>);</span><br><span class="line">                    <span class="comment">//将连接对象放到链表（池子）中</span></span><br><span class="line">                    connectionLinkedList.add(connection);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获得连接池中的一个连接对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="comment">//返回第一个连接对象，并将该对象从链表中去除</span></span><br><span class="line">            <span class="keyword">return</span> connectionLinkedList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *将使用完的连接对象回收进连接池</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backConnection</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">                connectionLinkedList.add(conn);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSourceTest</span> &#123;</span><br><span class="line">44<span class="comment">//Junit 单元测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_getConnection</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.初始化一个连接池对象</span></span><br><span class="line">        <span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.获取连接池中的Connection对象</span></span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">            <span class="comment">//3.编写带有占位符 ”?“ 的SQL语句。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//4.获取SQL语句执行对象并传入带有占位符的sql语句。</span></span><br><span class="line">            pst = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//5. 对占位符进行赋值。</span></span><br><span class="line">            pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="comment">//6.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">            rs = pst.executeQuery();</span><br><span class="line">            <span class="comment">//7.对执行SQL的结果进行处理</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;    密码：&quot;</span> + pas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            dataSource.backConnection(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用户名：小明    密码：<span class="number">123456</span></span><br><span class="line">用户名：小李    密码：<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>说明我们成功通过该数据库连接池获取到连接对象。</p>
<h3 id="3-开发中常用的数据连接池"><a href="#3-开发中常用的数据连接池" class="headerlink" title="3. 开发中常用的数据连接池"></a>3. 开发中常用的数据连接池</h3><p>在上面的示例中，我们自己实现了一个数据库连接池，实现了简单的一些功能。但是在实际开发中，对数据库连接池的功能要求更全面，一般来说，数据库厂商也会在驱动包中集成实现了 <code>DataSource</code>接口的数据库连接池，而在开源平台中，也有许多优秀的数据库连接池实现，如：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N3YWxkbWFuL2MzcDA=">c3p0<i class="fa fa-external-link-alt"></i></span>： 优秀的开源数据库连接池包，但是年代比较老了。</li>
<li>Druid(德鲁伊)： 阿里开源的数据库连接池包，支付宝和淘宝也在使用，后起之秀。</li>
</ul>
<p>接下来我们就学习一下他们的使用方式。</p>
<h4 id="3-1-使用C3P0"><a href="#3-1-使用C3P0" class="headerlink" title="3.1 使用C3P0"></a>3.1 使用C3P0</h4><p>官方文档地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWNoYW5nZS5jb20vcHJvamVjdHMvYzNwMC8jcXVpY2tzdGFydA==">https://www.mchange.com/projects/c3p0/#quickstart<i class="fa fa-external-link-alt"></i></span> 我们可以从中得到使用信息。</p>
<h5 id="step1-导入相关-jar-包"><a href="#step1-导入相关-jar-包" class="headerlink" title="step1. 导入相关 jar 包"></a>step1. 导入相关 jar 包</h5><p>不管是使用什么开源库，导包都是第一步。查看c3p0的官方文档，有这么一句：</p>
<blockquote>
<p>c3p0 was designed to be butt-simple to use. Just put the files <code>lib/c3p0-0.9.5.2.jar</code> and <code>lib/mchange-commons-java-0.2.15.jar</code> in your application’s effective <code>CLASSPATH</code></p>
</blockquote>
<p>大致意思就是 c3p0 使用很方便，将<code>c3p0-0.9.5.2.jar</code> 和<code>mchange-commons-java-0.2.15.jar</code>放到应用的环境变量中即可。</p>
<p>这里就告诉我们需要导入上述两个包到我们的项目中。这两个包的下载地址分别为：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9jb20ubWNoYW5nZS9jM3AwLzAuOS41LjI=">c3p0-0.9.5.2.jar<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9jb20ubWNoYW5nZS9tY2hhbmdlLWNvbW1vbnMtamF2YS8wLjIuMTU=">mchange-commons-java-0.2.15.jar<i class="fa fa-external-link-alt"></i></span></p>
<p>然后我们在我们的 src 同级目录新建一个 libs 目录用于存放所有的 jar包 并将上面的两个 jar 包复制进来，此时目录结构如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171620353.png"></p>
<p>然后右键点击<code>c3p0-0.9.5.2.jar</code>文件，在弹出的菜单栏中靠下部分点击 <code>Add as Library</code> ,然后在弹出的弹窗中点击 OK ,就可将其导入项目的 <code>ClassPath</code>中。</p>
<p>相应的，对 <code>mchange-commons-java-0.2.15.jar</code>也执行相同的步骤。操作完成后，我们可以展开该包查看其中的信息，说明导入成功：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202108171620462.png"></p>
<p>当然数据库连接驱动就不用多说了，一定也要导入的，这里我就不再细述了。</p>
<h5 id="step2-定义配置文件"><a href="#step2-定义配置文件" class="headerlink" title="step2. 定义配置文件"></a>step2. 定义配置文件</h5><p>使用c3p0 有两种方式，一种是硬编码，也就是配置都写在代码里，如官方文档中示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">cpds.setDriverClass( <span class="string">&quot;org.postgresql.Driver&quot;</span> ); <span class="comment">//loads the jdbc driver</span></span><br><span class="line">cpds.setJdbcUrl( <span class="string">&quot;jdbc:postgresql://localhost/testdb&quot;</span> );</span><br><span class="line">cpds.setUser(<span class="string">&quot;dbuser&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;dbpassword&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是很明显，这样的写法有许多缺点。一是代码冗余性多，二是将来代码维护的时候非常麻烦，所以我们更推荐使用配置文件的模式。</p>
<p>查看官方文档，在配置文件栏可以找到这句：</p>
<blockquote>
<p>Configuration files are normally looked up under standard names (<code>c3p0.properties</code> or <code>c3p0-config.xml</code>) at the top level of an application’s classpath, but the XML configuration can be placed anywhere in an application’s file system or classpath, if the system property <a href="https://www.mchange.com/projects/c3p0/#locating_configuration_information"><code>com.mchange.v2.c3p0.cfg.xml</code></a> is set.</p>
</blockquote>
<p>大致意思就是：通常来说配置文件的名字都应设为<code>c3p0.properties</code>或者<code>c3p0-config.xml</code>，而且该文件的位置应该在 classpath （类路径）目录，也就是 src 目录下。如果<code>com.mchange.v2.c3p0.cfg.xml</code> 指定了XML位置的话，XML文件也可以放在任意目录下。</p>
<p>根据以上信息，我们直接在 src 目录下新建<code>c3p0-config.xml</code>文件，添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--c3p0配置信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    默认配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/hk1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>987075<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--初始化连接池中申请的连接对象数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池中最大的连接数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池中最小的连接数量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超时时间(ms)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--附加配置，配置不同的数据库厂商 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;mySource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/bookstore<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做完后，数据库连接池的配置文件就准备完成。</p>
<h5 id="step3-使用示例"><a href="#step3-使用示例" class="headerlink" title="step3. 使用示例"></a>step3. 使用示例</h5><p>配置文件配好了，那么我们就用一个简单的示例来体验一下吧。</p>
<p>添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * C3P0 的简单示例</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//2.获取连接对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mchange.v2.c3p0.impl.NewProxyConnection@5fe5c6f [wrapping: com.mysql.jdbc.JDBC4Connection@6979e8cb]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>在不传参情况下，<code>new ComboPooledDataSource()</code> 创建对象使用默认构造函数，此时使用的配置为配置文件中的 <code>default-config</code> ，但我们也可以在创建对象时传入参数指定配置：<code>new ComboPooledDataSource(&quot;mySource&quot;)</code> 则指定配置文件中名为<code>mySource</code> 的配置，这样我们可以方便的在使用不同的数据库时切换不同的配置。</p>
</blockquote>
<h4 id="3-2-使用Druid"><a href="#3-2-使用Druid" class="headerlink" title="3.2 使用Druid"></a>3.2 使用Druid</h4><p>Druid 是阿里巴巴开源的一个高效的连接池实现，凭借其各方面优秀的特性，已经成为最热门的数据库连接池实现之一。</p>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvZHJ1aWQvd2lraS8lRTklQTYlOTYlRTklQTElQjU=">https://github.com/alibaba/druid/wiki/%E9%A6%96%E9%A1%B5<i class="fa fa-external-link-alt"></i></span></p>
<p>我们推荐使用Druid来使用数据库连接池。</p>
<p>下面是其使用的简单步骤：</p>
<h5 id="step1-导入-jar-包"><a href="#step1-导入-jar-包" class="headerlink" title="step1. 导入 jar 包"></a>step1. 导入 jar 包</h5><p>导包的操作和上面C3P0的方式一样，这里不再细述，这里给出Druid jar 包下载地址：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9jb20uYWxpYmFiYS9kcnVpZC8xLjEuMTA=">druid-1.1.10.jar<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="step2-使用配置文件"><a href="#step2-使用配置文件" class="headerlink" title="step2. 使用配置文件"></a>step2. 使用配置文件</h5><p>在Druid官方文档的说明中， DataSource连接池可配置的属性列表和说明如下：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>缺省值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错。<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFubW81NTUvYXJ0aWNsZS9kZXRhaWxzLzQxMjQ4NzYz">详情-点此处<i class="fa fa-external-link-alt"></i></span>。</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：<br />mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2<br /> oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvZHJ1aWQvd2lraS8lRTQlQkQlQkYlRTclOTQlQThDb25maWdGaWx0ZXI=">详细看这里<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>driverClassName</td>
<td>根据url自动识别</td>
<td>这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxPoolPreparedStatementPerConnectionSize</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。</td>
</tr>
<tr>
<td>validationQueryTimeout</td>
<td></td>
<td>单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>keepAlive</td>
<td>false<br/>（1.0.28）</td>
<td>连接池中的minIdle数量以内的连接，空闲时间超过minEvictableIdleTimeMillis，则会执行keepAlive操作。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>1分钟（1.0.14）</td>
<td>有两个含义：<br />1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。<br />2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td>30分钟（1.0.14）</td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接保持空闲而不被驱逐的最小时间</td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td>根据dbType自动识别</td>
<td>当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：<br />监控统计用的filter:stat<br />日志用的filter:log4j<br />防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<p>与上面的 C3P0 一样，这些属性也可以硬编码式的直接在代码里通过不同的 setXX() 方法设置，但不推荐。我们都推荐使用配置文件的方式，在这里，我们需要使用 Java配置文件格式 properties 来配置相应的连接池属性。</p>
<p>在 src 目录（也可以任意目录下）下，新建文件名为 druid.properties 的File文件，在里面填入一些必要的配置属性即可：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 驱动位置</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 连接路径</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/hk1</span></span><br><span class="line"><span class="comment"># 数据库用户名</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 数据库密码</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">987075</span></span><br><span class="line"><span class="comment"># 初始化时连接池连接对象的数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 连接池最大连接数量</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

<h5 id="step3-使用示例-1"><a href="#step3-使用示例-1" class="headerlink" title="step3. 使用示例"></a>step3. 使用示例</h5><p>定义好配置文件后，我们同样使用一个简单示例来介绍使用方式：</p>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid 数据库连接池的简单示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        pro.load(in);</span><br><span class="line">        System.out.println(pro);</span><br><span class="line">        <span class="comment">//2.创建数据库连接池对象</span></span><br><span class="line">        <span class="comment">//需要传入properties对象获取其中的配置信息</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">      4<span class="comment">//4.将连接对象放回连接池</span></span><br><span class="line">        <span class="comment">//使用了连接池时,close方法功能为连接对象退回连接池</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;maxActive=10, password=987075, url=jdbc:mysql://localhost:3306/hk1, driverClassName=com.mysql.jdbc.Driver, initialSize=5, username=root&#125;</span><br><span class="line">信息: &#123;dataSource-1&#125; inited</span><br><span class="line">com.mysql.jdbc.JDBC4Connection@42f93a98</span><br></pre></td></tr></table></figure>

<p>成功获取到了连接对象。</p>
<p>具体的步骤解析注释中已经介绍的很清楚了，我就不再细述了。</p>
<h2 id="二、设计结合了数据库连接池的工具类JDBCUtils"><a href="#二、设计结合了数据库连接池的工具类JDBCUtils" class="headerlink" title="二、设计结合了数据库连接池的工具类JDBCUtils"></a>二、设计结合了数据库连接池的工具类JDBCUtils</h2><p>前面我们设计了基本的 JDBCUtils 工具类，其可以帮我们简化代码，增加加代码的复用性…。在引入数据库连接池后，我们再来梳理以下我们工具类的功能：</p>
<ul>
<li>初始化数据库连接池</li>
<li>获取连接对象</li>
<li>关闭连接，并将连接对象退回连接池</li>
</ul>
<p>接下来就是各个功能的实现：</p>
<h3 id="f1-初始化数据库连接池"><a href="#f1-初始化数据库连接池" class="headerlink" title="f1. 初始化数据库连接池"></a>f1. 初始化数据库连接池</h3><p>一般来说，初始化的操作都只要执行一次而且是最早执行越好。于是我们初始化的代码可以放在 <code>static</code> 代码块中，具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库连接池引用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 静态代码块，负责连接池的初始化操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//1.加载配置文件，从中获取连接池的属性配置</span></span><br><span class="line">          pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">          in = JDBCUtils.class.getClassLoader()</span><br><span class="line">                  .getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">          pro.load(in);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.建立Druid数据库连接池并指定配置</span></span><br><span class="line">          dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="f2-获取连接对象"><a href="#f2-获取连接对象" class="headerlink" title="f2. 获取连接对象"></a>f2. 获取连接对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接池的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>附加一个获取连接池的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 连接池的引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="f3-关闭连接，并将连接对象退回连接池"><a href="#f3-关闭连接，并将连接对象退回连接池" class="headerlink" title="f3. 关闭连接，并将连接对象退回连接池"></a>f3. 关闭连接，并将连接对象退回连接池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭资源，连接对象会被归还进连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, PreparedStatement pst, Connection conn)</span>&#123;</span><br><span class="line">      <span class="comment">//关闭结果集对象</span></span><br><span class="line">      <span class="comment">//释放前应该判断对象是否为空，不为空再执行关闭操作，避免空指针异常</span></span><br><span class="line">      <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              rs.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭数据库操作对象</span></span><br><span class="line">      <span class="keyword">if</span>(pst != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              pst.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭本次连接，连接对象退回连接池</span></span><br><span class="line">      <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              conn.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭资源，连接对象会被归还进连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">      <span class="comment">//调用三参的方法，将第一个参数设为null，间接关闭两个对象</span></span><br><span class="line">      close(<span class="literal">null</span>,pst,conn);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="工具类功能合并及测试"><a href="#工具类功能合并及测试" class="headerlink" title="工具类功能合并及测试"></a>工具类功能合并及测试</h3><p>通过上面的步骤，我们的一个 JDBC工具类就设计完成了，整合后的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 引入Druid数据库连接池后的JDBC工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//数据库连接池引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码块，负责连接池的初始化操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件，从中获取连接池的属性配置</span></span><br><span class="line">            pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            in = JDBCUtils.class.getClassLoader()</span><br><span class="line">                    .getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(in);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.建立Druid数据库连接池并指定配置</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接池的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从连接池中获取一个连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接池中的一个连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源，连接对象会被归还进连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, PreparedStatement pst, Connection conn)</span>&#123;</span><br><span class="line">        <span class="comment">//关闭结果集对象</span></span><br><span class="line">        <span class="comment">//释放前应该判断对象是否为空，不为空再执行关闭操作，避免空指针异常</span></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭数据库操作对象</span></span><br><span class="line">        <span class="keyword">if</span>(pst != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                pst.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭本次连接，连接对象退回连接池</span></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源，连接对象会被归还进连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pst</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(PreparedStatement pst,Connection conn)</span>&#123;</span><br><span class="line">        <span class="comment">//调用三参的方法，将第一个参数设为null，间接关闭两个对象</span></span><br><span class="line">        close(<span class="literal">null</span>,pst,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们使用一个小示例来测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qianfanguojin</span></span><br><span class="line"><span class="comment"> * 测试工具类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 从连接池获得连接对象</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.构建带占位符的SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where password = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//4.获取SQL语句执行对象并传入带有占位符的sql语句。</span></span><br><span class="line">            pst = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//5. 对占位符进行赋值。</span></span><br><span class="line">            pst.setString(<span class="number">1</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="comment">//6.执行SQL语句，执行组装好的SQL语句。</span></span><br><span class="line">            rs = pst.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//7.对执行SQL的结果进行处理</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">pas</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名：&quot;</span> + user + <span class="string">&quot;    密码：&quot;</span> + pas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.关闭资源</span></span><br><span class="line">            JDBCUtils.close(rs,pst,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用户名：小明    密码：<span class="number">123456</span></span><br><span class="line">用户名：小李    密码：<span class="number">123456</span></span><br></pre></td></tr></table></figure>



<p>OK ，本节到这里结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/shuaihj/article/details/14223015"><strong>谈谈数据库连接池的原理</strong></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
        <tag>JDBC数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习记录（一）：HTML概念以及基本标签</title>
    <url>/2019/07/a370cf122d97.html</url>
    <content><![CDATA[<p>最近开始从头学习一遍<code>Java Web</code>，在学习的过程中，我也把学习到的东西都记录下来，供以后查阅。</p>
<p>这篇主要记录关于HTML的概念和基本标签使用的方法。</p>
<span id="more"></span>

<hr>
<h2 id="1-HTML基本信息"><a href="#1-HTML基本信息" class="headerlink" title="1. HTML基本信息"></a>1. HTML基本信息</h2><h3 id="1-1-HTML-描述"><a href="#1-1-HTML-描述" class="headerlink" title="1.1 HTML  描述"></a>1.1 HTML  描述</h3><p>HTML , 英文全称为HyperText Markup Language , 也就是超文本标记语言，是最基础的网页开发语言。</p>
<h4 id="超文本："><a href="#超文本：" class="headerlink" title="超文本："></a>超文本：</h4><p>超文本是用 <strong>链接</strong> 的方法，将各种不同空间的文字信息组织在一起的网状文本。如何理解呢，比如我打开某个导航页：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115042.png"></p>
<p>其中有各式各样的信息，我们可以通过点击上面的文本跳转到不同的页面，例如我点击左上角的 <strong>百度</strong> ，页面就会跳转到百度的页面，我点击 <strong>新浪</strong> ，页面就会跳转到新浪的页面，点击不同的超链接，可以跳转到不同的页面，在跳转到的页面我们又可以点击超链接跳转，如此层级往复，就形成了一个巨大的信息网。这就是所谓的超文本，通过链接跳转组成一个巨大的信息网。</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115057.png"></p>
<h4 id="标记语言："><a href="#标记语言：" class="headerlink" title="标记语言："></a>标记语言：</h4><p>标记语言，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。</p>
<p>通过对信息进行标记，可以将信息以不同的形式显示出来，这就是标记语言的作用。比如我标记一样东西为文本，那我用<code>&lt;font&gt;&lt;/font&gt;</code>将内容标记为文本显示。要显示图片，我就使用<code>&lt;img&gt;</code>将内容标记为图片显示。</p>
<p>标记语言（HTML）严格上不是一门编程语言，因为其没有逻辑，内容是直接定义好结果的。就比如 1+ 1 在编程语言中可以很简单的计算为 2 ,而标记语言却没有这个概念，它无法实现逻辑计算功能。</p>
<h3 id="1-2-HTML-规范"><a href="#1-2-HTML-规范" class="headerlink" title="1.2 HTML  规范"></a>1.2 HTML  规范</h3><blockquote>
<p>作为一门语言，与其他语言一样，HTML也有一套自己的规范，基本如下</p>
</blockquote>
<ol>
<li><p>每个HTML文件都必须以 <code>&lt;html&gt;</code>开始 ，以 <code>&lt;/html&gt; </code> 结束。</p>
</li>
<li><p>每个HTML文件名都是以<code>.html</code>结尾的。</p>
</li>
<li><p><code>&lt;head&gt;</code> 标签负责在初始化页面的相关信息（如标题栏）。</p>
</li>
<li><p><code>&lt;body&gt;</code> 标签负责显示页面内容，所有的页面显示的内容必须写在该标签下。</p>
</li>
<li><p>一般来说，HTML 里的标签有开始就一定要结束，例如开始为<code>&lt;head&gt;</code> ，就一定要有<code>&lt;/head&gt;</code> 来结束，也就是<code>&lt;head&gt;&lt;/head&gt;</code>。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>某些标签，例如换行，是没有结束标签的，但是HTML也为这些标签规定了一个结束规范，将<code>/</code> 放在标签名后，表示在该标签结束，如换行标签<code>&lt;br/&gt;</code></p>
</blockquote>
</li>
<li><p>HTML的代码不区分大小写，也就是说，你写<code>&lt;head&gt;</code> 和 <code>&lt;Head&gt;</code> 都能表示它为标题标签，当然，Java是严格区分大小写的。</p>
</li>
</ol>
<h3 id="1-3-HTML-的操作思想。"><a href="#1-3-HTML-的操作思想。" class="headerlink" title="1.3 HTML 的操作思想。"></a>1.3 HTML 的操作思想。</h3><p>网页中有很多数据，不同的数据可能需要不同的显示效果，这个时候需要使用标签把要操作的数据包起来（封装起来），通过秀爱标签的属性值实现标签内数据样式的变化。</p>
<p>一个标签相当于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以</p>
<p>比如我们需要在网页上显示三个不同颜色的Hello Word，我们可以使用如下代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--红色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Hello Word<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--绿色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;green&quot;</span>&gt;</span>Hello Word<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--蓝色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>Hello Word<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们首先通过<code>&lt;font&gt;</code> 标签容器将他们包起来，然后修改标签的相关属性，就可以实现对标签内数据样式的改变。</p>
<h2 id="2-HTML-基本标签"><a href="#2-HTML-基本标签" class="headerlink" title="2. HTML 基本标签"></a>2. HTML 基本标签</h2><h3 id="2-1-段落标签"><a href="#2-1-段落标签" class="headerlink" title="2.1 段落标签"></a>2.1 段落标签</h3><p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用段落标签时，浏览器会自动在段落的前后加上一个空行，但是两个段落标签之间并不产生两个空行。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">4<span class="comment">&lt;!-- 段落前后自动生成空行--&gt;</span></span><br><span class="line">aaaaaa</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  BBBBBBB</span><br><span class="line"><span class="comment">&lt;!--两个段落之间并不产生两个空行--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115104.png"></p>
<h3 id="2-2-注释标签"><a href="#2-2-注释标签" class="headerlink" title="2.2 注释标签"></a>2.2 注释标签</h3><p>实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--你要注释的内容--&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用注释后，你注释的内容不会被显示在页面上，但是这段内容依然会存在于源文件中。</p>
<h3 id="2-3-标题标签、水平线标签和特殊字符"><a href="#2-3-标题标签、水平线标签和特殊字符" class="headerlink" title="2.3 标题标签、水平线标签和特殊字符"></a>2.3 标题标签、水平线标签和特殊字符</h3><ul>
<li><p>标题标签</p>
<p>实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从h1到h6，文字大小依次变小，同时会自动换行。</p>
</li>
<li><p>水平线标签</p>
<p>实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关属性：</p>
<p><strong>size</strong> ：线的粗细，取值1 - 7</p>
<p><strong>color</strong> ：线的颜色</p>
</li>
<li><p>特殊字符</p>
<p>HTML 是一种标签语言，在HTML里，我们可以使用标签来对数据进行各种包装变换。</p>
<p>但在某些情况下，其标签化管理会出现一些问题。</p>
<p>例如我想显示<code>空格用&lt;br/&gt;</code> 这个字符串，使用文字标签来显示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span>空格用<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">font</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>可是当我们其运行到网页中时，奇怪的现象发生了，<code>&lt;br/&gt;</code> 这个字符串并没有显示在网页上。</p>
<p>这是为什么呢，其实我们稍加理解以下就应该能搞懂，在html中，<code>&lt;</code> 和 <code>&gt;</code> 这两个符号将标签包在其中，浏览器一发现这两个符号，就会执行相关的操作，而不是将其作为字符显示。</p>
<p>浏览器通过发现不同的标签来处理不同的数据，而标签其实也就是两个尖括号括子括在一起的内容，浏览器会扫描，发现是在<code>&lt;&gt;</code>之间的，就会将他们识别为标签。</p>
<p>而上面的这段代码就是如此，当浏览器发现<code>&lt;br/&gt;</code> 时，会自动将其定义为换行符的标签，执行换行操作，而不是直接将其打印出来。</p>
<p>而HTML的设计者们肯定不会允许这种bug的存在，于是，在HTML中引入了转义字符的概念，通过特殊的字符组成，来表示一个特殊的字符，例如：</p>
<table>
<thead>
<tr>
<th align="center">要表示的符号</th>
<th align="center">对应的转义字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center"><code>&amp;lt;</code></td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"><code>&amp;gt;</code></td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center"><code>&amp;nbsp;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>转义字符中的分号都为英文分号。</p>
</blockquote>
<p>那么，要表示刚才的字符串，真正的写法是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span>空格用<span class="symbol">&amp;lt;</span>br/<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-列表标签"><a href="#2-4-列表标签" class="headerlink" title="2.4 列表标签"></a>2.4 列表标签</h3><h4 id="2-4-1-有序列表"><a href="#2-4-1-有序列表" class="headerlink" title="2.4.1 有序列表"></a>2.4.1 有序列表</h4><p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="comment">&lt;!--列表项--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span> <span class="comment">&lt;!--有序列表的范围--&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器显示如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115111.png"></p>
<p><code>&lt;ol&gt;</code>相关属性：<strong>type</strong> ：设置排序的方式，也就是序号的样式，取值可以为 1 、a 、i ，设置不同值，排序显示的序号不不同，默认为1。</p>
<h4 id="2-4-2-无序列表"><a href="#2-4-2-无序列表" class="headerlink" title="2.4.2 无序列表"></a>2.4.2 无序列表</h4><p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="comment">&lt;!--列表项--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  4<span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  4<span class="tag">&lt;<span class="name">li</span>&gt;</span>css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115117.png"></p>
<p><code>&lt;ul&gt;</code>相关属性 ：</p>
<p><strong>type</strong> ：同样是设置序号的样式，有 空心圆circle、实心圆disc、实心方块square，默认为实心圆disc 。</p>
<h4 id="2-4-3-自定义列表"><a href="#2-4-3-自定义列表" class="headerlink" title="2.4.3 自定义列表"></a>2.4.3 自定义列表</h4><p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span> <span class="comment">&lt;!--自定义列表组--&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span> <span class="comment">&lt;!--自定义列表描述--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span> <span class="comment">&lt;!--自定义列表的范围--&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>java<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>html<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>css<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器显示如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115121.png"></p>
<h3 id="2-4-图像标签-img-（重要）"><a href="#2-4-图像标签-img-（重要）" class="headerlink" title="2.4 图像标签&lt; img&gt;（重要）"></a>2.4 图像标签&lt; img&gt;（重要）</h3><p>如果说一个网站中只有文字，那么这个网站就会变得非常的单调，而在如今的互联网的网页中，图片在网页显示中占了极大的比重，在HTML中，图片的显示用<code>img</code> 标签控制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片路径&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>img</code> 标签中，<code>src</code>属性是必须赋值的，你必须指定图像标签所显示的图片所在位置，该路径可以为本地也可以是网络。</p>
<p>对于路径的写法：一般分为相对路径及绝对路径。相对路径以 .&#x2F; 开始，如：<code>./01.png</code> ，绝对路径以盘符开始，如：<code>C:/01.png</code> 。</p>
<p>除<code>src</code>属性外，<code>img</code> 标签还有一些常用属性：</p>
<p><strong>width</strong> ：指定图片的宽度。</p>
<p><strong>height</strong> ：指定图片的高度。</p>
<h3 id="2-5-超链接标签-a"><a href="#2-5-超链接标签-a" class="headerlink" title="2.5 超链接标签&lt; a&gt;"></a>2.5 超链接标签&lt; a&gt;</h3><p>通过超链接标签将多个页面组合起来，可以从当前页面跳到一个指定位置，这个位置可以是页面的某个位置或者另外一个页面的链接。</p>
<p> 语法方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;链接地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如跳转到百度：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--href 属性指定资源位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然也可以跳转到网页的指定位置，使用<code>#</code> 指定网页的位置，如跳转到网页顶端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>点我跳到网页顶端<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>URL 的格式：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>URL</em></td>
<td align="left">超链接的 URL。可能的值：绝对 URL - 指向另一个站点href&#x3D;”<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">https://www.baidu.com<i class="fa fa-external-link-alt"></i></span>“ <br />相对 URL - 指向站点内的某个文件（href&#x3D;”index.htm”）<br />锚 URL - 指向页面中的锚（href&#x3D;”#top”），跳到指定标签位置，请在#后加该标签的id属性值。</td>
</tr>
</tbody></table>
<p>相关属性：</p>
<p><strong>targe：</strong> target指定跳转的方式 默认为 self ，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>在本页跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>在新标签页跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="2-6-表格标签"><a href="#2-6-表格标签" class="headerlink" title="2.6 表格标签"></a>2.6 表格标签</h3><p><code>&lt;table&gt;&lt;/table&gt;</code> 用来定义一个表格。</p>
<p><code>&lt;tr&gt;&lt;/tr&gt;</code>定义表格中的一行。</p>
<p><code>&lt;td&gt;&lt;/td&gt; </code>定义表格中的一个单元格。</p>
<p><code>&lt;th&gt;&lt;/th&gt;</code> 定义表头单元格。</p>
<p><code>&lt;caption&gt;</code> 定义表格的标题。</p>
<p>定义一个基本的学生信息表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义一个简单的学生信息表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">cellpadding</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    4  <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小李<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小华<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>300<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115129.png"></p>
<p>在表格中，也有一些语义化标签供我们使用：</p>
<p><code>thead</code> : 表示表格的头部份。</p>
<p><code>tbody</code> : 表示表格的内容体部分。</p>
<p><code>tfoot</code>：表示表格的脚部分。</p>
<blockquote>
<p>这些标签不附加任何样式，但是有严格的<strong>位置控制</strong>规定，且不受代码位置影响。thead中 显示在表格<strong>最上方</strong>，tbody中内容显示在 <strong>thead 下面</strong>，tfoot 中内容显示在 <strong>tbody 下面</strong>。</p>
</blockquote>
<p>例如我修改上面的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义一个简单的学生信息表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表格标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--表示为结尾--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--表示为内容体--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小李<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--表示为标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小华<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>300<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示的效果为：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115134.png"></p>
<p>表格的相关属性：</p>
<ul>
<li><p>table 标签的属性</p>
<p><strong>border：</strong>设置边框大小，默认为0不显示。</p>
<p><strong>width：</strong> 设置表格的宽度。</p>
<p><strong>cellspacing：</strong> 定义单元格之间的距离。</p>
<p><strong>align：</strong>设置表格在浏览器的位置</p>
</li>
<li><p>tr 标签的属性</p>
<p><strong>bgcolor：</strong>设置该行的背景色。</p>
<p><strong>align：</strong>设置该行单元格内容的显示位置，如设置<code>align=&quot;center&quot;</code> 该行单元格内容为居中显示。</p>
</li>
<li><p>td 标签的属性</p>
<p><strong>colspan</strong>：单元格所占的列数。</p>
<p><strong>rowspan：</strong>单元格所占的行数。</p>
</li>
</ul>
<h3 id="2-7-语义化标签"><a href="#2-7-语义化标签" class="headerlink" title="2.7 语义化标签"></a>2.7 语义化标签</h3><p>语义化标签是指一些负责标识位置的标签，也不会产生实际的样式，只是为了给开发人员方便阅读代码所用而已。</p>
<p>HTML5以后引入了许多的语义化标签，大多是时候我们只要使用如下几种：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表示这里的内容在页面头部显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表示这里的内容为导航栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--表示这里面的内容在页面底部显示--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>语义化标签页可以理解为一种注释，只是负责说明而已，并不会对实际的数据进行样式修改。</p>
<h3 id="2-8-块标签以及内联标签"><a href="#2-8-块标签以及内联标签" class="headerlink" title="2.8 块标签以及内联标签"></a>2.8 块标签以及内联标签</h3><p>在HTML中，标签总体可以分为两大类。</p>
<p>一类是块标签，如：<code>&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;，&lt;div&gt;</code>，块标签占用了全部宽度，在前后都是换行符，这些标签在浏览器显示时会开启一个新行来显示和结束内容，无论你是否在该标签使用前使用换行。</p>
<p>第二类是内联标签，如：<code>&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</code>，内联标签只需要必要的宽度，不强制换行。这些标签在浏览器显示时通常不会开新行显示，除非前者标签已经占满一行的位置。</p>
<p>下面使用一个例子来简要说明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>块标签和内联标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 块标签区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>块标签示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题一<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>没有在标题h6后加换行，块级元素div自动新开一行显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有在div后加换行，块级元素p自动新开一行显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 内联标签区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>内联标签示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>h2标题标签为块标签，内容结尾新开一行，这里的文本显示在标题下方。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>内联标签a会和span标签在同一行<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>内联标签会一直并列排放，直到充满浏览器再到下一行111111111111111</span><br><span class="line">        111111111111111111111111111111111111111111111111111111111111<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>也可以使用换行来跳到下一行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/hexo/20200312115139.png"></p>
<p><span style="color:blue">注意：</span></p>
<ul>
<li>块标签的新开一行其实就是换行，中间的空行都是外边距。</li>
<li>虽然块标签在前后都产生空行，但是块标签与块标签之间的空行不会叠加。</li>
<li>在大多数时候，我们都要记得 <code>div</code> 为块标签，<code>span</code>为内联标签，因为这两个标签在以后我们们编写网页时用的最多。</li>
</ul>
]]></content>
      <categories>
        <category>Java Web</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Jave Web</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习记录（二）：HTML中的表单标签使用</title>
    <url>/2019/08/9d7e1457832e.html</url>
    <content><![CDATA[<p>上篇文章主要介绍了 HTML 的一些基本标签的使用，这些标签如何使用美化和我们后端来说都没有很大的关系，我们关心的更多的是数据的交互。</p>
<p>这篇文章就来介绍我们后端关注的 HTML 中一个重要的标签：<strong>表单<code>&lt;form&gt;</code></strong> 标签</p>
<span id="more"></span>

<hr>
<h2 id="1-什么是表单"><a href="#1-什么是表单" class="headerlink" title="1. 什么是表单"></a>1. 什么是表单</h2><p>概念：用于采集用户输入的数据，用于和服务器进行交互。</p>
<p>最明显的一个例子就是登陆注册页面，用户登陆时在表单中填写数据，然后表单通过 get &#x2F; post 等方式将数据发给服务器进行登陆的操作。</p>
<h2 id="2-快速使用"><a href="#2-快速使用" class="headerlink" title="2 快速使用"></a>2 快速使用</h2><p>简单的使用方式：</p>
<p><code>&lt;form&gt;&lt;/form&gt; </code>定义一个表单范围。</p>
<p><code>&lt;input&gt;</code> 定义表单中的输入元素，根据指定不同的类型可以显示不同的功能，包括文本字段、复选框、单选框、提交按钮等。</p>
<p>一个简单的表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101617902.png"></p>
<p>显示两个 input 框，默认输入为文本类型元素。</p>
<hr>
<h2 id="3-标签属性详解"><a href="#3-标签属性详解" class="headerlink" title="3. 标签属性详解"></a>3. 标签属性详解</h2><h3 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 &lt;form&gt;标签"></a>3.1 <code>&lt;form&gt;</code>标签</h3><p><strong>action：</strong> 指定表单要提交到的路径（URL）。</p>
<p><strong>method：</strong>提交表单时的方式，常用的有一下两种：</p>
<ul>
<li><p>第一种：Get    速度更快，提交的数据会在地址栏显示，通过 &amp; 拼接显示，封装在请求行中，不太安全。</p>
</li>
<li><p>第二种：Post  提交的数据不会在地址栏显示。封装在请求体中，更安全。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--get post示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Get<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Post<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101618823.gif"></p>
</li>
</ul>
<h3 id="3-2-标签"><a href="#3-2-标签" class="headerlink" title="3.2 &lt;input&gt;标签"></a>3.2 <code>&lt;input&gt;</code>标签</h3><p><strong>name：</strong> 指定该input元素的名字，每个input名字唯一，服务器接收到表单通过name属性区别表单中不同的input元素</p>
<p><strong>value：</strong>指定该input元素的默认值。</p>
<p><strong>type：</strong> 指定该input元素的类型。</p>
<p><span style="color:blue">基本类型：</span></p>
<ul>
<li><p>text ：输入文本 (默认类型) 。</p>
</li>
<li><p>password：输入密码，输入的数据会被特殊字符代替。</p>
<blockquote>
<ul>
<li>通过指定输入框的 placeholder 属性值可以实现输入提示，提示会在输入字段为空时显示，并会在字段获得焦点时消失。</li>
</ul>
</blockquote>
</li>
<li><p>radio：单选框，</p>
</li>
<li><p>checkbox：复(多)选框。</p>
<blockquote>
<ul>
<li>指定 type 为单选或者复选的input元素 <code>name</code> 属性必须相同，且必须设置 value 属性的值来区别不同的选项。</li>
<li>可以通过设置 input 元素的 checked 属性来给设定某个选项默认被选中。</li>
</ul>
</blockquote>
<p>一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--input 元素类型解析--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>input 元素不同的类型示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用radio单选框时，选项的name属性必须一样--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>默认勾选单选框中的性别为男，多选框中的爱好为学习<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    性别:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    爱好:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">checked</span>&gt;</span>学习</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>努力学习</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>刻苦学习<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101618031.gif"></p>
</li>
</ul>
<p><span style="color:blue">更多类型：</span></p>
<ul>
<li>file: 文件上传按钮。</li>
<li>submit：提交表单按钮。</li>
<li>button：简单的按钮，默认没有任何实现效果。</li>
<li>image：定义图像类型的提交按钮，点击该图像，表单会被提交。</li>
<li>hidden：定义一些隐藏字段，在浏览器上不显示任何效果。</li>
</ul>
<h3 id="3-3-标签。"><a href="#3-3-标签。" class="headerlink" title="3.3 &lt;label&gt;标签。"></a>3.3 <code>&lt;label&gt;</code>标签。</h3><p>功能概述：label 标签可以实现对 input 元素定义标注（标记）。通过 label 标签将 input 元素前的文字包裹起来，再将 label 标签中 <code>for</code> 属性值与 input 元素中的 id 属性值对应，此时点击 input 元素前的文本可以使 input 元素获得焦点。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--label 标签示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>不使用label<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    男：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">    女：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用label<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101619857.gif"></p>
<h3 id="3-4-下拉列表标签"><a href="#3-4-下拉列表标签" class="headerlink" title="3.4 下拉列表&lt;select&gt;标签"></a>3.4 下拉列表<code>&lt;select&gt;</code>标签</h3><p><code>&lt;select&gt;</code> 标签用来创建下拉列表。</p>
<p>在<code>&lt;select&gt;</code> 标签中，使用<code>&lt;option&gt;</code>标签来标识每一个下拉列表的选项。</p>
<p>属性解析：</p>
<p><code>&lt;seclect&gt;</code>标签属性</p>
<ul>
<li><strong>name：</strong>指定其name属性值可作为与服务器交互数据的HTML元素的服务器端的标示，我们可以在服务器端根据其Name取得元素提交的值。</li>
</ul>
<p><code>&lt;option&gt;</code>标签属性</p>
<ul>
<li><strong>value：</strong>该属性值指定下拉列表被送往服务器的内容。通过该值给下拉列表中不同的选项指定值，以让服务器接收到对选择的选项进行判定。</li>
</ul>
<p>演示示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--select标签示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>select 标签示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span> <span class="attr">id</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>法国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>英国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101618247.gif"></p>
<h3 id="3-5-文本域标签"><a href="#3-5-文本域标签" class="headerlink" title="3.5 文本域&lt;textarea&gt;标签"></a>3.5 文本域<code>&lt;textarea&gt;</code>标签</h3><p><code>&lt;textarea&gt;</code> 标签定义一个多行的文本输入控件，可以容纳无限数量的文本，一般使用在一些填写详细信息或者大容量文本的地方。</p>
<p>属性解析：</p>
<ul>
<li><p><strong>cols：</strong>规定文本输入控件的可见列数。</p>
</li>
<li><p><strong>rows：</strong>规定文本输入控件的可见行数（不够会自动扩容）。</p>
<blockquote>
<p>这两个属性值在不同的浏览器中显示不一样，敬请参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTYvMDIvaHRtbC10ZXh0YXJlYS1yb3dzLWhlaWdodC8=">https://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>演示示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--textarea标签示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>textarea 标签示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--15行(cols)15列(rows)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;15&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101618988.png"></p>
]]></content>
      <categories>
        <category>Java Web</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Jave Web</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习记录（三）：CSS概念和基本使用</title>
    <url>/2019/08/59d9da3873f5.html</url>
    <content><![CDATA[<p>在HTML的学习中，我们通过使用HTML可以构建网页中的各种元素。</p>
<p>但HTML只定义了元素的类型，不能对其的样式进行多样化的修改。为了多样化的修改样式，我们引入了<code>CSS</code>(<strong>层叠样式表</strong>)。</p>
<span id="more"></span>

<h2 id="1-CSS初识"><a href="#1-CSS初识" class="headerlink" title="1. CSS初识"></a>1. CSS初识</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>Wiki：<strong>层叠样式表</strong>（英语：<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets，缩写：<strong>CSS</strong>；又称<strong>串样式列表</strong>、<strong>级联样式表</strong>、<strong>串接样式表</strong>、<strong>阶层式样式表</strong>）是一种用来为结构化文档（如<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRNTA==">HTML<i class="fa fa-external-link-alt"></i></span>文档或<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvWE1M">XML<i class="fa fa-external-link-alt"></i></span>应用）添加样式（字体、间距和颜色等）的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU4JUFGJUFEJUU4JUE4JTgw">计算机语言<i class="fa fa-external-link-alt"></i></span>，由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVzND">W3C<i class="fa fa-external-link-alt"></i></span>定义和维护。</p>
<p>层叠：多个样式可以作用在同一个HTML的元素上，同时生效。</p>
<p>理解：通俗来讲，CSS就是负责将HTML中的元素进行美化加工的一种语言。</p>
<h3 id="1-2-好处"><a href="#1-2-好处" class="headerlink" title="1.2 好处"></a>1.2 好处</h3><ul>
<li>功能强大，可以对元素进行多种样式加工</li>
<li>降低代码耦合度。CSS 代码 和 HTML 代码可以分开，HTML负责内容，CSS负责样式，提高开发效率</li>
<li>可复用性。同一份CSS代码可以应用于多个元素。</li>
</ul>
<h2 id="2-CSS与HTML结合的三种方式"><a href="#2-CSS与HTML结合的三种方式" class="headerlink" title="2. CSS与HTML结合的三种方式"></a>2. CSS与HTML结合的三种方式</h2><h3 id="2-1-内联样式"><a href="#2-1-内联样式" class="headerlink" title="2.1 内联样式"></a>2.1 内联样式</h3><p>示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 方式一，内联样式。在标签内使用style属性指定CSS代码</span></span><br><span class="line"><span class="comment">     不推荐使用该方式，会增加程序的耦合性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>内联样式示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>CSS&amp;HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101653201.png"></p>
<h3 id="2-2-内部样式"><a href="#2-2-内部样式" class="headerlink" title="2.2 内部样式"></a>2.2 内部样式</h3><p>示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>内部样式方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在head中通过style标签编写CSS代码 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作用域为当前HTML文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这种方式比较常用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>内部样式示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101653656.png"></p>
<h3 id="2-3-外部样式"><a href="#2-3-外部样式" class="headerlink" title="2.3 外部样式"></a>2.3 外部样式</h3><p>创建一个<code>.css</code>结尾的css源码文件负责存放css代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: orange</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在HTML代码中引入该CSS文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>外部样式方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个单独的CSS文件来放CSS代码，在head标签中使用link标签引入CSS资源文件，推荐使用这种方式。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作用域为所有的html文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/外部.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 也可以在style标签中使用@import来引入css文件,不推荐使用这种方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@import</span> <span class="string">&quot;css/外部.css&quot;</span>;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>外部样式示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101653645.png"></p>
<h3 id="2-4-三种结合方式的优先级"><a href="#2-4-三种结合方式的优先级" class="headerlink" title="2.4 三种结合方式的优先级"></a>2.4 三种结合方式的优先级</h3><p>为什么会有优先级？</p>
<p>为了</p>
<ol>
<li><p>内部样式与外部样式：<strong>就近原则</strong></p>
<p>同时使用了内部样式和外部样式的情况下，优先采用距离元素最近的样式，声明在下方的样式优先级更高。</p>
<p>例如：</p>
<p>假设外部样式 a.css 中的 css 代码设置内容颜色为红色，此时内部样式中 css 代码设置内容颜色为蓝色。</p>
<p>由于内部样式声明的位置在更下方，也就是元素离其更近，按照就近原则，元素采用内部样式，即显示为蓝色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--a. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/a.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内联样式：<strong>覆盖所有其他样式</strong></p>
<p>如果元素设定了内联样式，元素都会优先采用内联样式中的样式代码，无论此时元素是否受到其他的样式。内联样式代码会覆盖所有其他方式的样式代码。</p>
</li>
</ol>
<h2 id="3-CSS-基本语法"><a href="#3-CSS-基本语法" class="headerlink" title="3. CSS 基本语法"></a>3. CSS 基本语法</h2><h3 id="3-1-CSS-语法格式"><a href="#3-1-CSS-语法格式" class="headerlink" title="3.1 CSS 语法格式"></a>3.1 CSS 语法格式</h3><p>CSS 的语法其实就是键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">44属性名1:属性值 属性值 属性值;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择器</strong>是对相同特征的元素进行筛选，例如选择器名为 <code>div</code> 那么选择器里的属性只作用于 <code>div</code> 这个元素中。</p>
<p><strong>属性名</strong>是CSS中中可用的属性名，如 <code>width</code>属性控制元素的宽度。</p>
<p><strong>属性值</strong>是该属性可使用的控制值，对于同一个属性，可以设置多个属性值表示该属性的多种细节，多个属性值之间使用空格隔开。如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure>

<p>这段CSS代码指定边框大小为1px，边框线为实线，边框颜色为红色。</p>
<p><span style="color:blue">注意：<br></span>每个属性和属性值的键值对结束都要用分号结尾，类似我们在每行代码的结尾必须使用分号一样。</p>
<h3 id="3-2-CSS-基础选择器"><a href="#3-2-CSS-基础选择器" class="headerlink" title="3.2 CSS 基础选择器"></a>3.2 CSS 基础选择器</h3><h4 id="3-2-1-ID-选择器"><a href="#3-2-1-ID-选择器" class="headerlink" title="3.2.1 ID 选择器"></a>3.2.1 ID 选择器</h4><p>概念：使用元素中的 ID 属性值作为选择器，选择具有特定ID属性值的元素。</p>
<p>在HTML中，我们可以给每一个元素（标签）都定义一个 id 属性值。</p>
<p>在CSS中，可以利用元素的 ID属性值作为选择器，然后对该元素使用CSS样式操作。</p>
<p>ID 选择器的语法格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#id属性值&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS的基础选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.id选择器：选择器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>使用id选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101654924.png"></p>
<p><span style="color:blue">注意：</span> 由于元素的 ID 值不仅仅应用于CSS中，为了减少可能出现的异常，在一个HTML文件中，每一个元素的ID最好是<strong>唯一</strong>的，使浏览器能够正常解析不同的 <strong>id属性值</strong> 来给不同的元素添加样式。这样不仅仅是为了方便开发人员查看，也是给自己养成一种优良的习惯。</p>
<h4 id="3-2-2-元素选择器"><a href="#3-2-2-元素选择器" class="headerlink" title="3.2.2 元素选择器"></a>3.2.2 元素选择器</h4><p>概念：使用元素名称作为选择器，选择具有相同元素（标签）名的元素。</p>
<p>元素选择器较为简单，直接使用元素名做选择器，控制该元素的样式。</p>
<p>元素选择器的语法格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素(标签)名&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS的基础选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.元素选择器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>使用元素选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101654177.png"></p>
<h4 id="3-2-3-类选择器"><a href="#3-2-3-类选择器" class="headerlink" title="3.2.3 类选择器"></a>3.2.3 类选择器</h4><p>概念：使用元素的<strong>class</strong>属性值作为选择器，选择具有相同 <strong>class</strong> 属性值的元素。</p>
<p>多个相同(或不同)类型的元素可以拥有相同的 <strong>class</strong> 属性值，我们可以通过将多个元素设置相同的 <strong>class</strong> 属性值，通过一个类选择器控制多个元素（标签）的样式。</p>
<p>类选择器的语法格式为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class属性值&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS的基础选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cls</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.类选择器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>使用类选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101654683.png"></p>
<h4 id="3-2-4-三个基础选择器的优先级"><a href="#3-2-4-三个基础选择器的优先级" class="headerlink" title="3.2.4 三个基础选择器的优先级"></a>3.2.4 三个基础选择器的优先级</h4><p>CSS提供的多种选择器能够帮助我们灵活的操控元素的样式，但是如果多个选择器出现在了同一元素上时，元素应使用哪个呢？</p>
<p>例如一个元素内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>使用类选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该 div 元素既有类属性值，也有 id 属性值，假设我们都给两个属性都设置选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;</span><br><span class="line">44<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">44<span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的样式是 <strong>ID选择器</strong>中的还是<strong>class类选择器</strong>中的呢？</p>
<p>和上方CSS代码的结合方式不同具有不同的优先级一样，在CSS样式中，规定基本选择器的优先级为：</p>
<p><strong>ID选择器</strong> &gt; <strong>类选择器</strong> &gt; <strong>元素选择器</strong>，优先级高的选择器样式会覆盖优先级低的样式。所以在刚才的例子中，会采用 ID选择器<code>#div1</code> 中的样式内容。</p>
<h3 id="3-3-CSS-扩展选择器"><a href="#3-3-CSS-扩展选择器" class="headerlink" title="3.3 CSS 扩展选择器"></a>3.3 CSS 扩展选择器</h3><h4 id="3-3-1-全元素选择器"><a href="#3-3-1-全元素选择器" class="headerlink" title="3.3.1 全元素选择器"></a>3.3.1 全元素选择器</h4><p>概念：使用符号 <code>*</code>做选择器，选择该html文件中的所有元素，一般用于全局样式。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-并集选择器"><a href="#3-3-2-并集选择器" class="headerlink" title="3.3.2 并集选择器"></a>3.3.2 并集选择器</h4><p>概念：元素名之间使用 <code>,</code> 作为分隔符，并列在一起作为选择器，选择选择器名中出现的所有元素。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素名1,元素名2&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br><span class="line">如：</span><br><span class="line">div,p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">选择所有的 div,p元素</span><br></pre></td></tr></table></figure>



<h4 id="3-3-3-子选择器"><a href="#3-3-3-子选择器" class="headerlink" title="3.3.3 子选择器"></a>3.3.3 子选择器</h4><p>概念：元素名之间使用 <code> </code> 空格作为分隔符，并列在一起作为选择器，功能为选择前者元素内部所有的后者元素。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素名1 元素名2&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br><span class="line">如：</span><br><span class="line">div p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">选择div元素中所有的 p元素</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-父选择器"><a href="#3-3-4-父选择器" class="headerlink" title="3.3.4 父选择器"></a>3.3.4 父选择器</h4><p>概念：元素名之间使用符号 <code>&gt;</code> 作为分隔符，并列在一起作为选择器，功能为选择前者元素中的所有后者元素。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">元素名1&gt;元素名2&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br><span class="line">如：</span><br><span class="line">div&gt;p&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">选择父元素为div的所有 p元素</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-属性选择器"><a href="#3-3-5-属性选择器" class="headerlink" title="3.3.5 属性选择器"></a>3.3.5 属性选择器</h4><p>概念：使用元素名和在<code>[]</code>中指定元素的属性值作为选择器，选择具有指定属性值的元素。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素名[属性名=&quot;属性值&quot;]&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br><span class="line">如：</span><br><span class="line">input[type=&quot;text&quot;]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">选择具有type=&quot;text&quot; 属性值的input元素</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-伪类选择器"><a href="#3-3-5-伪类选择器" class="headerlink" title="3.3.5 伪类选择器"></a>3.3.5 伪类选择器</h4><p>概念：元素名和元素状态之间使用符号<code>:</code>分隔，并列在一起作为选择器，功能为选择所有具有指定元素状态的元素。</p>
<p>语法格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素名:元素状态&#123;</span><br><span class="line">44属性名1:属性值1;</span><br><span class="line">44属性名2:属性值2;</span><br><span class="line">44属性名3:属性值3;</span><br><span class="line">44..........</span><br><span class="line">&#125;</span><br><span class="line">如：</span><br><span class="line">a:link&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">选择所有在未被访问状态下的超链接a元素。</span><br></pre></td></tr></table></figure>

<p>这个选择器比较特殊，因为并不是所有的元素都具有不同的元素状态，只有在一些元素中，这个选择器的特性才能发挥出来。</p>
<p>为了更好的理解伪类选择器的用法，我们以超链接元素<code>&lt;a&gt;</code>为例。</p>
<p>首先我们要知道超链接元素一共具有四个状态：</p>
<ul>
<li>未被访问状态，对应状态名为<strong>link</strong>。</li>
<li>已被访问状态，对应状态名为<strong>visited</strong>。</li>
<li>活动状态(链接上被点击时，它就会成为活动的（激活的）)，对应状态名为<strong>active</strong>。</li>
<li>获取到鼠标指针状态(鼠标悬浮在链接上时)，对应状态名为<strong>hover</strong>。</li>
</ul>
<p>在默认情况下，超链接的四种状态如下图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101655386.gif"></p>
<p>获取到鼠标指针时为蓝色，未被访问时为蓝色，活动状态时为红色，访问后为一种类深红色。</p>
<p>我们使用伪类选择器对四种状态的颜色进行修改，样式代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: violet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时超链接的四种如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101655941.gif"></p>
<p>如我们样式所改，获取到鼠标指针时为紫色，未被访问时为红色，活动状态时为绿色，访问后为一种蓝色。</p>
<p>在不同状态下对超链接的样式修改当然不至于颜色，还可以修改字体、下划线、背景图等等…..。</p>
<h2 id="4-CSS-常用属性"><a href="#4-CSS-常用属性" class="headerlink" title="4. CSS 常用属性"></a>4. CSS 常用属性</h2><h3 id="4-1-字体、文本"><a href="#4-1-字体、文本" class="headerlink" title="4.1 字体、文本"></a>4.1 字体、文本</h3><ol>
<li>font-size：字体大小。</li>
<li>color：文本颜色。</li>
<li>text-align：对其方式。</li>
<li>line-height：行高。</li>
</ol>
<h3 id="4-2-背景"><a href="#4-2-背景" class="headerlink" title="4.2 背景"></a>4.2 背景</h3><ol>
<li>background：设置背景，图片、颜色…。</li>
</ol>
<h3 id="4-3-边框"><a href="#4-3-边框" class="headerlink" title="4.3 边框"></a>4.3 边框</h3><ol>
<li>border：边框。</li>
</ol>
<h3 id="4-4-尺子"><a href="#4-4-尺子" class="headerlink" title="4.4 尺子"></a>4.4 尺子</h3><ol>
<li>width：宽度。</li>
<li>height：高度。</li>
</ol>
<h2 id="5-CSS盒子模型"><a href="#5-CSS盒子模型" class="headerlink" title="5. CSS盒子模型"></a>5. CSS盒子模型</h2><p>在一个HTML页面中，会存在许许多多的元素，每个元素都应拥有一个范围。于是在CSS中，引入了<strong>盒子模型</strong>(box model)，将每个元素都看作一个盒子，并将盒子细分为多个不同的部分，如图：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101655573.gif"></p>
<p>其中</p>
<ul>
<li>margin 为盒子的外边距，该部分指定不同元素边框与边框之间的相关属性。</li>
<li>border 为盒子的边框，该部分指定元素的边框相关的属性。</li>
<li>padding 为盒子的内边距，该部分指定元素的内容与边框之间的相关属性。</li>
<li>content 为盒子的内容，该部分指定元素的实际内容相关的属性。</li>
</ul>
<p>元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<p>在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p><span style="color:blue">注意：<br></span></p>
<ul>
<li>内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。</li>
<li>外边距可以是负值，而且在很多情况下都要使用负值的外边距。</li>
</ul>
]]></content>
      <categories>
        <category>Java Web</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Jave Web</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Desktop：在Ubuntu中安装使用搜狗输入法</title>
    <url>/2019/09/10d2922a0dd2.html</url>
    <content><![CDATA[<p>刚安装好 <code>Ubuntu</code> 之后，为了让我们更好的从 <code>Windows</code> 转换到 <code>Linux</code> 的日常使用，安装我们在 <code>Windows</code> 使用的各种必要软件是首要的。</p>
<p>本篇文章介绍如何配置使用中文输入法，以我们最常用的 <code>搜狗输入法</code> 为例。</p>
<span id="more"></span>

<p><strong>注意：</strong>此篇文章的内容都基于最新版 ubuntu18.04 LTS 系统实现，如您的系统版本为其他版本，请自行甄别步骤中可能会出现的错误。</p>
<h3 id="一、Fcitx-搜狗输入法"><a href="#一、Fcitx-搜狗输入法" class="headerlink" title="一、Fcitx &amp; 搜狗输入法"></a>一、Fcitx &amp; 搜狗输入法</h3><p><code>Fcitx</code> [ˈfaɪtɪks] 是一个支持扩展的输入法框架。它有自己维护的三个输入法，拼音，区位和码表；还支持其他引擎，rime 中州韵，<code>google-pinyin</code>，<code>sunpinyin</code>。<code>Fcitx</code> 尝试提供在所有桌面环境下原生的体验，并保持其内核轻量。你可以很简单的将其按照你的需要进行配置。<code>Fcitx</code>的出现解决了<code>Linux</code>下没有一个好的中文输入法的问题。</p>
<p>搜狗输入法<code>Linux</code>版也是基于<code>Fcitx</code>框架而编写的，安装搜狗输入法必须先安装<code>Fcitx</code>框架。</p>
<h3 id="二、安装配置Fcitx输入法框架"><a href="#二、安装配置Fcitx输入法框架" class="headerlink" title="二、安装配置Fcitx输入法框架"></a>二、安装配置Fcitx输入法框架</h3><h4 id="1-安装Fcitx"><a href="#1-安装Fcitx" class="headerlink" title="1. 安装Fcitx"></a>1. 安装Fcitx</h4><p><code>Fcitx</code>输入法框架的软件包都放在<code>Ubuntu</code>的软件源仓库中，可以直接通过命令从远程安装。但为了减少可能出现的问题，最好先更新一下软件源信息。打开命令行工具 <code>Terminal</code>，执行更新软件源的命令：</p>
<blockquote>
<p>sudo 命令表示执行命令时以root权限执行，执行时需要验证当前登录用户的密码。默认情况下ubuntu的用户为普通用户，无法执行一些重要的命令。</p>
</blockquote>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101659921.png" alt="2-01"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656779.png"></p>
<p>这里由于我已经更新过，所以没有可下载的了。</p>
<p>然后通过 apt-get 命令安装<code>Fcitx</code>的软件包，在 <code>Terminal</code> 命令行工具中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx</span><br></pre></td></tr></table></figure>



<h4 id="2-配置Fcitx"><a href="#2-配置Fcitx" class="headerlink" title="2. 配置Fcitx"></a>2. 配置Fcitx</h4><p>通过上面的步骤，我们的<code>Fcitx</code>输入法框架已经安装好了，但是<code>ubuntu</code>的默认输入法系统为自带的<code>IBUS</code>，其对中文的支持不太好，我们将其切换到 <code>Fcitx</code>。</p>
<p>打开应用列表，找到 **语言支持(Language Support)**，</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656482.png"></p>
<p>将输入系统改为<code>fcitx</code> ：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656221.png"></p>
<p>最后重启系统，如果不重启的话大概率不生效。</p>
<h3 id="三、安装并配置搜狗输入法"><a href="#三、安装并配置搜狗输入法" class="headerlink" title="三、安装并配置搜狗输入法"></a>三、安装并配置搜狗输入法</h3><h4 id="1-安装搜狗输入法"><a href="#1-安装搜狗输入法" class="headerlink" title="1. 安装搜狗输入法"></a>1. 安装搜狗输入法</h4><p>配置<code>Fcitx</code>之后，接下来就是安装搜狗输入法的软件包了。</p>
<p>使用默认的火狐浏览器打开搜狗拼音<code>Linux</code>版的下载页：<span class="exturl" data-url="aHR0cHM6Ly9waW55aW4uc29nb3UuY29tL2xpbnV4Lz9yPXBpbnlpbg==">https://pinyin.sogou.com/linux/?r=pinyin<i class="fa fa-external-link-alt"></i></span></p>
<p>选择需要下载的位数，系统为32位下载32位版，系统64位下载64位版。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656657.png"></p>
<p>出现这个页面：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656434.png">)</p>
<p>点击ok直接打开自带软件包管理程序安装，或者保存文件然后双击文件安装。</p>
<p>避免麻烦，我们点击 <code>ok</code> ,在弹出的页面中点击<code>install</code>。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656640.png"></p>
<p>静等安装完成。</p>
<h4 id="2-配置搜狗输入法"><a href="#2-配置搜狗输入法" class="headerlink" title="2. 配置搜狗输入法"></a>2. 配置搜狗输入法</h4><p>打开应用列表，找到 <code>Fcitx Configuration</code>：</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656371.png"></p>
<p>点击左下角<code> +</code> 添加输入法，搜索搜狗输入法(因为是英文所以搜索Sogou)，选择然后点击 ok</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101656229.png"></p>
<blockquote>
<p> 刚安装好搜狗输入法可能这里搜索不出来，如果无法搜索到，重启一次系统或者过段时间再搜索即可。</p>
</blockquote>
<p>最后测试一下是否成功配置，默认为英文输入，使用 <strong>Ctrl + Space(空格)</strong> 切换输入法。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/202109101657771.png"></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ol>
<li>操作过程中如果遇到错误或者奇怪的问题，请不要随意修改配置，可以先重启电脑再试试，可能是一些内存中的配置混乱。</li>
<li>Linux 的操作就是需要一个不断折腾的心，但是也能享受到折腾的乐趣。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Desktop：修改Ubuntu默认语言为中文</title>
    <url>/2019/09/9c28a637d5b0.html</url>
    <content><![CDATA[<p>在安装 <code>Ubuntu</code>时，如果不对其进行特殊的配置，安装好之后的默认显示语言为英语。</p>
<p>对于英语不好的同学来说使用起来可能有点吃力，这次我们就通过一些设置，将 Ubuntu 的默认语言改为中文。</p>
<span id="more"></span>

<h3 id="修改步骤"><a href="#修改步骤" class="headerlink" title="修改步骤"></a>修改步骤</h3><ol>
<li><p>首先打开应用列表，找到 <strong>Language Suport</strong>，点击进去，一般来说第一次进入这个页面，会提示你更新数据，我们更新即可。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619204922.png"></p>
<blockquote>
<p>如果进去时没有弹出提示你更新数据，请你检查下面步骤中的安装语言列表中是否有 <code>Chinese</code>中文语言选项。</p>
<ul>
<li><p>如能找到，请继续按照步骤介绍内容来。</p>
</li>
<li><p>如找不到或者说只有 English 一门语言，请打开命令行工具 <code>Terminal</code>，执行刷新软件的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>然后再重新进入 Language Support 应用，此时应该就会提示您更新数据了。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>更新数据完成后，点击下方的 <strong>Install&#x2F;Remove Languages</strong>，选择安装简体中文Chinese (simplified)，点击 apply 提交。</p>
<p>  <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619205002.png"></p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619205038.png"></p>
</li>
<li><p>将安装的中文(汉语) 设为首选语言，并修改日期，数字的格式为中文，然后提交修改（需验证密码）。</p>
<p><strong>注意：</strong>修改完成之后，记得注销或是重启系统，设置才会生效。</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619205049.gif"></p>
</li>
<li><p>最后效果如图</p>
<p> <img data-src="https://fastly.jsdelivr.net/gh/qianfanguojin/ImageHosting_1/others/20210619205105.png"></p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在摸索如何将 Ubuntu 的语言修改为中文时，走了许多弯路。安装好了中文语言，没有意识到语言项拖动到第一就是首选语言，或是说又忘了设置的生效必须需要注销重启等等…。</p>
<p>习惯了在 Windows 下的即点即可得，在 Ubuntu 下许多的设置都感觉比较 <strong>不人性化</strong>，或许也是其没有像Windows 一样被大众接受的原因吧。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu Desktop</tag>
      </tags>
  </entry>
</search>
